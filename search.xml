<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vuex</title>
      <link href="/2020/06/13/vuex/"/>
      <url>/2020/06/13/vuex/</url>
      
        <content type="html"><![CDATA[<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><ul><li>VueX是适用于在Vue项目开发时使用的状态管理工具。试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步data中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。为此，Vue为这些被多个组件频繁使用的值提供了一个统一管理的工具——VueX。在具有VueX的Vue项目中，我们只需要把这些值定义在VueX中，即可在整个Vue项目的组件中使用。</li><li>通俗的来说，组件可以调用自己的data数据，但是组件与组件之间无法跨组件调用，这时vuex就显示他的作用了，vuex就像一个前端数据库，把数据存储进去，从而使所有的组件的能够使用</li></ul><h4 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h4><ul><li>npm i vuex -s</li></ul><h4 id="VueX中的核心内容"><a href="#VueX中的核心内容" class="headerlink" title="VueX中的核心内容"></a>VueX中的核心内容</h4><ul><li>state 存放状态<ul><li>state就相当与数据库的数据</li></ul></li><li>mutations state成员操作<ul><li>mutations就相当于增删改查操作</li></ul></li><li>getters 加工state成员给外界</li><li>actions 异步操作<ul><li>异步操作，提交mutations操作</li></ul></li><li>modules 模块化状态管理</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul><li>初始化store下index.js中的内容</li></ul><pre><code>    import Vue from &#39;vue&#39;;    import Vuex from &#39;vuex&#39;;    import actions from &#39;./actions&#39;    import mutations from &#39;./mutations&#39;    Vue.use(Vuex);    const state = {        username:&#39;&#39;,    //用户名        cartcount: 0    //购物车数量    }    export default new Vuex.Store({        state,        actions,        mutations    })</code></pre><ul><li>mutations</li></ul><pre><code>    //商城Vuex-mutation    export default{        saveUserName(state,username){        //改变数据            state.username = username        },        saveCartCount(state,cartcount){            state.cartcount = cartcount        }    }</code></pre><ul><li>actions</li></ul><pre><code>    //商城Vuex-action    export default{        saveUserName(context,username){        //提交            context.commit(&#39;saveUserName&#39;,username)        },        saveCartCount(context,cartcount){            context.commit(&#39;saveCartCount&#39;,cartcount)        }    }</code></pre><h5 id="将store挂载到当前项目的Vue实例当中去"><a href="#将store挂载到当前项目的Vue实例当中去" class="headerlink" title="将store挂载到当前项目的Vue实例当中去"></a>将store挂载到当前项目的Vue实例当中去</h5><ul><li>main.js,这样就可以全局调用了</li></ul><pre><code>    import store from &#39;./store/index&#39;    new Vue({      store,      router: router,      render: h =&gt; h(App),    }).$mount(&#39;#app&#39;)</code></pre><h5 id="dispatch分配actions任务"><a href="#dispatch分配actions任务" class="headerlink" title="dispatch分配actions任务"></a>dispatch分配actions任务</h5><ul><li>可以在App.vue里使用，这样全局都可以使用这个值了</li></ul><pre><code>      this.$store.dispatch(&#39;saveUserName&#39;,res.username)</code></pre><h5 id="渲染延迟"><a href="#渲染延迟" class="headerlink" title="渲染延迟"></a>渲染延迟</h5><ul><li>当我们拉取数据来渲染页面时会有延迟效果，可能渲染不出来获取的值，我们可以用computed来解决</li></ul><pre><code>    computed: {        username() {          return this.$store.state.username;        },        cartcount() {          return this.$store.state.cartcount;        }      },</code></pre><h5 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h5><ul><li>mapState辅助函数可以帮助我们引用state，与上面的效果是一样的</li></ul><pre><code> import { mapState } from &#39;vuex&#39;; computed: {      ...mapState([&#39;username&#39;, &#39;cartcount&#39;])    },</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios</title>
      <link href="/2020/06/13/axios/"/>
      <url>/2020/06/13/axios/</url>
      
        <content type="html"><![CDATA[<h2 id="axios-简介"><a href="#axios-简介" class="headerlink" title="axios 简介"></a>axios 简介</h2><ul><li><p>axios是网络请求封装的框架，axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p><ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API（本身就是一个promise结构）</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防止 CSRF/XSRF</li></ul></li><li><p>引入方式</p></li></ul><pre><code>    npm install axios</code></pre><ul><li>导入使用</li></ul><pre><code>    import axios from &#39;axios&#39;    import VueAxios from &#39;vue-axios&#39;    //VueAxios的作用是将axios框架挂载到vue实例上，这样我们在其他vue文件中使用axios就不用importer了，直接用this.axios    Vue.use(VueAxios,axios)</code></pre><h3 id="设置全局默认值"><a href="#设置全局默认值" class="headerlink" title="设置全局默认值"></a>设置全局默认值</h3><pre><code>    //根据前端跨域进行调整，`baseURL` 将自动加在 `url` 前面    axios.defaults.baseURL = &#39;/api&#39;    // axios.defaults.baseURL = env.baseURL    //设置超时时间    axios.defaults.timeout = 8000</code></pre><h3 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h3><ul><li>可以通过向 axios 传递相关配置来创建请求</li><li>axios(config)最常用的就是这个可以发送各种请求post，get都行</li></ul><pre><code>    // 发送 POST 请求    axios({      method: &#39;post&#39;,      url: &#39;/user/12345&#39;,      data: {        firstName: &#39;Fred&#39;,        lastName: &#39;Flintstone&#39;      }    });    // 发送 GET 请求（默认的方法）    axios(&#39;/user/12345&#39;);</code></pre><ul><li>为方便起见，为所有支持的请求方法提供了别名</li></ul><pre><code>    axios.request(config)    axios.get(url[, config])    axios.delete(url[, config])    axios.head(url[, config])    axios.post(url[, data[, config]])    axios.put(url[, data[, config]])    axios.patch(url[, data[, config]])</code></pre><ul><li>处理并发请求的助手函数</li></ul><pre><code>    axios.all(iterable)    axios.spread(callback)</code></pre><h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><ul><li>不带参</li></ul><pre><code>    this.axios.get(&quot;/carts&quot;).then(res =&gt; {    this.renderData(res);  });</code></pre><ul><li>带参，参数是加在尾部的如：products?pageNum=2&amp;pageSize=1&amp;categoryId=100002</li></ul><pre><code>    this.axios    .get(&quot;/products&quot;, {      params: {        categoryId: &quot;100012&quot;,        pageSize: 14      }    })    .then(res =&gt; {      res.list = res.list.slice(6, 14);      this.phoneList = [res.list.slice(0, 4), res.list.slice(4, 8)];    });</code></pre><h4 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h4><ul><li>带参数</li></ul><pre><code>    let { username, password, email } = this;  this.axios.post(&quot;/user/register&quot;, {    username,    password,    email  }).then(()=&gt;{    this.$message.success(&#39;注册成功&#39;)  });</code></pre><ul><li>不带参    </li></ul><pre><code>    //退出登陆时把名字和购物车数量设为空，弹出退出信息，userid失效    this.axios.post(&quot;/user/logout&quot;).then(() =&gt; {      this.$message.success(&#39;退出成功&#39;);      this.$cookie.set(&#39;userId&#39;, &#39;&#39;, { expires: &#39;-1&#39; });  //关闭的窗口的时候userid失效      this.$store.dispatch(&#39;saveUserName&#39;, &#39;&#39;);      this.$store.dispatch(&#39;saveCartCount&#39;, &#39;0&#39;);    })</code></pre><h4 id="put请求"><a href="#put请求" class="headerlink" title="put请求"></a>put请求</h4><ul><li>不带参</li></ul><pre><code>    let url = this.allChecked ? &quot;/carts/unSelectAll&quot; : &quot;/carts/selectAll&quot;;  this.axios.put(url).then(res =&gt; {    this.renderData(res);  });</code></pre><ul><li>带参</li></ul><pre><code>    this.axios    .put(`/carts/${item.productId}`, {      quantity,      selected    })    .then(res =&gt; {      this.renderData(res);    });</code></pre><h4 id="delete请求"><a href="#delete请求" class="headerlink" title="delete请求"></a>delete请求</h4><pre><code>this.axios.delete(`/carts/${item.productId}`).then(res =&gt; {        this.renderData(res);      })</code></pre><h3 id="自定义创建实例"><a href="#自定义创建实例" class="headerlink" title="自定义创建实例"></a>自定义创建实例</h3><pre><code>    // 使用由库提供的配置的默认值来创建实例    // 此时超时配置的默认值是 `0`    var instance = axios.create();    // 覆写库的超时默认值    // 现在，在超时前，所有请求都会等待 2.5 秒    instance.defaults.timeout = 2500;    // 为已知需要花费很长时间的请求覆写超时设置    instance.get(&#39;/longRequest&#39;, {      timeout: 5000    });</code></pre><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><ul><li>在请求或响应被 then 或 catch 处理前拦截它们。</li></ul><pre><code>    // 添加请求拦截器    axios.interceptors.request.use(function (config) {        // 在发送请求之前做些什么        return config;      }, function (error) {        // 对请求错误做些什么        return Promise.reject(error);      });    // 添加响应拦截器    axios.interceptors.response.use(function (response) {        // 对响应数据做点什么        return response;      }, function (error) {        // 对响应错误做点什么        return Promise.reject(error);      });</code></pre><ul><li>响应结构</li></ul><pre><code>    {      // `data` 由服务器提供的响应      data: {},      // `status` 来自服务器响应的 HTTP 状态码      status: 200,      // `statusText` 来自服务器响应的 HTTP 状态信息      statusText: &#39;OK&#39;,      // `headers` 服务器响应的头      headers: {},      // `config` 是为请求提供的配置信息      config: {}    }    使用 then 时，你将接收下面这样的响应：    axios.get(&#39;/user/12345&#39;)      .then(function(response) {        console.log(response.data);        console.log(response.status);        console.log(response.statusText);        console.log(response.headers);        console.log(response.config);      });</code></pre><h4 id="接口响应拦截"><a href="#接口响应拦截" class="headerlink" title="接口响应拦截"></a>接口响应拦截</h4><pre><code>    //接口错误拦截    axios.interceptors.response.use(function(response){   //拦截页面返回数据状态码      let res = response.data   //返回的数据为response.data，包括status和data      if(res.status == 0){      //状态码为0代表登陆成功        return res.data      }else if(res.status == 10){    //状态码为10代表未登陆，跳转到登陆页面        if(location.hash!=&quot;#/index&quot;){     //如果没有登录则只能访问首页          window.location.href = &quot;/#/login&quot;   //跳转到登陆页面        }        return Promise.reject()   //发生错误，promise返回拒绝值      }else{        Message.error(res.msg)        return Promise.reject()   //发生错误，promise返回拒绝值      }    },(error)=&gt;{    //拦截http请求状态码（请求发送失败）      let res = error.response      Message.error(res.data.message)      return Promise.reject()   //发生错误，promise返回拒绝值    })</code></pre><h4 id="错误拦截"><a href="#错误拦截" class="headerlink" title="错误拦截"></a>错误拦截</h4><ul><li>记住以后的交互请求功能，res最好加上一个默认值，防止请求不到数据时报错，还有记得在main.js的错误拦截处，发生错误时</li></ul><pre><code>    return Promise.reject()   //发生错误，promise返回拒绝值</code></pre><h3 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h3><ul><li>这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。</li></ul><pre><code>    {      // `url` 是用于请求的服务器 URL      url: &#39;/user&#39;,      // `method` 是创建请求时使用的方法      method: &#39;get&#39;, // 默认是 get      // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。      // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL      baseURL: &#39;https://some-domain.com/api/&#39;,      // `transformRequest` 允许在向服务器发送前，修改请求数据      // 只能用在 &#39;PUT&#39;, &#39;POST&#39; 和 &#39;PATCH&#39; 这几个请求方法      // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream      transformRequest: [function (data) {        // 对 data 进行任意转换处理        return data;      }],      // `transformResponse` 在传递给 then/catch 前，允许修改响应数据      transformResponse: [function (data) {        // 对 data 进行任意转换处理        return data;      }],      // `headers` 是即将被发送的自定义请求头      headers: {&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;},      // `params` 是即将与请求一起发送的 URL 参数      // 必须是一个无格式对象(plain object)或 URLSearchParams 对象      params: {        ID: 12345      },      // `paramsSerializer` 是一个负责 `params` 序列化的函数      // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)      paramsSerializer: function(params) {        return Qs.stringify(params, {arrayFormat: &#39;brackets&#39;})      },      // `data` 是作为请求主体被发送的数据      // 只适用于这些请求方法 &#39;PUT&#39;, &#39;POST&#39;, 和 &#39;PATCH&#39;      // 在没有设置 `transformRequest` 时，必须是以下类型之一：      // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams      // - 浏览器专属：FormData, File, Blob      // - Node 专属： Stream      data: {        firstName: &#39;Fred&#39;      },      // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)      // 如果请求超过 `timeout` 的时间，请求将被中断      timeout: 1000,      // `withCredentials` 表示跨域请求时是否需要使用凭证      withCredentials: false, // 默认的      // `adapter` 允许自定义处理请求，以使测试更轻松      // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).      adapter: function (config) {        /* ... */      },      // `auth` 表示应该使用 HTTP 基础验证，并提供凭据      // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头      auth: {        username: &#39;janedoe&#39;,        password: &#39;s00pers3cret&#39;      },      // `responseType` 表示服务器响应的数据类型，可以是 &#39;arraybuffer&#39;, &#39;blob&#39;, &#39;document&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39;      responseType: &#39;json&#39;, // 默认的      // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称      xsrfCookieName: &#39;XSRF-TOKEN&#39;, // default      // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称      xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;, // 默认的      // `onUploadProgress` 允许为上传处理进度事件      onUploadProgress: function (progressEvent) {        // 对原生进度事件的处理      },      // `onDownloadProgress` 允许为下载处理进度事件      onDownloadProgress: function (progressEvent) {        // 对原生进度事件的处理      },      // `maxContentLength` 定义允许的响应内容的最大尺寸      maxContentLength: 2000,      // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte      validateStatus: function (status) {        return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的      },      // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目      // 如果设置为0，将不会 follow 任何重定向      maxRedirects: 5, // 默认的      // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：      // `keepAlive` 默认没有启用      httpAgent: new http.Agent({ keepAlive: true }),      httpsAgent: new https.Agent({ keepAlive: true }),      // &#39;proxy&#39; 定义代理服务器的主机名称和端口      // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据      // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。      proxy: {        host: &#39;127.0.0.1&#39;,        port: 9000,        auth: : {          username: &#39;mikeymike&#39;,          password: &#39;rapunz3l&#39;        }      },      // `cancelToken` 指定用于取消请求的 cancel token      // （查看后面的 Cancellation 这节了解更多）      cancelToken: new CancelToken(function (cancel) {      })    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的引入和具体使用方法，还有服务器部署</title>
      <link href="/2020/06/12/redis/"/>
      <url>/2020/06/12/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这些都是redis的具体使用方法</li></ul><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ul><li>我们使用购物车的时候需要用到redis</li><li>这里我们用的是redis5</li></ul><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre><code>    &lt;!--        redis--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code>    spring:        redis:            host: localhost            port: 6379</code></pre><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>在方法里注入StringRedisTemplate</li></ul><pre><code>    @Autowired    private StringRedisTemplate stringRedisTemplate;</code></pre><ul><li>操作</li></ul><pre><code>    redisTemplate.opsForValue();　　//操作字符串    redisTemplate.opsForHash();　　 //操作hash    redisTemplate.opsForList();　　 //操作list    redisTemplate.opsForSet();　　  //操作set    redisTemplate.opsForZSet();　 　//操作有序set</code></pre><h3 id="StringRedisTemplate与RedisTemplate的区别"><a href="#StringRedisTemplate与RedisTemplate的区别" class="headerlink" title="StringRedisTemplate与RedisTemplate的区别"></a>StringRedisTemplate与RedisTemplate的区别</h3><ul><li>两者的关系是StringRedisTemplate继承RedisTemplate。</li><li>两者的数据是不共通的；也就是说StringRedisTemplate只能管理StringRedisTemplate里面的数据</li><li>RedisTemplate只能管RedisTemplate中的数据。</li><li>SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。</li><li>StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。</li><li>RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。</li></ul><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><ul><li>这里暂时只用到了opsForHash(操作hashmap)，更多操作方法在下面</li></ul><pre><code>    //获取对象，注意这里设置全是String类型的    HashOperations&lt;String, String, String&gt; opsForHash = stringRedisTemplate.opsForHash();    //遍历redis    private List&lt;Cart&gt; listForCart(Integer uid) {            HashOperations&lt;String, String, String&gt; opsForHash = stringRedisTemplate.opsForHash();            //redisKey            String redisKey = String.format(CART_REDIS_KEY_TEMPLATE, uid);            //获取所有键值对            Map&lt;String, String&gt; entries = opsForHash.entries(redisKey);            List&lt;Cart&gt; cartList = new ArrayList&lt;&gt;();            //遍历            for (Map.Entry&lt;String, String&gt; entry : entries.entrySet()) {                //获取值                String value = entry.getValue();                //返回的value是json格式的String类型，需要用Gson转换成Cart对象类型                cartList.add(gson.fromJson(value, Cart.class));            }            return cartList;        }    //put设置或者修改值，注意要数据类型全部转换为String类型    opsForHash.put(redisKey, String.valueOf(cart.getProductId()), gson.toJson(cart));    //delete删除值    opsForHash.delete(redisKey, hashKey);    //获取值        //获取一条值        String value = opsForHash.get(redisKey, hashKey);        //获取所有键值对        Map&lt;String, String&gt; entries = opsForHash.entries(redisKey);</code></pre><h4 id="opsForValue-操作字符串"><a href="#opsForValue-操作字符串" class="headerlink" title="opsForValue(操作字符串)"></a>opsForValue(操作字符串)</h4><pre><code>/** * @author lhz **/public class RedisString {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 新增一个字符串类型的值,key是键，value是值。 * * set(K key, V value) */public void set() {    // 存入永久数据    stringRedisTemplate.opsForValue().set(&quot;test2&quot;, &quot;1&quot;);    // 也可以向redis里存入数据和设置缓存时间    stringRedisTemplate.opsForValue().set(&quot;test1&quot;, &quot;hello redis&quot;, 1000, TimeUnit.SECONDS);}/** * 批量插入，key值存在会覆盖原值 * * multiSet(Map&lt;? extends K,? extends V&gt; map) */public void multiSet() {    Map&lt;String,String&gt; map = new HashMap&lt;&gt;(16);    map.put(&quot;testMultiSet1&quot;, &quot;value0&quot;);    map.put(&quot;testMultiSet2&quot;, &quot;value2&quot;);    stringRedisTemplate.opsForValue().multiSet(map);}/** *  批量插入，如果里面的所有key都不存在，则全部插入，返回true，如果其中一个在redis中已存在，全不插入，返回false * *  multiSetIfAbsent(Map&lt;? extends K,? extends V&gt; map) */public void multiSetIfAbsent() {    Map&lt;String,String&gt; map = new HashMap&lt;&gt;(16);    map.put(&quot;testMultiSet4&quot;, &quot;value1&quot;);    map.put(&quot;testMultiSet3&quot;, &quot;value3&quot;);    Boolean absent = stringRedisTemplate.opsForValue().multiSetIfAbsent(map);    System.out.println(absent);}/** * 如果不存在则插入，返回true为插入成功,false失败 * * setIfAbsent(K key, V value) */public void setIfAbsent() {    Boolean absent = stringRedisTemplate.opsForValue().setIfAbsent(&quot;test&quot;, &quot;hello redis&quot;);    System.out.println(absent);}/** * 获取值,key不存在返回null * * get(Object key) */public void get() {    System.out.println(stringRedisTemplate.opsForValue().get(&quot;testMultiSet1&quot;));}/** * 批量获取，key不存在返回null * * multiGet(Collection&lt;K&gt; keys) */public void multiGet() {    List&lt;String&gt; list = stringRedisTemplate.opsForValue().multiGet(Arrays.asList(&quot;test&quot;, &quot;test2&quot;));    assert list != null;    System.out.println(list.toString());}/** * 获取指定字符串的长度。 * * size(K key) */public void getLength() {    Long size = stringRedisTemplate.opsForValue().size(&quot;test&quot;);    System.out.println(size);}/** * 在原有的值基础上新增字符串到末尾。 * * append(K key, String value) */public void append() {    Integer append = stringRedisTemplate.opsForValue().append(&quot;test3&quot;, &quot;database&quot;);    System.out.println(append);}/** * 获取原来key键对应的值并重新赋新值 * * getAndSet(K key, V value) */public void getAndSet() {    String set = stringRedisTemplate.opsForValue().getAndSet(&quot;test&quot;, &quot;set test&quot;);    System.out.println(set);}/** * 获取指定key的值进行减1，如果value不是integer类型，会抛异常，如果key不存在会创建一个，默认value为0 * * decrement(k key) */public void decrement() {    stringRedisTemplate.opsForValue().decrement(&quot;test2&quot;);    stringRedisTemplate.opsForValue().decrement(&quot;test1&quot;);}/** * 获取指定key的值进行加1，如果value不是integer类型，会抛异常，如果key不存在会创建一个，默认value为0 *  * increment(k key) */public void increment() {    stringRedisTemplate.opsForValue().increment(&quot;test2&quot;);    stringRedisTemplate.opsForValue().increment(&quot;test1&quot;);}/** * 删除指定key,成功返回true，否则false *  * delete(k key) */public void delete() {    Boolean delete = stringRedisTemplate.opsForValue().getOperations().delete(&quot;test1&quot;);    System.out.println(delete);}/** * 删除多个key，返回删除key的个数 *  * delete(k ...keys) */public void deleteMulti() {    Long delete = stringRedisTemplate.opsForValue().getOperations().delete(Arrays.asList(&quot;test1&quot;, &quot;test2&quot;));    System.out.println(delete);}}</code></pre><h4 id="opsForList-操作集合"><a href="#opsForList-操作集合" class="headerlink" title="opsForList(操作集合)"></a>opsForList(操作集合)</h4><pre><code>public class RedisList {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 在变量左边添加元素值。如果key不存在会新建，添加成功返回添加后的总个数 *  * leftPush(K key, V value) */public void leftPush() {    Long aLong = stringRedisTemplate.opsForList().leftPush(&quot;list&quot;, &quot;a&quot;);    System.out.println(aLong);}/** * 向左边批量添加参数元素，如果key不存在会新建，添加成功返回添加后的总个数 *  * leftPushAll(K key, V... values) */public void leftPushAll() {    Long pushAll = stringRedisTemplate.opsForList().leftPushAll(&quot;list&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);    System.out.println(pushAll);}/** * 向集合最右边添加元素。如果key不存在会新建，添加成功返回添加后的总个数 *  * rightPush(K key, V value) */public void rightPush() {    Long aLong = stringRedisTemplate.opsForList().rightPush(&quot;list2&quot;, &quot;a&quot;);    System.out.println(aLong);}/** * 如果存在集合则添加元素。 *  * leftPushIfPresent(K key, V value) */public void leftPushIfPresent() {    Long aLong = stringRedisTemplate.opsForList().leftPushIfPresent(&quot;list&quot;, &quot;h&quot;);    System.out.println(aLong);}/** * 向右边批量添加元素。返回当前集合元素总个数 *  * rightPushAll(K key, V... values) */public void rightPushAll() {    Long aLong = stringRedisTemplate.opsForList().rightPushAll(&quot;list2&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);    System.out.println(aLong);}/** * 向已存在的集合中添加元素。返回集合总元素个数 *  * rightPushIfPresent(K key, V value) */public void rightPushIfPresent() {    Long aLong = stringRedisTemplate.opsForList().rightPushIfPresent(&quot;list&quot;, &quot;e&quot;);    System.out.println(aLong);}/** * 获取集合长度 *  * size(K key) */public void size() {    Long size = stringRedisTemplate.opsForList().size(&quot;list2&quot;);    System.out.println(size);}/** * 移除集合中的左边第一个元素。返回删除的元素，如果元素为空，该集合会自动删除 *  * leftPop(K key) */public void leftPop() {    String pop = stringRedisTemplate.opsForList().leftPop(&quot;list2&quot;);    System.out.println(pop);}/** * 移除集合中左边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。 *  * leftPop(K key, long timeout, TimeUnit unit) */public void leftPopWait() {    String pop = stringRedisTemplate.opsForList().leftPop(&quot;list2&quot;, 10, TimeUnit.SECONDS);    System.out.println(pop);}/** * 移除集合中右边的元素。返回删除的元素，如果元素为空，该集合会自动删除 *  * rightPop(K key) */public void rightPop() {    String pop = stringRedisTemplate.opsForList().rightPop(&quot;list2&quot;);    System.out.println(pop);}/** * 移除集合中右边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。 *  * rightPop(K key, long timeout, TimeUnit unit) */public void rightPopWait() {    String pop = stringRedisTemplate.opsForList().rightPop(&quot;list2&quot;, 10, TimeUnit.SECONDS);    System.out.println(pop);}/** * 移除第一个集合右边的一个元素，插入第二个集合左边插入这个元素 *  * rightPopAndLeftPush(K sourceKey, K destinationKey) */public void rightPopAndLeftPush() {    String s = stringRedisTemplate.opsForList().rightPopAndLeftPush(&quot;list2&quot;, &quot;list3&quot;);    System.out.println(s);}/** * 在集合的指定位置插入元素,如果指定位置已有元素，则覆盖，没有则新增，超过集合下标+n则会报错。 *  * set(K key, long index, V value) */public void set() {    stringRedisTemplate.opsForList().set(&quot;list2&quot;, 2, &quot;w&quot;);}/** * 从存储在键中的列表中删除等于值的元素的第一个计数事件。count&gt; 0：删除等于从左到右移动的值的第一个元素； * count&lt; 0：删除等于从右到左移动的值的第一个元素；count = 0：删除等于value的所有元素 *  * remove(K key, long count, Object value) */public void remove() {    Long remove = stringRedisTemplate.opsForList().remove(&quot;list2&quot;, 2, &quot;w&quot;);    System.out.println(remove);}/** * 截取集合元素长度，保留长度内的数据。 *  * trim(K key, long start, long end) */public void trim() {    stringRedisTemplate.opsForList().trim(&quot;list2&quot;, 0, 3);}/** * 获取集合指定位置的值。 *  * index(K key, long index) */public void index() {    Object listValue = stringRedisTemplate.opsForList().index(&quot;list2&quot;, 3);    System.out.println(listValue);}/** * 获取指定区间的值。 *  * range(K key, long start, long end) */public void range() {    List&lt;String&gt; list = stringRedisTemplate.opsForList().range(&quot;list&quot;, 0, -1);    System.out.println(list);}/** * 删除指定集合,返回true删除成功 *  * delete(K key) */public void delete() {    Boolean delete = stringRedisTemplate.opsForList().getOperations().delete(&quot;list2&quot;);    System.out.println(delete);}}</code></pre><h4 id="opsForHash-操作hashMap"><a href="#opsForHash-操作hashMap" class="headerlink" title="opsForHash(操作hashMap)"></a>opsForHash(操作hashMap)</h4><pre><code>public class RedisHash {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 新增hashMap值 *  * put(H key, HK hashKey, HV value) */public void put() {    stringRedisTemplate.opsForHash().put(&quot;hash&quot;,&quot;hash-key&quot;,&quot;hash-value&quot;);    stringRedisTemplate.opsForHash().put(&quot;hash&quot;,&quot;hash-key2&quot;,&quot;hash-value2&quot;);}/** * 以map集合的形式添加键值对 *  * putAll(H key, Map&lt;? extends HK,? extends HV&gt; m) */public void putAll() {    Map&lt;String, String&gt; map = new HashMap&lt;&gt;(16);    map.put(&quot;hash-key3&quot;, &quot;value3&quot;);    map.put(&quot;hash-key4&quot;, &quot;value4&quot;);    stringRedisTemplate.opsForHash().putAll(&quot;hash&quot;, map);}/** * 如果变量值存在，在变量中可以添加不存在的的键值对，如果变量不存在，则新增一个变量，同时将键值对添加到该变量。添加成功返回true否则返回false *  * putIfAbsent(H key, HK hashKey, HV value) */public void putIfAbsent() {    Boolean absent = stringRedisTemplate.opsForHash().putIfAbsent(&quot;hash&quot;, &quot;hash-key&quot;, &quot;value1&quot;);    Boolean absent2 = stringRedisTemplate.opsForHash().putIfAbsent(&quot;hash&quot;, &quot;hash-key5&quot;, &quot;value5&quot;);    System.out.println(absent);    System.out.println(absent2);}/** * 获取指定变量中的hashMap值。 *  * values(H Key) */public void values() {    List&lt;Object&gt; values = stringRedisTemplate.opsForHash().values(&quot;hash2&quot;);    System.out.println(values.toString());}/** * 获取变量中的键值对。 *  * entries(H key) */public void entries() {    Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(&quot;hash&quot;);    System.out.println(entries.toString());}/** * 获取变量中的指定map键是否有值,如果存在该map键则获取值，没有则返回null。 *  * get(H key, Object hashKey) */public void get() {    Object value = stringRedisTemplate.opsForHash().get(&quot;hash&quot;, &quot;hash-key&quot;);    System.out.println(value);}/** * 获取变量中的键。 *  * keys(H key) */public void keys() {    Set&lt;Object&gt; keys = stringRedisTemplate.opsForHash().keys(&quot;hash&quot;);    System.out.println(keys.toString());}/** *  获取变量的长度 *   *  size(H key) */public void size() {    Long size = stringRedisTemplate.opsForHash().size(&quot;hash&quot;);    System.out.println(size);}/** * 使变量中的键以long值的大小进行自增长。值必须为Integer类型,否则异常 *  * increment(H key, HK hashKey, long data) */public void increment() {    Long increment = stringRedisTemplate.opsForHash().increment(&quot;hash&quot;, &quot;hash-key2&quot;, 1);    System.out.println(increment);}/** * 以集合的方式获取变量中的值。 *  * multiGet(H key, Collection&lt;HK&gt; hashKeys) */public void multiGet() {    List&lt;Object&gt; values = stringRedisTemplate.opsForHash().multiGet(&quot;hash&quot;, Arrays.asList(&quot;hash-key&quot;, &quot;hash-key2&quot;));    System.out.println(values.toString());}/** * 匹配获取键值对，ScanOptions.NONE为获取全部键对，ScanOptions.scanOptions().match(&quot;hash-key2&quot;).build()匹配获取键位map1的键值对,不能模糊匹配。 *  * scan(H key, ScanOptions options) */public void scan() {    Cursor&lt;Map.Entry&lt;Object, Object&gt;&gt; scan = stringRedisTemplate.opsForHash().scan(&quot;hash&quot;, ScanOptions.NONE);    while (scan.hasNext()) {        Map.Entry&lt;Object, Object&gt; next = scan.next();        System.out.println(next.getKey() + &quot;----&gt;&quot; + next.getValue());    }}/** * 删除变量中的键值对，可以传入多个参数，删除多个键值对。返回删除成功数量 *  * delete(H key, Object... hashKeys) */public void delete() {    Long delete = stringRedisTemplate.opsForHash().delete(&quot;hash&quot;, &quot;hash-key&quot;, &quot;hash-key1&quot;);    System.out.println(delete);}}</code></pre><h4 id="opsForSet-操作有序set集合"><a href="#opsForSet-操作有序set集合" class="headerlink" title="opsForSet(操作有序set集合)"></a>opsForSet(操作有序set集合)</h4><pre><code>public class RedisSet {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 向变量中批量添加值。返回添加的数量 * * add(K key, V... values) */public void add() {    Long add = stringRedisTemplate.opsForSet().add(&quot;set&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);    System.out.println(add);}/** * 获取变量的值 * * members(K key) */public void members() {    Set&lt;String&gt; set = stringRedisTemplate.opsForSet().members(&quot;set&quot;);    System.out.println(set);}/** * 获取变量中值得长度 * * size(k key) */public void size() {    Long size = stringRedisTemplate.opsForSet().size(&quot;set&quot;);    System.out.println(size);}/** * 随机获取变量中的某个元素 * * randomMember(k key) */public void randomMember() {    String member = stringRedisTemplate.opsForSet().randomMember(&quot;set&quot;);    System.out.println(member);}/** * 随机获取变量中指定个数的元素 * * randomMembers(k key, long count) */public void randomMembers() {    List&lt;String&gt; members = stringRedisTemplate.opsForSet().randomMembers(&quot;set&quot;, 2);    System.out.println(members);}/** * 检查给定的元素是否在变量中,true为存在 * * isMember(k key, object value) */public void isMember() {    Boolean member = stringRedisTemplate.opsForSet().isMember(&quot;set&quot;, &quot;b&quot;);    System.out.println(member);}/** * 转义变量的元素值到另一个变量中 * * move(k key, v value, k targetKey) */public void move() {    Boolean move = stringRedisTemplate.opsForSet().move(&quot;set&quot;, &quot;b&quot;, &quot;set2&quot;);    System.out.println(move);}/** * 弹出变量中的元素。当元素全部弹完,变量也会删除 * * pop(k key) */public void pop() {    String pop = stringRedisTemplate.opsForSet().pop(&quot;set&quot;);    System.out.println(pop);}/** * 批量删除变量中的元素,返回删除的数量 * * remove(k key, v ...values) */public void remove() {    Long remove = stringRedisTemplate.opsForSet().remove(&quot;set2&quot;, &quot;b&quot;);    System.out.println(remove);}/** * 匹配获取键值对，ScanOptions.NONE为获取全部键值对；ScanOptions.scanOptions().match(&quot;C&quot;).build()匹配获取键位map1的键值对,不能模糊匹配。 * * scan(K key, ScanOptions options) */public void scan() {    Cursor&lt;String&gt; set = stringRedisTemplate.opsForSet().scan(&quot;set&quot;, ScanOptions.NONE);    while (set.hasNext()) {        String next = set.next();        System.out.println(next);    }}/** * 通过集合求差值。 * * difference(k key, k otherKey) */public void difference() {    Set&lt;String&gt; difference = stringRedisTemplate.opsForSet().difference(&quot;set&quot;, &quot;set2&quot;);    System.out.println(difference);}/** * 将求出来的差值元素保存 * * differenceAndStore(K key, K otherKey, K targetKey) */public void differenceAndStore() {    Long aLong = stringRedisTemplate.opsForSet().differenceAndStore(&quot;set&quot;, &quot;set2&quot;, &quot;set3&quot;);    System.out.println(aLong);}/** * 获取去重的随机元素 * * distinctRandomMembers(K key, long count) */public void distinctRandomMembers() {    Set&lt;String&gt; set = stringRedisTemplate.opsForSet().distinctRandomMembers(&quot;set&quot;, 2);    System.out.println(set);}/** * 获取两个变量中的交集 * * intersect(K key, K otherKey) */public void intersect() {    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(&quot;set&quot;, &quot;set2&quot;);    System.out.println(intersect);}/** * 获取2个变量交集后保存到最后一个变量上。 * * intersectAndStore(K key, K otherKey, K targetKey) */public void intersectAndStore() {    Long aLong = stringRedisTemplate.opsForSet().intersectAndStore(&quot;set&quot;, &quot;set2&quot;, &quot;set3&quot;);    System.out.println(aLong);}/** * 获取两个变量的合集 * * union(K key, K otherKey) */public void union() {    Set&lt;String&gt; union = stringRedisTemplate.opsForSet().union(&quot;set&quot;, &quot;set2&quot;);    System.out.println(union);}/** * 获取两个变量合集后保存到另一个变量中 * * unionAndStore(K key, K otherKey, K targetKey) */public void unionAndStore() {    Long aLong = stringRedisTemplate.opsForSet().unionAndStore(&quot;set&quot;, &quot;set2&quot;, &quot;set3&quot;);    System.out.println(aLong);}}</code></pre><h4 id="opsForZset（操作有序set集合）"><a href="#opsForZset（操作有序set集合）" class="headerlink" title="opsForZset（操作有序set集合）"></a>opsForZset（操作有序set集合）</h4><pre><code>public class RedisZSet {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 添加元素到变量中同时指定元素的分值。 * * add(K key, V value, double score) */public void add() {    Boolean add = stringRedisTemplate.opsForZSet().add(&quot;zset&quot;, &quot;a&quot;, 1);    System.out.println(add);}/** * 通过TypedTuple方式新增数据。 * * add(K key, Set&lt;ZSetOperations.TypedTuple&lt;V&gt;&gt; tuples) */public void addByTypedTuple() {    ZSetOperations.TypedTuple&lt;String&gt; typedTuple1 = new DefaultTypedTuple&lt;&gt;(&quot;E&quot;, 2.0);    ZSetOperations.TypedTuple&lt;String&gt; typedTuple2 = new DefaultTypedTuple&lt;&gt;(&quot;F&quot;, 3.0);    ZSetOperations.TypedTuple&lt;String&gt; typedTuple3 = new DefaultTypedTuple&lt;&gt;(&quot;G&quot;, 5.0);    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTupleSet = new HashSet&lt;&gt;();    typedTupleSet.add(typedTuple1);    typedTupleSet.add(typedTuple2);    typedTupleSet.add(typedTuple3);    Long zset = stringRedisTemplate.opsForZSet().add(&quot;zset&quot;, typedTupleSet);    System.out.println(zset);}/** * 获取指定区间的元素 * * range(k key, long start, long end) */public void range() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().range(&quot;zset&quot;, 0, -1);    System.out.println(zset);}/** * 用于获取满足非score的排序取值。这个排序只有在有相同分数的情况下才能使用，如果有不同的分数则返回值不确定。 * * rangeByLex(K key, RedisZSetCommands.Range range) */public void rangeByLex() {    Set&lt;String&gt; rangeByLex = stringRedisTemplate.opsForZSet().rangeByLex(&quot;zset&quot;, RedisZSetCommands.Range.range().lt(&quot;E&quot;));    System.out.println(rangeByLex);}/** * 用于获取满足非score的设置下标开始的长度排序取值。 * * rangeByLex(k key, range range, limit limit) */public void rangeByLexAndLimit() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().rangeByLex(&quot;zset&quot;, RedisZSetCommands.Range.range().lt(&quot;E&quot;),            RedisZSetCommands.Limit.limit().offset(1).count(2));    System.out.println(zset);}/** * 根据设置的score获取区间值。 * * rangeByScore(K key, double min, double max) */public void rangeByScore() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().rangeByScore(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 获取RedisZSetCommands.Tuples的区间值。 * * rangeWithScores(K key, long start, long end) */public void rangeWithScores() {    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zset = stringRedisTemplate.opsForZSet().rangeWithScores(&quot;zset&quot;, 1, 3);    assert zset != null;    for (ZSetOperations.TypedTuple&lt;String&gt; next : zset) {        String value = next.getValue();        Double score = next.getScore();        System.out.println(value + &quot;--&gt;&quot; + score);    }}/** * 获取区间值的个数。 * * count(k key, double min, double max) */public void count() {    Long zset = stringRedisTemplate.opsForZSet().count(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 获取变量中指定元素的索引,下标开始为0 * * rank(k key, object o) */public void rank() {    Long rank = stringRedisTemplate.opsForZSet().rank(&quot;zset&quot;, &quot;a&quot;);    System.out.println(rank);}/** * 匹配获取键值对，ScanOptions.NONE为获取全部键值对；ScanOptions.scanOptions().match(&quot;C&quot;).build()匹配获取键位map1的键值对,不能模糊匹配。 * * scan(K key, ScanOptions options) */public void scan() {    Cursor&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zset = stringRedisTemplate.opsForZSet().scan(&quot;zset&quot;, ScanOptions.NONE);    while (zset.hasNext()) {        ZSetOperations.TypedTuple&lt;String&gt; next = zset.next();        System.out.println(next.getValue() + &quot;--&gt;&quot; + next.getScore());    }}/** * 获取指定元素的分值 * * score(k key, object o) */public void score() {    Double score = stringRedisTemplate.opsForZSet().score(&quot;zset&quot;, &quot;a&quot;);    System.out.println(score);}/** * 获取变量中元素的个数 * * zCard(k key) */public void zCard() {    Long zset = stringRedisTemplate.opsForZSet().zCard(&quot;zset&quot;);    System.out.println(zset);}/** * 修改变量中元素的分值 * * incrementScore(K key, V value, double delta) */public void incrementScore() {    Double score = stringRedisTemplate.opsForZSet().incrementScore(&quot;zset&quot;, &quot;a&quot;, 2);    System.out.println(score);}/** * 索引倒序排列指定区间的元素 * * reverseRange(K key, long start, long end) */public void reverseRange() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().reverseRange(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 倒序排列指定分值区间的元素 * * reverseRangeByScore(K key, double min, double max) */public void reverseRangeByScore() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().reverseRangeByScore(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 倒序排序获取RedisZSetCommands.Tuples的分值区间值 * * reverseRangeByScore(K key, double min, double max, long offset, long count) */public void reverseRangeByScoreLength() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().reverseRangeByScore(&quot;zset&quot;, 1, 3, 1, 2);    System.out.println(zset);}/** * 倒序排序获取RedisZSetCommands.Tuples的分值区间值。 * * reverseRangeByScoreWithScores(K key, double min, double max) */public void reverseRangeByScoreWithScores() {    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zset = stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(&quot;zset&quot;, 1, 5);    assert zset != null;    zset.iterator().forEachRemaining(e-&gt; System.out.println(e.getValue() + &quot;---&gt;&quot; + e.getScore()));}/** * 获取倒序排列的索引值 * * reverseRank(k key, object o) */public void reverseRank() {    Long aLong = stringRedisTemplate.opsForZSet().reverseRank(&quot;zset&quot;, &quot;a&quot;);    System.out.println(aLong);}/** * 获取2个变量的交集存放到第3个变量里面。 * * intersectAndStore(K key, K otherKey, K destKey) */public void intersectAndStore() {    Long aLong = stringRedisTemplate.opsForZSet().intersectAndStore(&quot;zset&quot;, &quot;zset2&quot;, &quot;zset3&quot;);    System.out.println(aLong);}/** * 获取2个变量的合集存放到第3个变量里面。 返回操作的数量 * * unionAndStore(K key, K otherKey, K destKey) */public void unionAndStore() {    Long aLong = stringRedisTemplate.opsForZSet().unionAndStore(&quot;zset&quot;, &quot;zset2&quot;, &quot;zset3&quot;);    System.out.println(aLong);}/** * 批量移除元素根据元素值。返回删除的元素数量 * * remove(K key, Object... values) */public void remove() {    Long remove = stringRedisTemplate.opsForZSet().remove(&quot;zset&quot;, &quot;a&quot;, &quot;b&quot;);    System.out.println(remove);}/** * 根据分值移除区间元素。返回删除的数量 * * removeRangeByScore(k key, double min, double max) */public void removeRangeByScore() {    Long zset = stringRedisTemplate.opsForZSet().removeRangeByScore(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 根据索引值移除区间元素。返回移除的元素集合 * * removeRange(K key, long start, long end) */public void removeRange() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().reverseRange(&quot;zset&quot;, 0, 4);    System.out.println(zset);}}</code></pre><h3 id="阿里云服务器上部署redis-centos7-7"><a href="#阿里云服务器上部署redis-centos7-7" class="headerlink" title="阿里云服务器上部署redis(centos7.7)"></a>阿里云服务器上部署redis(centos7.7)</h3><ul><li>下载包</li></ul><pre><code>    wget wget http://download.redis.io/releases/redis-5.0.8.tar.gz</code></pre><ul><li>解压到指定路径</li></ul><pre><code>    tar -zxvf redis-5.0.8.tar.gz -C /usr/local</code></pre><ul><li>编译</li></ul><pre><code>    cd /usr/local/redis-5.0.8    make</code></pre><ul><li>编译成功将会出现</li></ul><pre><code>    Hint: It&#39;s a good idea to run &#39;make test&#39; 😉    make[1]: Leaving directory `/usr/local/redis-5.0.8/src&#39;</code></pre><ul><li>然后执行下面命令</li></ul><pre><code>    cd /usr/local/redis-5.0.8/src    make install</code></pre><ul><li>成功</li></ul><pre><code>    Hint: It&#39;s a good idea to run &#39;make test&#39; 😉    INSTALL install    INSTALL install    INSTALL install    INSTALL install    INSTALL install</code></pre><ul><li>修改配置文件</li></ul><pre><code>    vim /usr/local/redis-5.0.8/redis.conf    protected-mode no # 关闭保护模式    daemonize yes     # 守护进程模式开启    bind 127.0.0.1  注释掉，不然远程连接不上</code></pre><ul><li>千万记住修改完配置文件后要重启，不然不会生效！！！踩了好大的坑</li></ul><pre><code>    //以下命令一起输入    /usr/local/redis-5.0.8/src/redis-server &amp;    /usr/local/redis-5.0.8/redis.conf</code></pre><ul><li>启动服务端和客户端</li></ul><pre><code>    /usr/local/redis-5.0.8/src/redis-server    /usr/local/redis-5.0.8/src/redis-cli</code></pre><ul><li>后台启动服务端</li></ul><pre><code>    /usr/local/redis-5.0.8/src/redis-server &amp;</code></pre><ul><li>查看redis进程</li></ul><pre><code>    ps -ef | grep redis</code></pre><ul><li>密码登录客户端</li></ul><pre><code>    cd /usr/local/redis-5.0.8/src    ./redis-cli -h 127.0.0.1 -p 6379 -a 980508</code></pre><ul><li>然后就用redis可视化工具测试远程连接，记住要用密码连接</li></ul>]]></content>
      
      
      <categories>
          
          <category> nosql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router路由</title>
      <link href="/2020/06/05/vue-router/"/>
      <url>/2020/06/05/vue-router/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌，对于一个vue开发的spa单页面而言，路由的重要性不言而喻</p><h2 id="vue-router是什么"><a href="#vue-router是什么" class="headerlink" title="vue-router是什么"></a>vue-router是什么</h2><ul><li>这里的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。再通俗的说，vue-router就是WebApp的链接路径管理系统。<br>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。</li><li>至于我们为啥不能用a标签，这是因为用Vue做的都是单页应用（当你的项目准备打包时，运行npm run build时，就会生成dist文件夹，这里面只有静态资源和一个index.html页面），所以你写的<a></a>标签是不起作用的，你必须使用vue-router来进行管理。</li></ul><h2 id="vue-router使用方式"><a href="#vue-router使用方式" class="headerlink" title="vue-router使用方式"></a>vue-router使用方式</h2><ul><li>下载 </li></ul><pre><code>    npm i vue-router --save</code></pre><ul><li>创建router.js文件</li></ul><pre><code>import Router from &#39;vue-router&#39; //导入插件Vue.use(Router);    //安装插件</code></pre><ul><li>创建路由对象并配置路由规则 let router = new VueRouter({routes:[{path:’/home’,component:Home}]});</li></ul><pre><code>    export default new Router({        routes: [    //配置路由，这里是个数组            {       //每一个链接都是一个对象                path: &#39;/&#39;,  //链接路径                name: &#39;home&#39;,   //路由名称                redirect: &#39;/index&#39;,     //重定向                component: Home,    //对应的组件模板                children: [        //子路由                {                    path: &#39;product/:id&#39;,    // /:id表示动态路由 动态传id                    name: &#39;product&#39;,                    component: Product,                },                ]            },        ]    })</code></pre><ul><li>动态路由的取值：this.$route.params.id</li><li>在main.js中引入 router.js</li><li>将其路由对象传递给main.js中Vue的实例，options中加入 router:router</li><li>在app.vue中留坑 <router-view></router-view></li></ul><pre><code>    //app.vue中    &lt;template&gt;        &lt;div&gt;            &lt;!-- 留坑，非常重要 --&gt;            &lt;router-view&gt;&lt;/router-view&gt;        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default {            data(){                return {}            }        }    &lt;/script&gt;</code></pre><h2 id="使用路由模块来实现页面跳转的方式"><a href="#使用路由模块来实现页面跳转的方式" class="headerlink" title="使用路由模块来实现页面跳转的方式"></a>使用路由模块来实现页面跳转的方式</h2><ul><li>1：直接修改地址栏</li><li>2：this.$router.push(‘路由地址’)</li><li>3：<router-link to="路由地址"></router-link></li></ul><h3 id="路由携带参数跳转页面"><a href="#路由携带参数跳转页面" class="headerlink" title="路由携带参数跳转页面"></a>路由携带参数跳转页面</h3><h4 id="使用Query实现路由传参（url中显示参数）"><a href="#使用Query实现路由传参（url中显示参数）" class="headerlink" title="使用Query实现路由传参（url中显示参数）"></a>使用Query实现路由传参（url中显示参数）</h4><pre><code>    //携带参数跳转到订单支付页面    this.$router.push({      path:&#39;/order/pay&#39;,    //路由路径      query:{        orderNo : res.orderNo   //携带参数      }    })</code></pre><ul><li>跳转过去url是携带参数的</li></ul><pre><code>    http://localhost:8080/#/order/pay?orderNo=1589864016971</code></pre><ul><li>获取参数</li></ul><pre><code>    this.$route.query.orderNo</code></pre><h3 id="params传参（url中不显示参数）"><a href="#params传参（url中不显示参数）" class="headerlink" title="params传参（url中不显示参数）"></a>params传参（url中不显示参数）</h3><ul><li>注意：上述这种利用params不显示url传参的方式会导致在刷新页面的时候，传递的值会丢失,这个可以用来判断是从哪个页面跳转过来</li></ul><pre><code>    this.$router.push({        name: &#39;index&#39;,        params:{          from: &#39;login&#39;        }      });</code></pre><ul><li>获取参数</li></ul><pre><code>    this.$route.params.from</code></pre><ul><li>判断</li></ul><pre><code>    //只有从登陆页面跳转过来的时候才会获取购物车数量    if (this.$route.params.from &amp;&amp; this.$route.params.from == &#39;login&#39;) {        this.getCartCount();    }</code></pre><h2 id="路由懒加载vue-router"><a href="#路由懒加载vue-router" class="headerlink" title="路由懒加载vue-router"></a>路由懒加载vue-router</h2><h3 id="什么是懒加载？"><a href="#什么是懒加载？" class="headerlink" title="什么是懒加载？"></a>什么是懒加载？</h3><ul><li>懒加载也就是延迟加载或者按需加载，即在需要的时候进行加载。</li></ul><h3 id="为什么在Vue路由中使用懒加载？"><a href="#为什么在Vue路由中使用懒加载？" class="headerlink" title="为什么在Vue路由中使用懒加载？"></a>为什么在Vue路由中使用懒加载？</h3><ul><li>像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，时间过长，会出啊先长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时；</li><li>简单的说就是：进入首页不用一次加载过多资源造成用时过长；</li></ul><h3 id="如何实现懒加载"><a href="#如何实现懒加载" class="headerlink" title="如何实现懒加载"></a>如何实现懒加载</h3><ul><li>方案一： 在路由文件中使用 reslove=&gt;require([“./pages/HelloWorld.vue”],reslove) 来引入页面模板；</li></ul><pre><code>    export default new Router({        routes: [    //配置路由，这里是个数组            {       //每一个链接都是一个对象                path: &#39;/&#39;,  //链接路径                name: &#39;home&#39;,   //路由名称                redirect: &#39;/index&#39;,     //重定向                component: Home,    //对应的组件模板                children: [        //子路由                    {                        path: &#39;product/:id&#39;,        //动态路由 /:表示动态传id                        name: &#39;product&#39;,                        component: resolve =&gt; require([&#39;./pages/product.vue&#39;], resolve),                    },                    {                        path: &#39;detail/:id&#39;,                        name: &#39;detail&#39;,                        component: resolve =&gt; require([&#39;./pages/detail.vue&#39;], resolve),                    }                ]            ]        })</code></pre><ul><li>方案二：在路由文件中使用  ()=&gt;import(“../components/HelloWorld.vue”) 来引入组件模版；</li><li>但是这个方案用的是es7的语法，可能需要下载一个插件</li></ul><pre><code>    npm install @babel/plugin-syntax-dynamic-import    export default new Router({        routes: [    //配置路由，这里是个数组            {       //每一个链接都是一个对象                path: &#39;/&#39;,  //链接路径                name: &#39;home&#39;,   //路由名称                redirect: &#39;/index&#39;,     //重定向                component: Home,    //对应的组件模板                children: [        //子路由                    {                        path: &#39;product/:id&#39;,        //动态路由 /:表示动态传id                        name: &#39;product&#39;,                        component: () =&gt; import(&#39;./pages/product.vue&#39;)                    },                    {                        path: &#39;detail/:id&#39;,                        name: &#39;detail&#39;,                        component: () =&gt; import(&#39;./pages/detail.vue&#39;)                    }                ]            ]        })</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis三剑客</title>
      <link href="/2020/05/23/mybatis-san-jian-ke/"/>
      <url>/2020/05/23/mybatis-san-jian-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>mybatis用起来非常方便，但是每次都要写实体类，接口，mapping映射文件又显得有些麻烦，那么有没有帮我们生成这些生成这些文件的东西呢，当然有，那就是mybatis三剑客的其中之一mybatis-generator，当然还有两个可以帮助我们是使用mybatis的插件就在后面慢慢介绍</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>Mabatis三剑客分别是：mybatis-generator、mybatis-plugin、mybatis-pagehelper</li></ul><h2 id="一-mybatis-generator"><a href="#一-mybatis-generator" class="headerlink" title="一. mybatis-generator"></a>一. mybatis-generator</h2><ul><li>根据我们的数据库自动生成pojo、dao和xml文件<br>pojo里面放的是跟数据库字段一一对应的对象、dao层是接口，供service使用，xml是这个dao层接口的实现，sql语句都写在xml里</li><li>原理就是连接数据库，获取表机构，生成文件</li><li>如图生成这三个文件<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/39.png" alt=""></li></ul><ul><li>首先引入配置文件，这里用的是1.3.7版本</li></ul><pre><code>    &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.7&lt;/version&gt;            &lt;!--                如果存在文件就不会在生成，只会覆盖--&gt;            &lt;configuration&gt;                &lt;overwrite&gt;true&lt;/overwrite&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;</code></pre><ul><li>然后在main包的resource文件夹下添加文件generatorConfig.xml,如图</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/38.png" alt=""></p><h3 id="generatorConfig-xml详解"><a href="#generatorConfig-xml详解" class="headerlink" title="generatorConfig.xml详解"></a>generatorConfig.xml详解</h3><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;!DOCTYPE generatorConfiguration      PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;    &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;    &lt;!-- 配置生成器 --&gt;    &lt;generatorConfiguration&gt;    &lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用${propertyKey}的方式来引用配置项        resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties                url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.        注意，两个属性只能选址一个;        另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用    &lt;properties resource=&quot;&quot; url=&quot;&quot; /&gt;     --&gt;     &lt;!-- 在MBG工作的时候，需要额外加载的依赖包         location属性指明加载jar/zip包的全路径    &lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&gt;      --&gt;    &lt;!--         context:生成一组对象的环境         id:必选，上下文id，用于在生成错误时提示        defaultModelType:指定生成对象的样式            1，conditional：类似hierarchical；            2，flat：所有内容（主键，blob）等全部生成在一个对象中；            3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)        targetRuntime:            1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；            2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；        introspectedColumnImpl：类全限定名，用于扩展MBG    --&gt;    &lt;context id=&quot;mysql&quot; defaultModelType=&quot;hierarchical&quot; targetRuntime=&quot;MyBatis3Simple&quot; &gt;        &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；            一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖         --&gt;        &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;false&quot;/&gt;        &lt;!-- 生成的Java文件的编码 --&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;!-- 格式化java代码 --&gt;        &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;        &lt;!-- 格式化XML代码 --&gt;        &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;        &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;!-- 必须要有的，使用这个配置链接数据库            @TODO:是否可以扩展         --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:///pss&quot; userId=&quot;root&quot; password=&quot;admin&quot;&gt;            &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;        &lt;/jdbcConnection&gt;        &lt;!-- java类型处理器             用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；            注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型；         --&gt;        &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt;            &lt;!--                 true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型                false：默认,                    scale&gt;0;length&gt;18：使用BigDecimal;                    scale=0;length[10,18]：使用Long；                    scale=0;length[5,9]：使用Integer；                    scale=0;length&lt;5：使用Short；             --&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- java模型创建器，是必须要的元素            负责：1，key类（见context的defaultModelType）；2，java类；3，查询类            targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；            targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录         --&gt;        &lt;javaModelGenerator targetPackage=&quot;com._520it.mybatis.domain&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;!--  for MyBatis3/MyBatis3Simple                自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；             --&gt;            &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;!-- for MyBatis3 / MyBatis3Simple                是否创建一个不可变的类，如果为true，                那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类             --&gt;            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;            &lt;!-- 设置一个根对象，                如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项                注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：                    1，属性名相同，类型相同，有相同的getter/setter方法；             --&gt;            &lt;property name=&quot;rootClass&quot; value=&quot;com._520it.mybatis.domain.BaseDomain&quot;/&gt;            &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- 生成SQL map的XML文件生成器，            注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），                或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置            targetPackage/targetProject:同javaModelGenerator         --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口             targetPackage/targetProject:同javaModelGenerator            type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：                1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；                2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；                3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；            注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER        --&gt;        &lt;javaClientGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; type=&quot;ANNOTATEDMAPPER&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查            &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;             --&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素            选择的table会生成一下文件：            1，SQL map文件            2，生成一个主键类；            3，除了BLOB和主键的其他字段的类；            4，包含BLOB的类；            5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；            6，Mapper接口（可选）            tableName（必要）：要生成对象的表名；            注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会                根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：                1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；                2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；                3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；                4，否则，使用指定的大小写格式查询；            另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；            这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式；            可选：            1，schema：数据库的schema；            2，catalog：数据库的catalog；            3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName            4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；            5，enableInsert（默认true）：指定是否生成insert语句；            6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；            7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；            8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；            9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；            10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；            11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；            12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；            13，modelType：参考context元素的defaultModelType，相当于覆盖；            14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）            15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性            注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；         --&gt;        &lt;table tableName=&quot;userinfo&quot; &gt;            &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;            &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;            &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt;            &lt;property name=&quot;ignoreQualifiersAtRuntime&quot; value=&quot;false&quot;/&gt;            &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;            &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;            &lt;property name=&quot;modelOnly&quot; value=&quot;false&quot;/&gt;            &lt;!-- 参考 javaModelGenerator 的 rootClass 属性             &lt;property name=&quot;rootClass&quot; value=&quot;&quot;/&gt;             --&gt;            &lt;!-- 参考javaClientGenerator 的  rootInterface 属性            &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;            --&gt;            &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog             &lt;property name=&quot;runtimeCatalog&quot; value=&quot;&quot;/&gt;            --&gt;            &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema             &lt;property name=&quot;runtimeSchema&quot; value=&quot;&quot;/&gt;            --&gt;            &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename             &lt;property name=&quot;runtimeTableName&quot; value=&quot;&quot;/&gt;            --&gt;            &lt;!-- 注意，该属性只针对MyBatis3Simple有用；                如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；             --&gt;            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;age desc,username asc&quot;/&gt;            &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;            &lt;!-- generatedKey用于生成生成主键的方法，                如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选                column:主键的列名；                sqlStatement：要生成的selectKey语句，有以下可选项：                    Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()                    DB2       :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()                    DB2_MF    :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1                    Derby      :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()                    HSQLDB      :相当于selectKey的SQL为：CALL IDENTITY()                    Informix  :相当于selectKey的SQL为：select dbinfo(&#39;sqlca.sqlerrd1&#39;) from systables where tabid=1                    MySql      :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()                    SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()                    SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY                    JDBC      :相当于在生成的insert元素上添加useGeneratedKeys=&quot;true&quot;和keyProperty属性            &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot;/&gt;             --&gt;            &lt;!--                 该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，                比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；                那么就可以设置searchString为&quot;^CUST_&quot;，并使用空白替换，那么生成的Customer对象中的属性名称就不是                custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；                注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，                如果使用了columnOverride元素，该属性无效；            &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt;             --&gt;             &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；                 column:要重新设置的列名；                 注意，一个table元素中可以有多个columnOverride元素哈~              --&gt;             &lt;columnOverride column=&quot;username&quot;&gt;                 &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;                 &lt;property name=&quot;property&quot; value=&quot;userName&quot;/&gt;                 &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名                 &lt;property name=&quot;javaType&quot; value=&quot;&quot;/&gt;                  --&gt;                 &lt;!-- jdbcType用于指定该列的JDBC类型                  &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;                  --&gt;                 &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名                     注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler                     只会生成类似：where id = #{id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler}的参数描述                 &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;                 --&gt;                 &lt;!-- 参考table元素的delimitAllColumns配置，默认为false                 &lt;property name=&quot;delimitedColumnName&quot; value=&quot;&quot;/&gt;                  --&gt;             &lt;/columnOverride&gt;             &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现                  column:指定要忽略的列的名字；                 delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false                 注意，一个table元素中可以有多个ignoreColumn元素             &lt;ignoreColumn column=&quot;deptId&quot; delimitedColumnName=&quot;&quot;/&gt;             --&gt;        &lt;/table&gt;    &lt;/context&gt;    &lt;/generatorConfiguration&gt;</code></pre><h3 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h3><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;!DOCTYPE generatorConfiguration            PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;            &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;    &lt;generatorConfiguration&gt;        &lt;!--    windows下路径, 如D:/downloads/xxx.jar--&gt;        &lt;classPathEntry location=&quot;D:/downloads/mybatis/mysql-connector-java-5.1.6.jar&quot; /&gt;        &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;            &lt;!--        不再追加xml内容--&gt;            &lt;plugin type=&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot; /&gt;            &lt;commentGenerator&gt;                &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;            &lt;/commentGenerator&gt;            &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                            connectionURL=&quot;jdbc:mysql://192.168.206.131:3307/mimall?characterEncoding=utf-8&quot;                            userId=&quot;root&quot;                            password=&quot;123456&quot;&gt;            &lt;/jdbcConnection&gt;            &lt;javaTypeResolver &gt;                &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;            &lt;/javaTypeResolver&gt;            &lt;javaModelGenerator targetPackage=&quot;com.imooc.mimall.pojo&quot; targetProject=&quot;src/main/java&quot;&gt;                &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;                &lt;!--            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;--&gt;            &lt;/javaModelGenerator&gt;            &lt;sqlMapGenerator targetPackage=&quot;mappers&quot;  targetProject=&quot;src/main/resources&quot;&gt;                &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;            &lt;/sqlMapGenerator&gt;            &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.imooc.mimall.dao&quot;  targetProject=&quot;src/main/java&quot;&gt;                &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;            &lt;/javaClientGenerator&gt;            &lt;table tableName=&quot;mall_order&quot; domainObjectName=&quot;Order&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;/&gt;            &lt;table tableName=&quot;mall_order_item&quot; domainObjectName=&quot;OrderItem&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;/&gt;            &lt;table tableName=&quot;mall_user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;/&gt;        &lt;/context&gt;    &lt;/generatorConfiguration&gt;</code></pre><h3 id="运行代码生成文件"><a href="#运行代码生成文件" class="headerlink" title="运行代码生成文件"></a>运行代码生成文件</h3><ul><li>配置完成后只需打开终端运行此命令就能生成文件</li></ul><pre><code>    mvn mybatis-generator:generate</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>generatorConfig.xml默认配置中是生成Example类的相关内容，如果不需要Example类，只需要将enableCountByExample、enableCountByExample、enableDeleteByExample、enableSelectByExample设置为true或者去掉这些配置。</li></ul><h2 id="二、Mybatis-plugin插件"><a href="#二、Mybatis-plugin插件" class="headerlink" title="二、Mybatis-plugin插件"></a>二、Mybatis-plugin插件</h2><ul><li>提供Mapper接口与配置文件中对应SQL的导航</li><li>编辑XML文件时自动补全</li><li>自动检查Mapper XML文件中ID冲突</li><li>自动检查Mapper XML文件中错误的属性值</li><li>等等</li></ul><h3 id="Free-Mybatis-plugin插件"><a href="#Free-Mybatis-plugin插件" class="headerlink" title="Free-Mybatis-plugin插件"></a>Free-Mybatis-plugin插件</h3><ul><li>因为Mybatis-plugin插件现在收费了，我们找到一个免费的替代版本</li><li>只需下载插件就行</li><li>我们暂时用到的功能是追踪dao接口和mapper文件里xml的一个插件</li><li>效果：点击dao可以追踪到xml，，同理点击xml的sql右边小箭头，可以追踪到dao方法</li></ul><h2 id="三、Mybatis-pageHelper"><a href="#三、Mybatis-pageHelper" class="headerlink" title="三、Mybatis-pageHelper"></a>三、Mybatis-pageHelper</h2><ul><li>Mybatis-pageHelper是使数据实现分页效果的插件</li></ul><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>    &lt;!--        mybatis分页器--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;        &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.2.13&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>在方法中使用</li></ul><pre><code>    //使用mybatis分页器，pageNum表示第几页，pageSize表示每页的条数    PageHelper.startPage(pageNum,pageSize);    //返回值赋值成productVo类型    List&lt;Product&gt; productList = productMapper.selectByCategoryIdSet(categoryIdSet);    List&lt;ProductVo&gt; productVoList = productList.stream()            .map(e -&gt; {                ProductVo productVo = new ProductVo();                BeanUtils.copyProperties(e, productVo);                return productVo;            })            .collect(Collectors.toList());    PageInfo pageInfo = new PageInfo&lt;&gt;(productList);    //所有查到的数据    pageInfo.setList(productVoList);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis的使用</title>
      <link href="/2020/05/22/mybatis/"/>
      <url>/2020/05/22/mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这是我学习Mybatis做的一些笔记，包括XML和注解两种方法,注解方法只需了解会用就行，XML要熟悉使用</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>Mybatis是一个基于Java的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录</li></ul><h2 id="导入依赖和配置"><a href="#导入依赖和配置" class="headerlink" title="导入依赖和配置"></a>导入依赖和配置</h2><ul><li>依赖，这里我们用的是2.1.0版本</li></ul><pre><code>    &lt;!--        Mybatis--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;2.1.0&lt;/version&gt;            &lt;/dependency&gt;    &lt;!--        数据库--&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                &lt;scope&gt;runtime&lt;/scope&gt;            &lt;/dependency&gt;</code></pre><ul><li>配置</li></ul><pre><code>    spring:      datasource:        password: 123456        username: root        url: jdbc:mysql://192.168.206.131:3307/mimall?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8        driver-class-name: com.mysql.cj.jdbc.Driver    mybatis:      configuration:        map-underscore-to-camel-case: true    #驼峰命名法</code></pre><h2 id="使用Mybatis"><a href="#使用Mybatis" class="headerlink" title="使用Mybatis"></a>使用Mybatis</h2><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><ul><li>新建两个文件如图</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/36.png" alt=""></p><ul><li>Category是对应数据库表设置的实体类</li><li>这里可以使用一个插件免于生成get set toString方法</li><li>导入依赖和下载插件lombok（记住要去下载插件）</li></ul><pre><code>    &lt;!--        lombok插件，自动生成get set方法和toStringFangfa--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;/dependency&gt;</code></pre><ul><li>Category</li></ul><pre><code>    @Data       //自动生成get set toString方法    public class Category {        private Integer id;        private Integer parentId;        private String name;        private Integer status;        private Integer sortOrder;        private Date createTime;        private Date updateTime;    }</code></pre><ul><li>CategoryMapper是对数据库进行增删改查的接口</li><li>需要在接口前写上@Mapper注解</li></ul><pre><code>    @Mapper    public interface CategoryMapper {        @Select(&quot;select * from mall_category where id = #{id}&quot;)        Category findById(@Param(&quot;id&quot;) Integer id);    }</code></pre><ul><li>但是每个注解前都写@Mapper注解就太麻烦了，可以在主类前写上@MapperScan(basePackages = “com.imooc.mimall.dao”)</li></ul><pre><code>    @MapperScan(basePackages = &quot;com.imooc.mimall.dao&quot;)    @SpringBootApplication    public class MimallApplication {        public static void main(String[] args) {            SpringApplication.run(MimallApplication.class, args);        }    }</code></pre><ul><li>测试</li></ul><pre><code>    @Autowired    private CategoryMapper categoryMapper;    @Test    public void findById() {        Category category = categoryMapper.findById(100001);        System.out.println(category.toString());    }</code></pre><h3 id="XML方式"><a href="#XML方式" class="headerlink" title="XML方式"></a>XML方式</h3><ul><li>生成xml文件如图</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/37.png" alt=""></p><ul><li>namespace：增删改查接口所在包</li><li>sql中id是对数据库操作时公共的字段，可以提取出来</li><li>select中id是接口的名字，resultType是对应数据库的类的所在包</li></ul><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;    &lt;!DOCTYPE mapper            PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;            &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;    &lt;mapper namespace=&quot;com.imooc.mimall.dao.CategoryMapper&quot;&gt;    &lt;!--    公共的字段--&gt;        &lt;sql id=&quot;Base_Column_List&quot;&gt;            id, parent_id, name, status, sort_order, create_time, update_time        &lt;/sql&gt;        &lt;select id=&quot;queryById&quot; resultType=&quot;com.imooc.mimall.pojo.Category&quot;&gt;            select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from mall_category where id = #{id}        &lt;/select&gt;    &lt;/mapper&gt;</code></pre><ul><li>CategoryMapper中加入接口，注意不要写sql语句了，xml中写了，对比注解</li></ul><pre><code>    //@Mapper    public interface CategoryMapper {        @Select(&quot;select * from mall_category where id = #{id}&quot;)        Category findById(@Param(&quot;id&quot;) Integer id);        Category queryById(Integer id);    }</code></pre><ul><li>这样就可以用了吗，还是会报错，因为我们yml中没配置mappers中xml所在包，所以无法使用</li></ul><pre><code>    mybatis:      configuration:        map-underscore-to-camel-case: true    #驼峰命名法      mapper-locations: classpath:mappers/*.xml  #使用xml时导入mappers包</code></pre><ul><li>测试和注解方式一摸一样</li></ul><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><ul><li>foreach元素的属性主要有item，index，collection，open，separator，close。<ul><li>item：集合中元素迭代时的别名，该参数为必选。</li><li>index：在list和数组中,index是元素的序号，在map中，index是元素的key，该参数可选</li><li>open：foreach代码的开始符号，一般是(和close=”)”合用。常用在in(),values()时。该参数可选</li><li>separator：元素之间的分隔符，例如在in()的时候，separator=”,”会自动在元素中间用“,“隔开，避免手动输入逗号导致sql错误，如in(1,2,)这样。该参数可选。</li><li>close: foreach代码的关闭符号，一般是)和open=”(“合用。常用在in(),values()时。该参数可选。</li><li>collection: 要做foreach的对象，作为入参时，List对象默认用”list”代替作为键，数组对象有”array”代替作为键，Map对象没有默认的键。当然在作为入参时可以使用@Param(“keyName”)来设置键，设置keyName后，list,array将会失效。 除了入参这种情况外，还有一种作为参数对象的某个字段的时候。举个例子：如果User有属性List ids。入参是User对象，那么这个collection = “ids”.如果User有属性Ids ids;其中Ids是个对象，Ids有个属性List id;入参是User对象，那么collection = “ids.id”</li></ul></li><li>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况： <ul><li>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list .</li><li>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array .</li><li>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key.</li></ul></li></ul><h5 id="mapper接口"><a href="#mapper接口" class="headerlink" title="mapper接口"></a>mapper接口</h5><ul><li>建立增删改查操作时当传入参数为一个集合或者列表时，例如，注意要加上注解@Param</li></ul><pre><code>    List&lt;Product&gt; selectByCategoryIdSet(@Param(&quot;categoryIdSet&quot;) Set&lt;Integer&gt; categoryIdSet);</code></pre><h5 id="xml文件"><a href="#xml文件" class="headerlink" title="xml文件"></a>xml文件</h5><ul><li>这是查询category_id是否在集合内，是就返回</li></ul><pre><code>    &lt;select id=&quot;selectByCategoryIdSet&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select        &lt;include refid=&quot;Base_Column_List&quot;/&gt;        from mall_product        where status = 1        &lt;if test=&quot;categoryIdSet.size() &gt; 0&quot;&gt;            and category_id in            &lt;foreach collection=&quot;categoryIdSet&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;                #{item}            &lt;/foreach&gt;        &lt;/if&gt;    &lt;/select&gt;</code></pre><h4 id="Param注解"><a href="#Param注解" class="headerlink" title="@Param注解"></a>@Param注解</h4><h5 id="使用场景一"><a href="#使用场景一" class="headerlink" title="使用场景一"></a>使用场景一</h5><ul><li>注解单一属性，当传入参数不止一个时使用</li><li>dao层示例</li></ul><pre><code>    int deleteByIdAndUid(@Param(&quot;shippingId&quot;) Integer shippingId,@Param(&quot;userId&quot;) Integer userId);</code></pre><ul><li>xml映射对应示例</li></ul><pre><code>    &lt;delete id=&quot;deleteByIdAndUid&quot; parameterType=&quot;map&quot;&gt;        delete from mall_shipping        where id = #{shippingId,jdbcType=INTEGER}        and user_id = #{userId,jdbcType=INTEGER}      &lt;/delete&gt;</code></pre><p>注意：采用#{}的方式把@Param注解括号内的参数进行引用（括号内参数对应的是形参如 userId对应的是userId）；</p><h5 id="使用场景二"><a href="#使用场景二" class="headerlink" title="使用场景二"></a>使用场景二</h5><ul><li>@Param注解JavaBean对象，当传入参数为一个对象时使用</li><li>dao层示例</li></ul><pre><code>    List&lt;Shipping&gt; selectByIdSet(@Param(&quot;idSet&quot;) Set&lt;Integer&gt; idSet);</code></pre><ul><li>xml映射对应示例</li></ul><pre><code>    &lt;select id=&quot;selectByIdSet&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select        &lt;include refid=&quot;Base_Column_List&quot;/&gt;        from mall_shipping        &lt;where&gt;            &lt;if test=&quot;idSet.size() &gt; 0&quot;&gt;                id in                &lt;foreach collection=&quot;idSet&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;                    #{item}                &lt;/foreach&gt;            &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><h3 id="插入数据获取不到自动生成主键问题"><a href="#插入数据获取不到自动生成主键问题" class="headerlink" title="插入数据获取不到自动生成主键问题"></a>插入数据获取不到自动生成主键问题</h3><ul><li>Springboot中 Mybatis 配置文件 Mapper参数</li><li>useGeneratedKeys=“true” keyProperty=“id”</li><li>useGeneratedKeys设置为 true 时，表示如果插入的表id以自增列为主键，则允许 JDBC 支持自动生成主键，并可将自动生成的主键id返回。</li><li>useGeneratedKeys参数只针对 insert 语句生效，默认为 false；</li><li>dao层示例</li></ul><pre><code>    int insertSelective(Shipping record);</code></pre><ul><li>xml映射文件</li></ul><pre><code>    &lt;!--    允许生成的主键返回--&gt;    &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.imooc.mimall.pojo.Shipping&quot; useGeneratedKeys=&quot;true&quot;                keyProperty=&quot;id&quot;&gt;            insert into mall_shipping            &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;                &lt;if test=&quot;id != null&quot;&gt;                    id,                &lt;/if&gt;                &lt;if test=&quot;userId != null&quot;&gt;                    user_id,                &lt;/if&gt;                &lt;if test=&quot;receiverName != null&quot;&gt;                    receiver_name,                &lt;/if&gt;                &lt;if test=&quot;receiverPhone != null&quot;&gt;                    receiver_phone,                &lt;/if&gt;                &lt;if test=&quot;receiverMobile != null&quot;&gt;                    receiver_mobile,                &lt;/if&gt;                &lt;if test=&quot;receiverProvince != null&quot;&gt;                    receiver_province,                &lt;/if&gt;                &lt;if test=&quot;receiverCity != null&quot;&gt;                    receiver_city,                &lt;/if&gt;                &lt;if test=&quot;receiverDistrict != null&quot;&gt;                    receiver_district,                &lt;/if&gt;                &lt;if test=&quot;receiverAddress != null&quot;&gt;                    receiver_address,                &lt;/if&gt;                &lt;if test=&quot;receiverZip != null&quot;&gt;                    receiver_zip,                &lt;/if&gt;                &lt;if test=&quot;createTime != null&quot;&gt;                    create_time,                &lt;/if&gt;                &lt;if test=&quot;updateTime != null&quot;&gt;                    update_time,                &lt;/if&gt;            &lt;/trim&gt;            &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;                &lt;if test=&quot;id != null&quot;&gt;                    #{id,jdbcType=INTEGER},                &lt;/if&gt;                &lt;if test=&quot;userId != null&quot;&gt;                    #{userId,jdbcType=INTEGER},                &lt;/if&gt;                &lt;if test=&quot;receiverName != null&quot;&gt;                    #{receiverName,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverPhone != null&quot;&gt;                    #{receiverPhone,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverMobile != null&quot;&gt;                    #{receiverMobile,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverProvince != null&quot;&gt;                    #{receiverProvince,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverCity != null&quot;&gt;                    #{receiverCity,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverDistrict != null&quot;&gt;                    #{receiverDistrict,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverAddress != null&quot;&gt;                    #{receiverAddress,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverZip != null&quot;&gt;                    #{receiverZip,jdbcType=VARCHAR},                &lt;/if&gt;            &lt;/trim&gt;        &lt;/insert&gt;</code></pre><h3 id="dao层传入参数为List时"><a href="#dao层传入参数为List时" class="headerlink" title="dao层传入参数为List时"></a>dao层传入参数为List时</h3><ul><li>List中的数据而且还是对象</li><li>dao层示例</li></ul><pre><code>    int batchInsert(@Param(&quot;orderItemList&quot;) List&lt;OrderItem&gt; orderItemList);</code></pre><ul><li>xml映射文件对应示例，因为List中是对象，要一个个获取属性要用#{item.xxx},注意外面的大括号不能丢</li></ul><pre><code>    &lt;insert id=&quot;batchInsert&quot; parameterType=&quot;list&quot;&gt;        insert into mall_order_item (user_id, order_no,        product_id, product_name, product_image,        current_unit_price, quantity, total_price)        values        &lt;foreach collection=&quot;orderItemList&quot; index=&quot;index&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt;            (            #{item.userId},            #{item.orderNo},            #{item.productId},            #{item.productName},            #{item.productImage},            #{item.currentUnitPrice},            #{item.quantity},            #{item.totalPrice}            )        &lt;/foreach&gt;    &lt;/insert&gt;</code></pre><h3 id="dao层传入参数为Set时"><a href="#dao层传入参数为Set时" class="headerlink" title="dao层传入参数为Set时"></a>dao层传入参数为Set时</h3><ul><li>dao层示例</li></ul><pre><code>    List&lt;OrderItem&gt; selectByOrderNoSet(@Param(&quot;orderNoSet&quot;) Set&lt;Long&gt; orderNoSet);</code></pre><ul><li>xml映射文件对应示例，因为set里面不是对象，所以直接获取item就好了，这里用到了open和close</li></ul><pre><code>    &lt;select id=&quot;selectByOrderNoSet&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select        &lt;include refid=&quot;Base_Column_List&quot;/&gt;        from mall_order_item        &lt;where&gt;            &lt;if test=&quot;orderNoSet.size() &gt; 0&quot;&gt;                order_no in                &lt;foreach collection=&quot;orderNoSet&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;                    #{item}                &lt;/foreach&gt;            &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><h3 id="List转Map"><a href="#List转Map" class="headerlink" title="List转Map"></a>List转Map</h3><ul><li>Map value值为对象</li></ul><pre><code>    //获取所有商品    List&lt;Product&gt; products = productMapper.selectByProductIdSet(productIdSet);    //把商品转换成一个map，这样就可以不经数据库查到数据，用到Collectors.toMap()方法    Map&lt;Integer, Product&gt; map = products.stream()            .collect(Collectors.toMap(Product::getId, product -&gt; product));</code></pre><ul><li>Map value为List,List中也是对象</li></ul><pre><code>    List&lt;OrderItem&gt; orderItemList = orderItemMapper.selectByOrderNoSet(orderNoSet);    //list转map，这里因为value是一个List，所以要用到groupingBy    Map&lt;Long, List&lt;OrderItem&gt;&gt; orderItemMap = orderItemList.stream()            .collect(Collectors.groupingBy(OrderItem::getOrderNo));</code></pre><h3 id="List转Set"><a href="#List转Set" class="headerlink" title="List转Set"></a>List转Set</h3><pre><code>    List&lt;Order&gt; orderList = orderMapper.selectByUid(uid);    Set&lt;Integer&gt; shippingIdSet = orderList.stream()            .map(Order::getShippingId)            .collect(Collectors.toSet());</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分页加载，点击按钮加载更多和滚动加载</title>
      <link href="/2020/05/18/fen-ye/"/>
      <url>/2020/05/18/fen-ye/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>如果返回的数据比较少，那么我们放在一个页面没什么问题，但是请求回来的数据比较多，放在一个页面就会用户体验比较差，我们需要把他分开</li><li>这里有三种方法，分页，点击按钮加载更多，和滚动加载更多</li><li>前两种方法是用element-ui的组件，滚动加载则是用一个插件vue-infinite-scroll</li></ul><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><pre><code>    getOrderList() {          this.loading = true       //加载loading          this.axios            .get(&quot;/orders&quot;,{              params:{                pageSize: 5,        //每页跳蛛                pageNum:this.pageNum    //当前页数              }            })            .then(res =&gt; {              this.loading = false;              this.list = res.list;     //当前页面数据              this.total = res.total;   //总条数            })            .catch(() =&gt; {              this.loading = false;            });</code></pre><h3 id="Pagination组件"><a href="#Pagination组件" class="headerlink" title="Pagination组件"></a>Pagination组件</h3><ul><li>做一个应用不可能一个页面都能把所有数据加载完，所以我们要实现分页效果，一页只实现少量的数据，可以分很多页</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>注意，这是一个组件，要在components中引入，这里的语法可能不太好理解，Pagination.name就相当于<el-pagination></el-pagination>，这个是在html中引入的组件</p><pre><code>  import { Pagination } from &quot;element-ui&quot;;  components: {      [Pagination.name]: Pagination    }</code></pre></li></ul><pre><code>     &lt;el-pagination class=&quot;pagination&quot; :pageSize=&quot;pageSize&quot; background layout=&quot;prev, pager, next&quot; :total=&quot;total&quot; @current-change=&quot;handelchange&quot;&gt;&lt;/el-pagination&gt;</code></pre><ul><li><p>这里面的组件包含很多属性，pageSize就是页面的大小可以包含几条数据，total表示总数据，注意属性的调用可能有驼峰命名法，比如文档中调用属性page-size会出错，你要改成pageSize</p></li><li><p>current-change是事件名称，page页改变的时候会触发，回调参数是当前页数</p><pre><code>   //点击触发事件，会有一个回调参数，这个回调参数就是当前的页数      handelchange(pageNum){        this.pageNum = pageNum        this.getOrderList()      }</code></pre></li></ul><h2 id="加载更多"><a href="#加载更多" class="headerlink" title="加载更多"></a>加载更多</h2><h3 id="Button组件"><a href="#Button组件" class="headerlink" title="Button组件"></a>Button组件</h3><ul><li>点击Button组件会加载更多数据</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li><p>组件的loading属性是显示加载loading的，需要动态绑定，在加载时显示，加载完成后关闭，绑定到getOrderList</p><pre><code>  import { Button } from &quot;element-ui&quot;;  components: {      [Button.name]: Button,    }  &lt;el-button type=&quot;primary&quot; :loading=&quot;loading&quot; @click=&quot;loadMore&quot;&gt;加载更多&lt;/el-button&gt;</code></pre></li><li><p>loadMore事件是加载更多</p><pre><code>  loadMore(){        this.pageNum++    //每点击一次页数加1        this.getOrderList()      }</code></pre></li><li><p>我们发现返回的数据没有拼接，只有请求的到数据，我们要把它拼接</p><pre><code>  this.list = this.list.concat(res.list);   //把返回的数据拼接到一起</code></pre></li></ul><h2 id="滚动加载"><a href="#滚动加载" class="headerlink" title="滚动加载"></a>滚动加载</h2><ul><li>开发中总会遇到这种下拉加载的设计方案，Vue实现下拉加载最佳方案自然是使用vue-infinite-scroll来实现。接下来我们一起看下它的配置及使用方式。</li></ul><h3 id="首先我们先了解下他的配置参数："><a href="#首先我们先了解下他的配置参数：" class="headerlink" title="首先我们先了解下他的配置参数："></a>首先我们先了解下他的配置参数：</h3><ul><li>v-infinite-scroll=”loadMore”表示回调函数是loadMore</li><li>infinite-scroll-disabled=”busy”表示由变量busy决定是否执行loadMore，false则执行loadMore，true则不执行，注意，busy表示繁忙，繁忙的时候是不执行的。</li><li>infinite-scroll-distance=”10”这里10决定了页面滚动到离页尾多少像素的时候触发回调函数，10是像素值。一般情况下会在页尾做一个几十像素高的“正在加载中…”，这样的话，可以把这个div的高度设为infinite-scroll-distance的值即可。</li><li>infinite-scroll-immediate-check 默认值为true，该指令表示，应该在绑定后立即检查busy的值和是否滚动到底。假如你的初始内容高度不够，不足以填满可滚动的容器的话，你应设为true，这样会立即执行一次loadMore，会帮你填充一些初始内容。</li><li>infinite-scroll-listen-for-event 当事件在Vue实例中发出时，无限滚动将再次检查。</li><li>infinite-scroll-throttle-delay 检查busy的值的时间间隔，默认值是200，因为vue-infinite-scroll的基础原理是，vue-infinite-scroll会循环检查busy的值，以及是否滚动到底，只有当：busy为false且滚动到底，回调函数才会执行</li></ul><h3 id="安装vue-infinite-scroll"><a href="#安装vue-infinite-scroll" class="headerlink" title="安装vue-infinite-scroll"></a>安装vue-infinite-scroll</h3><pre><code>    npm install vue-infinite-scroll --save</code></pre><h3 id="引入-vue-infinite-scroll"><a href="#引入-vue-infinite-scroll" class="headerlink" title="引入 vue-infinite-scroll"></a>引入 vue-infinite-scroll</h3><ul><li><p>全局引入</p><pre><code>  // register globally（全局引入，在main.js中引入）  import infiniteScroll from &#39;vue-infinite-scroll&#39;  Vue.use(infiniteScroll)</code></pre></li><li><p>局部引入</p><pre><code>  // or for a single instance  import infiniteScroll from &#39;vue-infinite-scroll&#39;  new Vue({    directives: {infiniteScroll}  })</code></pre></li></ul><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><ul><li><p>首先需要引用插件，上面步骤，然后使用，img是加载动画，需要绑定一个loading动态加载</p><pre><code>      &lt;div              v-show=&quot;loading&quot;              v-infinite-scroll=&quot;loadMore&quot;              infinite-scroll-disabled=&quot;busy&quot;              infinite-scroll-distance=&quot;410&quot;            &gt;            &lt;img src=&quot;/imgs/loading-svg/loading-spinning-bubbles.svg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;          &lt;/div&gt;</code></pre></li></ul><ul><li><p>触发事件，下拉都一定程度就会触发</p><pre><code>          loadMore(){        this.busy = true      //触发事件后busy繁忙        setTimeout(()=&gt;{      //防止频繁触发事件，设置0.5秒延迟          this.pageNum++          this.getList()        },500)      },      getList() {        this.loading = true        this.axios          .get(&quot;/orders&quot;, {            params: {              pageSize: 5,              pageNum: this.pageNum            }          })          .then(res =&gt; {            this.list = this.list.concat(res.list);   //拼接            if(res.hasNextPage){                  this.busy = false            }else{              this.busy = true  //如果没有下一页，就禁止掉，下拉将没用，动画也不再显示              this.loading = false            }          })      },</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> element-ui，vue-infinite-scroll </category>
          
      </categories>
      
      
        <tags>
            
            <tag> element-ui </tag>
            
            <tag> vue </tag>
            
            <tag> vue-infinite-scroll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商支付（微信支付和支付宝支付）前端</title>
      <link href="/2020/05/17/dian-shang-zhi-fu/"/>
      <url>/2020/05/17/dian-shang-zhi-fu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>做一个电商平台，那么最必不可少的步骤就是支付了，我们这里只介绍两种最主流的支付方法，微信支付和支付宝支付，众所周知考虑到支付安全等因素，支付要做的大部分事情都是后端承担的，前端只需要做少部分事情与后端对接就可以了，这里我们暂时只讲前端与后端对接的支付功能</li></ul><h2 id="订单页面"><a href="#订单页面" class="headerlink" title="订单页面"></a>订单页面</h2><ul><li>这个页面前期已开发好，暂时只讲支付功能，这个页面的开发就没写出来了。点击微信支付则弹出微信支付框，点击支付宝则跳转到支付宝支付页面（这个相对更安全）</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/31.png" alt=""></p><h2 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h2><ul><li>点击触发事件，携带支付订单号跳转到支付宝页面</li></ul><pre><code>    paySubmit(payment) {          //payment等于1就是支付宝支付，2就是微信支付          if (payment == 1) {            this.payment = 1;            window.open(&quot;/#/order/alipay?orderId=&quot; + this.orderNo, &quot;_blank&quot;); //携带订单号跳转到支付宝支付页面（新页面）          }        }</code></pre><ul><li>alipay页面，调用接口，返回一堆html源码</li><li>我们需要用v-html把他渲染出来，它是一个form表单，我们还需要提交他document.forms[0].submit()，然后就会跳转到支付宝支付页面</li></ul><pre><code>    &lt;template&gt;        &lt;div class=&quot;ali-pay&quot;&gt;            &lt;order-header title=&quot;订单支付&quot;&gt;                &lt;template v-slot:tips&gt;                    &lt;span&gt;请谨防钓鱼链接或诈骗电话，了解更多&lt;/span&gt;                &lt;/template&gt;            &lt;/order-header&gt;            &lt;loading v-if=&quot;loading&quot;&gt;&lt;/loading&gt;            &lt;div class=&quot;form&quot; v-html=&quot;content&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        import OrderHeader from &#39;./../components/OrderHeader&#39;;        import Loading from &#39;./../components/Loading&#39;;        export default {            name: &#39;alipay&#39;,            data() {                return {                    orderId: this.$route.query.orderId,      //订单号                    content: &#39;&#39;,     //支付宝页面html源码                    loading: true   //是否展示loading                }            },            components: {                OrderHeader,                Loading            },            mounted() {                //调用支付宝接口                this.submitPay()            },            methods: {                submitPay() {                    this.axios.post(&#39;/pay&#39;, {                        orderId: this.orderId,                        orderName: &#39;Vue小米高仿商城&#39;,                        amount: 0.01,                        payType: 1,                    }).then((res) =&gt; {                        this.content = res.content                        setTimeout(()=&gt;{                            document.forms[0].submit();     //提交第一个表单数据，跳转到支付宝页面                        },100)                    })                }            },        }    &lt;/script&gt;</code></pre><h3 id="中转页面"><a href="#中转页面" class="headerlink" title="中转页面"></a>中转页面</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/32.png" alt=""></p><h3 id="支付页面"><a href="#支付页面" class="headerlink" title="支付页面"></a>支付页面</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/33.png" alt=""></p><h2 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h2><ul><li>微信支付和支付宝支付调用的接口差不多，只不过微信返回的之一串二维码生成的代码，我们需要解析它</li></ul><h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><ul><li>qrcode是一个可以把代码生成二维码的插件，可以用来生成微信支付二维码</li></ul><pre><code>    cnpm install qrcode --save</code></pre><h3 id="插件的基本使用方法"><a href="#插件的基本使用方法" class="headerlink" title="插件的基本使用方法"></a>插件的基本使用方法</h3><pre><code>    import QRCode from &quot;qrcode&quot;;    QRCode.toDataURL(content)                  .then(url =&gt; {                    console.log(url)    //成功生成二维码                  })                  .catch((err) =&gt; {                    console.log(err)    //失败                  });</code></pre><h3 id="调用接口生成二维码"><a href="#调用接口生成二维码" class="headerlink" title="调用接口生成二维码"></a>调用接口生成二维码</h3><pre><code>    paySubmit(payment) {    if (payment == 2) {            this.payment = 2;            this.axios              .post(&quot;/pay&quot;, {                orderId: this.orderNo,                orderName: &quot;Vue高仿小米商城&quot;,                amount: 0.01,                payType: 2              })              .then(res =&gt; {                  //通过插件生成微信支付二维码                QRCode.toDataURL(res.content)                  .then(url =&gt; {                    this.showPay = true;                    this.payImg = url;                    this.loopOrderState()                  })                  .catch(() =&gt; {                    this.$message.error(&#39;二维码生成失败，请稍后重试&#39;)                  });              });          }        }</code></pre><h3 id="微信支付弹框"><a href="#微信支付弹框" class="headerlink" title="微信支付弹框"></a>微信支付弹框</h3><ul><li>是先做好，点击微信支付则弹出</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/34.png" alt=""></p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><ul><li>我们这里要做的功能是用户扫码之后就会跳转到订单列表，我们要怎么才能知道用户是否已经支付了呢，这里我们一秒轮询一次支付状态，直到用户已经支付，则关闭轮询，跳转到订单列表页面</li></ul><pre><code>    //轮询当前支付状态        loopOrderState(){          //setInterval和setTimeout不一样，这个只要不关闭会一直轮询，setTimeout则只会执行一次          this.T = setInterval(()=&gt;{            this.axios.get(`/orders/${this.orderNo}`).then((res)=&gt;{            if(res.status == 20){              clearInterval(this.T)   //关闭轮询              this.gotoOrderList()            }          })          },1000)        }</code></pre><ul><li>点击关闭微信支付页面，为了更好的用户体验，会弹出一个弹框，让用户自己选择有没有支付（怕网络延迟，支付成功不跳转），当然这里也要关闭轮询</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/35.png" alt=""></p><h3 id="支付完成"><a href="#支付完成" class="headerlink" title="支付完成"></a>支付完成</h3><ul><li>支付完成之后我们还要干嘛呢，就是再次点击微信支付，因为订单已经没有了，就会报一个错，这里我们要提醒用户已经支付，到main.js中去配置,这里的错误是http请求状态码错误，跟返回数据状态码错误不一样</li><li>这里是接口调用失败，http状态码为500，没有返回response数据，所以需要在error里处理</li></ul><pre><code>    //接口错误拦截    axios.interceptors.response.use(function(response){   //拦截页面返回数据状态码      let res = response.data      if(res.status == 0){      //状态码为0代表登陆成功        return res.data      }else if(response.status == 10){    //状态码为10代表未登陆，跳转到登陆页面        if(location.hash!=&#39;#/index&#39;){     //如果没有登录则只能访问首页          window.location.href = &#39;/#/login&#39;   //跳转到登陆页面        }        return Promise.reject()   //发生错误，promise返回拒绝值      }else{        Message.error(res.msg)        return Promise.reject()   //发生错误，promise返回拒绝值      }    },(error)=&gt;{    //拦截http请求状态码（请求发送失败）      let res = error.response      Message.error(res.data.message)      return Promise.reject()   //发生错误，promise返回拒绝值    })</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-cli脚手架</title>
      <link href="/2020/05/13/vue-cli/"/>
      <url>/2020/05/13/vue-cli/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这是我学习vue一段时间后，上手脚手架，做的一些笔记</li></ul><h2 id="什么是脚手架"><a href="#什么是脚手架" class="headerlink" title="什么是脚手架"></a>什么是脚手架</h2><ul><li>vue-cli4.0安装及应用生成，vue-cli4.0是一个脚手架，作用是创建一个初始化的Vue项目，一个很方便的东西，很多东西都封装好了，我们只需要用就行了，约定大于配置</li></ul><h2 id="安装和环境搭建"><a href="#安装和环境搭建" class="headerlink" title="安装和环境搭建"></a>安装和环境搭建</h2><ul><li>安装vue-cli：cnpm i -g @vue/cli（一般会下载最新版本）</li><li>创建项目：vue create + 项目名</li><li>默认babel，eslint自动安装</li></ul><h2 id="vue-cli的使用"><a href="#vue-cli的使用" class="headerlink" title="vue-cli的使用"></a>vue-cli的使用</h2><ul><li>进入文件，启动：cnpm run serve</li><li>使用脚手架的界面ui功能：vue ui，这是脚手架内置的一套可视化的系统，（vue项目管理器，需要导入项目，或者创建项目）</li><li>安装一些依赖插件：axios，vue-router，vuex（这些插件的使用后面会说到）</li></ul><h2 id="脚手架目录结构解析"><a href="#脚手架目录结构解析" class="headerlink" title="脚手架目录结构解析"></a>脚手架目录结构解析</h2><pre><code>    public --- 存放一些公共资源，比如大图片等    resource --- 一些打包的资源，供我们使用    .gitignore --- git忽略配置文件    package-lock.json --- 项目包管控文件    package.json --- 项目配置    README.md --- 项目说明书    dist --- 打包后的项目    src --- 源码目录        |- api --- 承载整个项目的api请求        |- assets --- 存放web中引用的图片 媒体资源        |- components --- 存放可复用组件，你可以在任意页面中复用这些组件        |- util --- 一些公共的方法        |- store --- vuex        |- App.vue --- 是项目入口文件        |- main.js --- 根逻辑，页面加载首先会加载这份js文件。        |- router.js --- 路由文件        |- pages --- 页面</code></pre><h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><h3 id="Vue文件解析"><a href="#Vue文件解析" class="headerlink" title="Vue文件解析"></a>Vue文件解析</h3><ul><li>vue文件初始化一般是template模板包裹一层div来写骨架，然后就是script写逻辑，style写样式</li></ul><pre><code>    &lt;template&gt;        &lt;div&gt;            orderList        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default{            name: &#39;order-list&#39;,        }    &lt;/script&gt;    &lt;style&gt;    &lt;/style&gt;</code></pre><h3 id="watch-和-computed的-简析"><a href="#watch-和-computed的-简析" class="headerlink" title="watch 和 computed的 简析"></a>watch 和 computed的 简析</h3><ul><li>vue提供了2个动态监测data的函数，一个是watch，一个是computed。</li><li>watch： 主要监测已经存在的data，处理data变化后的钩子</li><li>computed： 处理一个已存在的data，返回一个data</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/26.png" alt=""></p><h3 id="vue中引入组件以及父子组件的数据交互"><a href="#vue中引入组件以及父子组件的数据交互" class="headerlink" title="vue中引入组件以及父子组件的数据交互"></a>vue中引入组件以及父子组件的数据交互</h3><ul><li>关于组件，任意vue文件你都可以看做一个组件。在项目中我们一般使用的应该都是单文件组件，单文件组件与页面结构无异，是具有完整功能的一个模块。比如一个评论框，你就可以剥离成一个组件，在任意页面文件中引入这个组件。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/27.png" alt=""></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/28.png" alt=""></p><h3 id="vue过滤器"><a href="#vue过滤器" class="headerlink" title="vue过滤器"></a>vue过滤器</h3><ul><li>在有一些业务场景需要对数据进行一些转换，比如后端图片地址的前缀匹配，这个时候filters就派上大用场了。看个例子感受一下。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/29.png" alt=""></p><h3 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h3><ul><li>路由对于spa应用的重要性不言而喻，整个应用的页面关系都是通过路由定义的。我们先来看看一个路由文件大致是什么样子</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/30.png" alt=""></p><h3 id="可监测的全局变量——vuex"><a href="#可监测的全局变量——vuex" class="headerlink" title="可监测的全局变量——vuex"></a>可监测的全局变量——vuex</h3><ul><li>项目开发中，往往我们会有一些全局变量，但是正常全局变量，vue是不能监测的，这个时候vuex就派上用场了。</li></ul><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><ul><li>VueX是适用于在Vue项目开发时使用的状态管理工具。试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步data中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。为此，Vue为这些被多个组件频繁使用的值提供了一个统一管理的工具——VueX。在具有VueX的Vue项目中，我们只需要把这些值定义在VueX中，即可在整个Vue项目的组件中使用。</li><li>通俗的来说，组件可以调用自己的data数据，但是组件与组件之间无法跨组件调用，这时vuex就显示他的作用了，vuex就像一个前端数据库，把数据存储进去，从而使所有的组件的能够使用</li></ul><h4 id="VueX中的核心内容"><a href="#VueX中的核心内容" class="headerlink" title="VueX中的核心内容"></a>VueX中的核心内容</h4><ul><li>state 存放状态<ul><li>state就相当与数据库的数据</li></ul></li><li>mutations state成员操作<ul><li>mutations就相当于增删改查操作</li></ul></li><li>getters 加工state成员给外界</li><li>actions 异步操作<ul><li>异步操作，提交mutations操作</li></ul></li><li>modules 模块化状态管理</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>    npm install vuex --save    安装好vuex后，我们先新建一个store文件夹，存放vuex相关文件</code></pre><h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><pre><code>    import Vue from &#39;vue&#39;;    import Vuex from &#39;vuex&#39;;    import actions from &#39;./actions&#39;    import mutations from &#39;./mutations&#39;    Vue.use(Vuex);    const state = {        username:&#39;&#39;,    //用户名        cartcount: 0    //购物车数量    }    export default new Vuex.Store({        state,        actions,        mutations    })  </code></pre><h4 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h4><pre><code>    //商城Vuex-mutation    export default{        saveUserName(state,username){        //改变数据            state.username = username        },        saveCartCount(state,cartcount){            state.cartcount = cartcount        }    }</code></pre><h4 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h4><pre><code>    //商城Vuex-action    export default{        saveUserName(context,username){        //提交            context.commit(&#39;saveUserName&#39;,username)        },        saveCartCount(context,cartcount){            context.commit(&#39;saveCartCount&#39;,cartcount)        }    }</code></pre><h4 id="将store挂载到当前项目的Vue实例当中去"><a href="#将store挂载到当前项目的Vue实例当中去" class="headerlink" title="将store挂载到当前项目的Vue实例当中去"></a>将store挂载到当前项目的Vue实例当中去</h4><ul><li>main.js,这样就可以全局调用了</li></ul><pre><code>    import store from &#39;./store/index&#39;    new Vue({      store,      router: router,      render: h =&gt; h(App),    }).$mount(&#39;#app&#39;)</code></pre><h4 id="dispatch分配actions任务"><a href="#dispatch分配actions任务" class="headerlink" title="dispatch分配actions任务"></a>dispatch分配actions任务</h4><ul><li>可以在App.vue里使用，这样全局都可以使用这个值了</li></ul><pre><code>      this.$store.dispatch(&#39;saveUserName&#39;,res.username)</code></pre><h4 id="渲染延迟"><a href="#渲染延迟" class="headerlink" title="渲染延迟"></a>渲染延迟</h4><ul><li>当我们拉取数据来渲染页面时会有延迟效果，可能渲染不出来获取的值，我们可以用computed来解决</li></ul><pre><code>    computed: {        username() {          return this.$store.state.username;        },        cartcount() {          return this.$store.state.cartcount;        }      },</code></pre><h4 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h4><ul><li>mapState辅助函数可以帮助我们引用state，与上面的效果是一样的</li></ul><pre><code> import { mapState } from &#39;vuex&#39;; computed: {      ...mapState([&#39;username&#39;, &#39;cartcount&#39;])    },</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习vue的时候，做的一些笔记</title>
      <link href="/2020/05/12/vue/"/>
      <url>/2020/05/12/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本文主要讲述学习vue时的一些指令</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是vue"><a href="#什么是vue" class="headerlink" title="什么是vue"></a>什么是vue</h3><ul><li>Vue (读音 /vjuː/，类似于 <strong>view) 是一套用于构建用户界面的渐进式框架</strong></li><li>vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合</li></ul><h3 id="安装和环境搭建"><a href="#安装和环境搭建" class="headerlink" title="安装和环境搭建"></a>安装和环境搭建</h3><ul><li>这里建议新手去看vue.js的官方文档，熟悉之后可以上手vue-cli脚手架</li></ul><h2 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h2><ul><li>MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel</li><li>m model<ul><li>数据层 Vue 中 数据层 都放在 data 里面</li></ul></li><li>v view 视图<ul><li>Vue 中 view 即 我们的HTML页面</li></ul></li><li>vm （view-model） 控制器 将数据和视图层建立联系<ul><li>vm 即 Vue 的实例 就是 vm</li></ul></li></ul><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul><li>本质就是自定义属性</li><li>Vue中指定都是以 v- 开头</li></ul><h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><ul><li>防止页面加载时出现闪烁问题</li></ul><pre><code>    &lt;html&gt;     &lt;style type=&quot;text/css&quot;&gt;      /*         1、通过属性选择器 选择到 带有属性 v-cloak的标签  让他隐藏     */      [v-cloak]{        /* 元素隐藏    */        display: none;      }      &lt;/style&gt;    &lt;body&gt;      &lt;div id=&quot;app&quot;&gt;        &lt;!-- 2、 让带有插值 语法的   添加 v-cloak 属性              在 数据渲染完场之后，v-cloak 属性会被自动去除，             v-cloak一旦移除也就是没有这个属性了  属性选择器就选择不到该标签             也就是对应的标签会变为可见        --&gt;        &lt;div  v-cloak  &gt;{{msg}}&lt;/div&gt;      &lt;/div&gt;      &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;      &lt;script type=&quot;text/javascript&quot;&gt;        var vm = new Vue({          //  el   指定元素 id 是 app 的元素            el: &#39;#app&#39;,          //  data  里面存储的是数据          data: {            msg: &#39;Hello Vue&#39;          }        });    &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><ul><li>v-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题</li><li>如果数据中有HTML标签会将html标签一并输出</li><li>注意：此处为单向绑定，数据对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值</li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;        &lt;!--              注意:在指令中不要写插值语法  直接写对应的变量名称             在 v-text 中 赋值的时候不要在写 插值语法            一般属性中不加 {{}}  直接写 对应 的数据名         --&gt;        &lt;p v-text=&quot;msg&quot;&gt;&lt;/p&gt;        &lt;p&gt;            &lt;!-- Vue  中只有在标签的 内容中 才用插值语法 --&gt;            {{msg}}        &lt;/p&gt;    &lt;/div&gt;    &lt;script&gt;        new Vue({            el: &#39;#app&#39;,            data: {                msg: &#39;Hello Vue.js&#39;            }        });    &lt;/script&gt;</code></pre><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><ul><li><p>用法和v-text 相似 但是他可以将HTML片段填充到标签中</p></li><li><p>可能有安全问题, 一般只在可信任内容上使用 v-html，永不用在用户提交的内容上</p></li><li><p>它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。</p></li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;    　　&lt;p v-html=&quot;html&quot;&gt;&lt;/p&gt; &lt;!-- 输出：html标签在渲染的时候被解析 --&gt;        &lt;p&gt;{{message}}&lt;/p&gt; &lt;!-- 输出：&lt;span&gt;通过双括号绑定&lt;/span&gt; --&gt;    　　&lt;p v-text=&quot;text&quot;&gt;&lt;/p&gt; &lt;!-- 输出：&lt;span&gt;html标签在渲染的时候被源码输出&lt;/span&gt; --&gt;    &lt;/div&gt;    &lt;script&gt;    　　let app = new Vue({    　　el: &quot;#app&quot;,    　　data: {    　　　　message: &quot;&lt;span&gt;通过双括号绑定&lt;/span&gt;&quot;,    　　　　html: &quot;&lt;span&gt;html标签在渲染的时候被解析&lt;/span&gt;&quot;,    　　　　text: &quot;&lt;span&gt;html标签在渲染的时候被源码输出&lt;/span&gt;&quot;,    　　}     });    &lt;/script&gt;</code></pre><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><ul><li>显示原始信息跳过编译过程</li><li>跳过这个元素和它的子元素的编译过程。</li><li>一些静态的内容不需要编译加这个指令可以加快渲染</li></ul><pre><code>    &lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;        &lt;!--  显示的是{{ this will not be compiled }}  --&gt;    &lt;span v-pre&gt;{{msg}}&lt;/span&gt;       &lt;!--   即使data里面定义了msg这里仍然是显示的{{msg}}  --&gt;    &lt;script&gt;        new Vue({            el: &#39;#app&#39;,            data: {                msg: &#39;Hello Vue.js&#39;            }        });    &lt;/script&gt;</code></pre><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><ul><li>执行一次性的插值【当数据改变时，插值处的内容不会继续更新】</li></ul><pre><code>      &lt;!-- 即使data里面定义了msg 后期我们修改了 仍然显示的是第一次data里面存储的数据即 Hello Vue.js  --&gt;         &lt;span v-once&gt;{{ msg}}&lt;/span&gt;        &lt;script&gt;        new Vue({            el: &#39;#app&#39;,            data: {                msg: &#39;Hello Vue.js&#39;            }        });    &lt;/script&gt;</code></pre><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul><li>v-model是一个指令，限制在input、select、textarea、components中使用</li><li>双向数据绑定：当数据发生变化的时候，视图也就发生变化<br>当视图发生变化的时候，数据也会跟着同步变化</li></ul><pre><code>     &lt;div id=&quot;app&quot;&gt;          &lt;div&gt;{{msg}}&lt;/div&gt;          &lt;div&gt;              当输入框中内容改变的时候，  页面上的msg  会自动更新            &lt;input type=&quot;text&quot; v-model=&#39;msg&#39;&gt;          &lt;/div&gt;      &lt;/div&gt;</code></pre><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul><li>用来绑定事件的</li><li>形式如：v-on:click 缩写为 @click;</li></ul><pre><code>        &lt;div id=&quot;app&quot;&gt;            &lt;div&gt;{{num}}&lt;/div&gt;            &lt;div&gt;                &lt;!-- 如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数 --&gt;                &lt;button v-on:click=&#39;handle1&#39;&gt;点击1&lt;/button&gt;                &lt;!-- 2、如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，                     并且事件对象的名称必须是$event                 --&gt;                &lt;button v-on:click=&#39;handle2(123, 456, $event)&#39;&gt;点击2&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var vm = new Vue({                el: &#39;#app&#39;,                data: {                    num: 0                },                methods: {                    handle1: function(event) {                        console.log(event.target.innerHTML)                    },                    handle2: function(p, p1, event) {                        console.log(p, p1)                        console.log(event.target.innerHTML)                        this.num++;                    }                }            });        &lt;/script&gt;</code></pre><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul><li>在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。</li><li>Vue 不推荐我们操作DOM 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符</li><li>修饰符是由点开头的指令后缀来表示的</li></ul><pre><code>    &lt;!-- 阻止单击事件继续传播 --&gt;    &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;    &lt;!-- 提交事件不再重载页面 --&gt;    &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;    &lt;!-- 修饰符可以串联   即阻止冒泡也阻止默认事件 --&gt;    &lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;    &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;    &lt;!-- 即事件不是从内部元素触发的 --&gt;    &lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;    使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</code></pre><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><ul><li>在做项目中有时会用到键盘事件，在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符</li></ul><pre><code>    &lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;    &lt;input v-on:keyup.13=&quot;submit&quot;&gt;    &lt;!-- -当点击enter 时调用 `vm.submit()` --&gt;    &lt;input v-on:keyup.enter=&quot;submit&quot;&gt;    &lt;!--当点击enter或者space时  时调用 `vm.alertMe()`   --&gt;    &lt;input type=&quot;text&quot; v-on:keyup.enter.space=&quot;alertMe&quot; &gt;    常用的按键修饰符    .enter =&gt;    enter键    .tab =&gt; tab键    .delete (捕获“删除”和“退格”按键) =&gt;  删除键    .esc =&gt; 取消键    .space =&gt;  空格键    .up =&gt;  上    .down =&gt;  下    .left =&gt;  左    .right =&gt;  右    &lt;script&gt;        var vm = new Vue({            el:&quot;#app&quot;,            methods: {                  submit:function(){},                  alertMe:function(){},            }        })    &lt;/script&gt;</code></pre><h3 id="自定义按键修饰符别名"><a href="#自定义按键修饰符别名" class="headerlink" title="自定义按键修饰符别名"></a>自定义按键修饰符别名</h3><ul><li>在Vue中可以通过config.keyCodes自定义按键修饰符别名</li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;        预先定义了keycode 116（即F5）的别名为f5，因此在文字输入框中按下F5，会触发prompt方法        &lt;input type=&quot;text&quot; v-on:keydown.f5=&quot;prompt()&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        Vue.config.keyCodes.f5 = 116;        let app = new Vue({            el: &#39;#app&#39;,            methods: {                prompt: function() {                    alert(&#39;我是 F5！&#39;);                }            }        });    &lt;/script&gt;</code></pre><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul><li>v-bind 指令被用来响应地更新 HTML 属性</li><li>v-bind:href 可以缩写为 :href;</li></ul><pre><code>    &lt;!-- 绑定一个属性 --&gt;    &lt;img v-bind:src=&quot;imageSrc&quot;&gt;    &lt;!-- 缩写 --&gt;    &lt;img :src=&quot;imageSrc&quot;&gt;</code></pre><h4 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h4><ul><li>我们可以给v-bind:class 一个对象，以动态地切换class。</li><li>注意：v-bind:class指令可以与普通的class特性共存</li></ul><pre><code>    1、 v-bind 中支持绑定一个对象         如果绑定的是一个对象 则 键为 对应的类名  值 为对应data中的数据     &lt;!--         HTML最终渲染为 &lt;ul class=&quot;box textColor textSize&quot;&gt;&lt;/ul&gt;        注意：            textColor，textSize  对应的渲染到页面上的CSS类名                isColor，isSize  对应vue data中的数据  如果为true 则对应的类名 渲染到页面上             当 isColor 和 isSize 变化时，class列表将相应的更新，            例如，将isSize改成false，            class列表将变为 &lt;ul class=&quot;box textColor&quot;&gt;&lt;/ul&gt;    --&gt;    &lt;ul class=&quot;box&quot; v-bind:class=&quot;{textColor:isColor, textSize:isSize}&quot;&gt;        &lt;li&gt;学习Vue&lt;/li&gt;        &lt;li&gt;学习Node&lt;/li&gt;        &lt;li&gt;学习React&lt;/li&gt;    &lt;/ul&gt;      &lt;div v-bind:style=&quot;{color:activeColor,fontSize:activeSize}&quot;&gt;对象语法&lt;/div&gt;    &lt;sript&gt;    var vm= new Vue({        el:&#39;.box&#39;,        data:{            isColor:true,            isSize:true，            activeColor:&quot;red&quot;,            activeSize:&quot;25px&quot;,        }    })    &lt;/sript&gt;    &lt;style&gt;        .box{            border:1px dashed #f0f;        }        .textColor{            color:#f00;            background-color:#eef;        }        .textSize{            font-size:30px;            font-weight:bold;        }    &lt;/style&gt;</code></pre><h4 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h4><pre><code>    2、  v-bind 中支持绑定一个数组    数组中classA和 classB 对应为data中的数据    这里的classA  对用data 中的  classA    这里的classB  对用data 中的  classB    &lt;ul class=&quot;box&quot; :class=&quot;[classA, classB]&quot;&gt;        &lt;li&gt;学习Vue&lt;/li&gt;        &lt;li&gt;学习Node&lt;/li&gt;        &lt;li&gt;学习React&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;    var vm= new Vue({        el:&#39;.box&#39;,        data:{            classA:‘textColor‘,            classB:‘textSize‘        }    })    &lt;/script&gt;    &lt;style&gt;        .box{            border:1px dashed #f0f;        }        .textColor{            color:#f00;            background-color:#eef;        }        .textSize{            font-size:30px;            font-weight:bold;        }    &lt;/style&gt;</code></pre><h4 id="绑定对象和绑定数组-的区别"><a href="#绑定对象和绑定数组-的区别" class="headerlink" title="绑定对象和绑定数组 的区别"></a>绑定对象和绑定数组 的区别</h4><ul><li>绑定对象的时候 对象的属性 即要渲染的类名 对象的属性值对应的是 data 中的数据</li><li>绑定数组的时候数组里面存的是data 中的数据</li></ul><h4 id="绑定style"><a href="#绑定style" class="headerlink" title="绑定style"></a>绑定style</h4><ul><li>不过一般很少这么用</li></ul><pre><code>     &lt;div v-bind:style=&quot;styleObject&quot;&gt;绑定样式对象&lt;/div&gt;&#39;    &lt;!-- CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来)    --&gt;     &lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize,background:&#39;red&#39; }&quot;&gt;内联样式&lt;/div&gt;    &lt;!--组语法可以将多个样式对象应用到同一个元素 --&gt;    &lt;div v-bind:style=&quot;[styleObj1, styleObj2]&quot;&gt;&lt;/div&gt;    &lt;script&gt;        new Vue({          el: &#39;#app&#39;,          data: {            styleObject: {              color: &#39;green&#39;,              fontSize: &#39;30px&#39;,              background:&#39;red&#39;            }，            activeColor: &#39;green&#39;,               fontSize: &quot;30px&quot;          },          styleObj1: {                 color: &#39;red&#39;           },           styleObj2: {                fontSize: &#39;30px&#39;           }    &lt;/script&gt;</code></pre><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="v-if-使用场景"><a href="#v-if-使用场景" class="headerlink" title="v-if 使用场景"></a>v-if 使用场景</h4><ul><li>1- 多个元素 通过条件判断展示或者隐藏某个元素。或者多个元素</li><li>2- 进行两个视图之间的切换</li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;            &lt;!--  判断是否加载，如果为真，就加载，否则不加载--&gt;            &lt;span v-if=&quot;flag&quot;&gt;               如果flag为true则显示,false不显示!            &lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;        var vm = new Vue({            el:&quot;#app&quot;,            data:{                flag:true            }        })    &lt;/script&gt;    ----------------------------------------------------------        &lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt;           A        &lt;/div&gt;      &lt;!-- v-else-if紧跟在v-if或v-else-if之后   表示v-if条件不成立时执行--&gt;        &lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt;           B        &lt;/div&gt;        &lt;div v-else-if=&quot;type === &#39;C&#39;&quot;&gt;           C        &lt;/div&gt;      &lt;!-- v-else紧跟在v-if或v-else-if之后--&gt;        &lt;div v-else&gt;           Not A/B/C        &lt;/div&gt;    &lt;script&gt;        new Vue({          el: &#39;#app&#39;,          data: {            type: &#39;C&#39;          }        })    &lt;/script&gt;</code></pre><h4 id="v-show-和-v-if的区别"><a href="#v-show-和-v-if的区别" class="headerlink" title="v-show 和 v-if的区别"></a>v-show 和 v-if的区别</h4><ul><li>v-show本质就是标签display设置为none，控制隐藏<ul><li>v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。</li></ul></li><li>v-if是动态的向DOM树内添加或者删除DOM元素<ul><li>v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件</li></ul></li><li>v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>相比之下， v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。</li></ul><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><ul><li>用于循环的数组里面的值可以是对象，也可以是普通元素</li></ul><pre><code>    &lt;ul id=&quot;example-1&quot;&gt;       &lt;!-- 循环结构-遍历数组          item 是我们自己定义的一个名字  代表数组里面的每一项          items对应的是 data中的数组--&gt;      &lt;li v-for=&quot;item in items&quot;&gt;        {{ item.message }}      &lt;/li&gt;     &lt;/ul&gt;    &lt;script&gt;     new Vue({      el: &#39;#example-1&#39;,      data: {        items: [          { message: &#39;Foo&#39; },          { message: &#39;Bar&#39; }        ]，      }    })    &lt;/script&gt;</code></pre><ul><li>不推荐同时使用 v-if 和 v-for</li><li>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。</li></ul><pre><code>       &lt;!--  循环结构-遍历对象            v 代表   对象的value            k  代表对象的 键             i  代表索引            ---&gt;          &lt;div v-if=&#39;v==13&#39; v-for=&#39;(v,k,i) in obj&#39;&gt;{{v + '---' + k + '---' + i}}&lt;/div&gt;    &lt;script&gt;     new Vue({      el: &#39;#example-1&#39;,      data: {        items: [          { message: &#39;Foo&#39; },          { message: &#39;Bar&#39; }        ]，        obj: {            uname: &#39;zhangsan&#39;,            age: 13,            gender: &#39;female&#39;        }      }    })    &lt;/script&gt;</code></pre><ul><li>key 的作用<ul><li>key来给每个节点做一个唯一标识</li><li>key的作用主要是为了高效的更新虚拟DOM</li></ul></li></ul><pre><code>    &lt;ul&gt;      &lt;li v-for=&quot;(item,index) in items&quot; :key=&quot;index&quot;&gt;...&lt;/li&gt;    &lt;/ul&gt;</code></pre><h3 id="案例选项卡"><a href="#案例选项卡" class="headerlink" title="案例选项卡"></a>案例选项卡</h3><h4 id="1、-HTML-结构"><a href="#1、-HTML-结构" class="headerlink" title="1、 HTML 结构"></a>1、 HTML 结构</h4><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;tab&quot;&gt;        &lt;!--  tab栏  --&gt;        &lt;ul&gt;            &lt;li class=&quot;active&quot;&gt;apple&lt;/li&gt;            &lt;li class=&quot;&quot;&gt;orange&lt;/li&gt;            &lt;li class=&quot;&quot;&gt;lemon&lt;/li&gt;        &lt;/ul&gt;          &lt;!--  对应显示的图片 --&gt;        &lt;div class=&quot;current&quot;&gt;&lt;img src=&quot;img/apple.png&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;&quot;&gt;&lt;img src=&quot;img/orange.png&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;&quot;&gt;&lt;img src=&quot;img/lemon.png&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h4 id="2、-提供的数据"><a href="#2、-提供的数据" class="headerlink" title="2、 提供的数据"></a>2、 提供的数据</h4><pre><code>     list: [{                id: 1,                title: &#39;apple&#39;,                path: &#39;img/apple.png&#39;            }, {                id: 2,                title: &#39;orange&#39;,                path: &#39;img/orange.png&#39;            }, {                id: 3,                title: &#39;lemon&#39;,                path: &#39;img/lemon.png&#39;            }]</code></pre><h4 id="3、-把数据渲染到页面"><a href="#3、-把数据渲染到页面" class="headerlink" title="3、 把数据渲染到页面"></a>3、 把数据渲染到页面</h4><ul><li>把tab栏 中的数替换到页面上<ul><li>把 data 中 title 利用 v-for 循环渲染到页面上</li><li>把 data 中 path利用 v-for 循环渲染到页面上</li></ul></li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;        &lt;div class=&quot;tab&quot;&gt;              &lt;ul&gt;                  &lt;!--                      1、绑定key的作用 提高Vue的性能                     2、 key 需要是唯一的标识 所以需要使用id， 也可以使用index ，                        index 也是唯一的                     3、 item 是 数组中对应的每一项                      4、 index 是 每一项的 索引                --&gt;                   &lt;li :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;&gt;{{item.title}}&lt;/li&gt;              &lt;/ul&gt;              &lt;div  :key=&#39;item.id&#39; v-for=&#39;(item, index) in list&#39;&gt;                    &lt;!-- :  是 v-bind 的简写   绑定属性使用 v-bind --&gt;                    &lt;img :src=&quot;item.path&quot;&gt;              &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        new  Vue({            //  指定 操作元素 是 id 为app 的             el: &#39;#app&#39;,                data: {                    list: [{                        id: 1,                        title: &#39;apple&#39;,                        path: &#39;img/apple.png&#39;                    }, {                        id: 2,                        title: &#39;orange&#39;,                        path: &#39;img/orange.png&#39;                    }, {                        id: 3,                        title: &#39;lemon&#39;,                        path: &#39;img/lemon.png&#39;                    }]                }        })    &lt;/script&gt;</code></pre><h4 id="4、-给每一个tab栏添加事件-并让选中的高亮"><a href="#4、-给每一个tab栏添加事件-并让选中的高亮" class="headerlink" title="4、 给每一个tab栏添加事件,并让选中的高亮"></a>4、 给每一个tab栏添加事件,并让选中的高亮</h4><ul><li>4.1 、让默认的第一项tab栏高亮<ul><li>tab栏高亮 通过添加类名active 来实现 （CSS active 的样式已经提前写好）<ul><li>在data 中定义一个 默认的 索引 currentIndex 为 0</li><li>给第一个li 添加 active 的类名<ul><li>通过动态绑定class 来实现 第一个li 的索引为 0 和 currentIndex 的值刚好相等</li><li>currentIndex === index 如果相等 则添加类名 active 否则 添加 空类名</li></ul></li></ul></li></ul></li></ul><ul><li>4.2 、让默认的第一项tab栏对应的div 显示<ul><li>实现思路 和 第一个 tab 实现思路一样 只不过 这里控制第一个div 显示的类名是 current</li></ul></li></ul><pre><code>      &lt;ul&gt;           &lt;!-- 动态绑定class   有 active   类名高亮  无 active   不高亮--&gt;           &lt;li  :class=&#39;currentIndex==index?&quot;active&quot;:&quot;&quot;&#39;               :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;               &gt;{{item.title}}&lt;/li&gt;      &lt;/ul&gt;        &lt;!-- 动态绑定class   有 current  类名显示  无 current  隐藏--&gt;      &lt;div :class=&#39;currentIndex==index?&quot;current&quot;:&quot;&quot;&#39;            :key=&#39;item.id&#39; v-for=&#39;(item, index) in list&#39;&gt;            &lt;!-- :  是 v-bind 的简写   绑定属性使用 v-bind --&gt;            &lt;img :src=&quot;item.path&quot;&gt;      &lt;/div&gt;    &lt;script&gt;        new  Vue({            el: &#39;#app&#39;,                data: {                    currentIndex: 0, // 选项卡当前的索引  默认为 0                      list: [{                        id: 1,                        title: &#39;apple&#39;,                        path: &#39;img/apple.png&#39;                    }, {                        id: 2,                        title: &#39;orange&#39;,                        path: &#39;img/orange.png&#39;                    }, {                        id: 3,                        title: &#39;lemon&#39;,                        path: &#39;img/lemon.png&#39;                    }]                }        })    &lt;/script&gt;</code></pre><ul><li>4.3 、点击每一个tab栏 当前的高亮 其他的取消高亮<ul><li>给每一个li添加点击事件</li><li>让当前的索引 index 和 当前 currentIndex 的 值 进项比较</li><li>如果相等 则当前li 添加active 类名 当前的 li 高亮 当前对应索引的 div 添加 current 当前div 显示 其他隐藏</li></ul></li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;        &lt;div class=&quot;tab&quot;&gt;            &lt;ul&gt;                &lt;!--  通过v-on 添加点击事件   需要把当前li 的索引传过去                 --&gt;                &lt;li v-on:click=&#39;change(index)&#39;                                                   :class=&#39;currentIndex==index?&quot;active&quot;:&quot;&quot;&#39;                                       :key=&#39;item.id&#39;                     v-for=&#39;(item,index) in list&#39;&gt;{{item.title}}&lt;/li&gt;            &lt;/ul&gt;            &lt;div :class=&#39;currentIndex==index?&quot;current&quot;:&quot;&quot;&#39;                  :key=&#39;item.id&#39; v-for=&#39;(item, index) in list&#39;&gt;                &lt;img :src=&quot;item.path&quot;&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        new  Vue({            el: &#39;#app&#39;,                data: {                    currentIndex: 0, // 选项卡当前的索引  默认为 0                      list: [{                        id: 1,                        title: &#39;apple&#39;,                        path: &#39;img/apple.png&#39;                    }, {                        id: 2,                        title: &#39;orange&#39;,                        path: &#39;img/orange.png&#39;                    }, {                        id: 3,                        title: &#39;lemon&#39;,                        path: &#39;img/lemon.png&#39;                    }]                },                methods: {                    change: function(index) {                        // 通过传入过来的索引来让当前的  currentIndex  和点击的index 值 相等                         //  从而实现 控制类名                            this.currentIndex = index;                    }                }        })    &lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element-ui的使用</title>
      <link href="/2020/05/12/element-ui/"/>
      <url>/2020/05/12/element-ui/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h3><ul><li>推荐使用 npm 的方式安装，它能更好地和 webpack 打包工具配合使用。</li></ul><pre><code>    npm i element-ui -S</code></pre><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ul><li>目前可以通过 unpkg.com/element-ui 获取到最新版本的资源，在页面上引入 js 和 css 文件即可开始使用。</li></ul><pre><code>    &lt;!-- 引入样式 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;    &lt;!-- 引入组件库 --&gt;    &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="引入Element"><a href="#引入Element" class="headerlink" title="引入Element"></a>引入Element</h3><ul><li>你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。</li></ul><h3 id="完整引入"><a href="#完整引入" class="headerlink" title="完整引入"></a>完整引入</h3><ul><li>你可以在main.js中加入以下内容</li></ul><pre><code>    import ElementUI from &#39;element-ui&#39;;    import &#39;element-ui/lib/theme-chalk/index.css&#39;;    Vue.use(ElementUI);</code></pre><ul><li>以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。</li><li>如果在需要用到大部分组件的时候可以完整引入，只是用到少部分软件建议按需引入，可以减少项目体积</li></ul><h3 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h3><ul><li><p>借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。</p></li><li><p>首先，安装 babel-plugin-component：</p></li></ul><pre><code>    npm install babel-plugin-component -D</code></pre><ul><li>这里官方文档里面是将 .babelrc 修改为：</li></ul><pre><code>    {      &quot;presets&quot;: [[&quot;es2015&quot;, { &quot;modules&quot;: false }]],      &quot;plugins&quot;: [        [          &quot;component&quot;,          {            &quot;libraryName&quot;: &quot;element-ui&quot;,            &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;          }        ]      ]    }</code></pre><ul><li>但是我们可能没有，只有一个babel.config.js,里面的内容比起上面只能解析es2015要强大很多，当然也包括上面的es2015</li></ul><p>“presets”: [<br>    ‘@vue/cli-plugin-babel/preset’<br>  ],</p><ul><li>所以我们只需把这个加入babel.config.js中</li></ul><pre><code>    &quot;plugins&quot;: [        [          &quot;component&quot;,          {            &quot;libraryName&quot;: &quot;element-ui&quot;,            &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;          }        ]      ]</code></pre><ul><li>接下来，如果你只希望引入部分组件，比如 Button 和 Select，那么需要在 main.js 中写入以下内容：</li></ul><pre><code>    import { Button, Select } from &#39;element-ui&#39;;    Vue.component(Button.name, Button);    Vue.component(Select.name, Select);    /* 或写为     * Vue.use(Button)     * Vue.use(Select)     */</code></pre><h3 id="Message组件"><a href="#Message组件" class="headerlink" title="Message组件"></a>Message组件</h3><h4 id="全局使用"><a href="#全局使用" class="headerlink" title="全局使用"></a>全局使用</h4><ul><li>如果每个文件都要import导入那就太麻烦了</li><li>我们用到了Message组件，就以Message组件为例,写入main.js中</li></ul><pre><code>    import { Message } from &#39;element-ui&#39;    Vue.prototype.$message = Message;</code></pre><ul><li>这样我们在全局要是哟个Message组件就可以这样</li></ul><pre><code>    this.$message.info(&#39;消息&#39;)    this.$message.warning(&#39;警告&#39;)    this.$message.success(&#39;成功&#39;)    this.$message.error(&#39;错误&#39;)</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><pre><code>    getOrderList() {          this.loading = true       //加载loading          this.axios            .get(&quot;/orders&quot;,{              params:{                pageSize: 5,        //每页跳蛛                pageNum:this.pageNum    //当前页数              }            })            .then(res =&gt; {              this.loading = false;              this.list = res.list;     //当前页面数据              this.total = res.total;   //总条数            })            .catch(() =&gt; {              this.loading = false;            });</code></pre><h3 id="Pagination组件"><a href="#Pagination组件" class="headerlink" title="Pagination组件"></a>Pagination组件</h3><ul><li>做一个应用不可能一个页面都能把所有数据加载完，所以我们要实现分页效果，一页只实现少量的数据，可以分很多页</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>注意，这是一个组件，要在components中引入，这里的语法可能不太好理解，Pagination.name就相当于<el-pagination></el-pagination>，这个是在html中引入的组件</li></ul><pre><code>    import { Pagination } from &quot;element-ui&quot;;    components: {        [Pagination.name]: Pagination      }     &lt;el-pagination class=&quot;pagination&quot; :pageSize=&quot;pageSize&quot; background layout=&quot;prev, pager, next&quot; :total=&quot;total&quot; @current-change=&quot;handelchange&quot;&gt;&lt;/el-pagination&gt;</code></pre><ul><li>这里面的组件包含很多属性，pageSize就是页面的大小可以包含几条数据，total表示总数据，注意属性的调用可能有驼峰命名法，比如文档中调用属性page-size会出错，你要改成pageSize</li><li>current-change是事件名称，page页改变的时候会触发，回调参数是当前页数</li></ul><pre><code>     //点击触发事件，会有一个回调参数，这个回调参数就是当前的页数        handelchange(pageNum){          this.pageNum = pageNum          this.getOrderList()        }</code></pre><h2 id="加载更多"><a href="#加载更多" class="headerlink" title="加载更多"></a>加载更多</h2><h3 id="Button组件"><a href="#Button组件" class="headerlink" title="Button组件"></a>Button组件</h3><ul><li>点击Button组件会加载更多数据</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li>组件的loading属性是显示加载loading的，需要动态绑定，在加载时显示，加载完成后关闭，绑定到getOrderList</li></ul><pre><code>    import { Button } from &quot;element-ui&quot;;    components: {        [Button.name]: Button,      }    &lt;el-button type=&quot;primary&quot; :loading=&quot;loading&quot; @click=&quot;loadMore&quot;&gt;加载更多&lt;/el-button&gt;</code></pre><ul><li>loadMore事件是加载更多</li></ul><pre><code>    loadMore(){          this.pageNum++    //每点击一次页数加1          this.getOrderList()        }</code></pre><ul><li>我们发现返回的数据没有拼接，只有请求的到数据，我们要把它拼接</li></ul><pre><code>    this.list = this.list.concat(res.list);   //把返回的数据拼接到一起</code></pre>]]></content>
      
      
      <categories>
          
          <category> element-ui </category>
          
      </categories>
      
      
        <tags>
            
            <tag> element-ui </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot安全（spring security）</title>
      <link href="/2020/02/14/springboot-yu-an-quan/"/>
      <url>/2020/02/14/springboot-yu-an-quan/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot与安全（spring-security）"><a href="#SpringBoot与安全（spring-security）" class="headerlink" title="SpringBoot与安全（spring security）"></a>SpringBoot与安全（spring security）</h1><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>比较常见的安全框架有：Apache的shiro、Spring Security等等，相信用shiro的用户群体更多，而security功能更多一些。<br>Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型。他可以实现强大的web安全控制。对于安全控制，我们仅需引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理。几个类：</p><ul><li>WebSecurityConfigurerAdapter：自定义Security策略</li><li>AuthenticationManagerBuilder：自定义认证策略</li><li>@EnableWebSecurity：开启WebSecurity模式</li></ul><ul><li>应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两个主要区域是Spring Security 的两个目标。</li></ul><ul><li>“认证”（Authentication），是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统）。</li></ul><ul><li><p>“授权”（Authorization）指确定一个主体是否允许在你的应用程序执行一个动作的过程。为了抵达需要授权的店，主体的身份已经有认证过程建立。</p></li><li><p>这个概念是通用的而不只在Spring Security中。</p></li></ul><h2 id="Web和安全"><a href="#Web和安全" class="headerlink" title="Web和安全"></a>Web和安全</h2><h3 id="登陆注销"><a href="#登陆注销" class="headerlink" title="登陆注销"></a>登陆注销</h3><ul><li>HttpSecurity配置登陆、注销功能</li></ul><ul><li>Thymeleaf提供的SpringSecurity标签支持<ul><li>需要引入thymeleaf-extras-springsecurity5</li><li><html xmlns:th="http://www.thymeleaf.org"xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurit></li><li>sec:authentication=“name”获得当前用户的用户名</li><li>sec:authorize=“hasRole(‘ADMIN’)”当前用户必须拥有ADMIN权限时才会显示标签内容</li><li>sec:authentication=”principal.authorities” 获取当前用户的权限级别</li><li>sec:authorize=”!isAuthenticated()” 用户没登陆才会显示的标签内容</li><li>sec:authorize=”isAuthenticated()” 用户登陆才会显示的标签内容</li></ul></li></ul><ul><li>remember me<ul><li>表单添加remember-me的checkbox</li><li>配置启用remember-me功能</li></ul></li></ul><ul><li>CSRF（Cross-site request forgery）跨站请求伪造<ul><li>HttpSecurity启用csrf功能，会为表单添加_csrf的值，提交携带来预防CSRF；</li></ul></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;thymeleaf.version&gt;3.0.11.RELEASE&lt;/thymeleaf.version&gt;        &lt;!--布局功能的支持程序  thymeleaf3的主程序  layout2版本以上--&gt;        &lt;thymeleaf-layout-dialect.version&gt;2.4.1&lt;/thymeleaf-layout-dialect.version&gt;        &lt;thymeleaf-extras-springsecurity.version&gt;3.0.4.RELEASE&lt;/thymeleaf-extras-springsecurity.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;        &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><h3 id="测试页面"><a href="#测试页面" class="headerlink" title="测试页面"></a>测试页面</h3><ul><li>welcome.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;h1 align=&quot;center&quot;&gt;欢迎光临武林秘籍管理系统&lt;/h1&gt;    &lt;h2 align=&quot;center&quot;&gt;游客您好，如果想查看武林秘籍 &lt;a th:href=&quot;@{/login}&quot;&gt;请登录&lt;/a&gt;&lt;/h2&gt;    &lt;hr&gt;    &lt;h3&gt;普通武功秘籍&lt;/h3&gt;    &lt;ul&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level1/1}&quot;&gt;罗汉拳&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level1/2}&quot;&gt;武当长拳&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level1/3}&quot;&gt;全真剑法&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;高级武功秘籍&lt;/h3&gt;    &lt;ul&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level2/1}&quot;&gt;太极拳&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level2/2}&quot;&gt;七伤拳&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level2/3}&quot;&gt;梯云纵&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;绝世武功秘籍&lt;/h3&gt;    &lt;ul&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level3/1}&quot;&gt;葵花宝典&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level3/2}&quot;&gt;龟派气功&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level3/3}&quot;&gt;独孤九剑&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><ul><li>login.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;h1 align=&quot;center&quot;&gt;欢迎登陆武林秘籍管理系统&lt;/h1&gt;    &lt;hr&gt;    &lt;div align=&quot;center&quot;&gt;    &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    用户名:&lt;input name=&quot;&quot;/&gt;&lt;br&gt;    密码:&lt;input name=&quot;&quot;&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;    &lt;/form&gt;    &lt;/div&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><h4 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h4><ul><li>1.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a th:href=&quot;@{/}&quot;&gt;返回&lt;/a&gt;        &lt;h1&gt;罗汉拳&lt;/h1&gt;        &lt;p&gt;罗汉拳站当央,打起来不要慌&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><ul><li>2.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a th:href=&quot;@{/}&quot;&gt;返回&lt;/a&gt;        &lt;h1&gt;罗汉拳&lt;/h1&gt;        &lt;p&gt;罗汉拳站当央,打起来不要慌&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><ul><li>3.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a th:href=&quot;@{/}&quot;&gt;返回&lt;/a&gt;        &lt;h1&gt;罗汉拳&lt;/h1&gt;        &lt;p&gt;罗汉拳站当央,打起来不要慌&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><ul><li>level2/3和level1基本一致，页面架构如下</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/18.png" alt=""></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>KungfuController.java</li></ul><pre><code>    package com.atguigu.security.controller;    import org.springframework.stereotype.Controller;    import org.springframework.web.bind.annotation.GetMapping;    import org.springframework.web.bind.annotation.PathVariable;    @Controller    public class KungfuController {        private final String PREFIX = &quot;pages/&quot;;        /**        * 欢迎页        * @return        */        @GetMapping(&quot;/&quot;)        public String index() {            return &quot;welcome&quot;;        }        /**        * 登陆页        * @return        */        @GetMapping(&quot;/userlogin&quot;)        public String loginPage() {            return PREFIX+&quot;login&quot;;        }        /**        * level1页面映射        * @param path        * @return        */        @GetMapping(&quot;/level1/{path}&quot;)        public String level1(@PathVariable(&quot;path&quot;)String path) {            return PREFIX+&quot;level1/&quot;+path;        }        /**        * level2页面映射        * @param path        * @return        */        @GetMapping(&quot;/level2/{path}&quot;)        public String level2(@PathVariable(&quot;path&quot;)String path) {            return PREFIX+&quot;level2/&quot;+path;        }        /**        * level3页面映射        * @param path        * @return        */        @GetMapping(&quot;/level3/{path}&quot;)        public String level3(@PathVariable(&quot;path&quot;)String path) {            return PREFIX+&quot;level3/&quot;+path;        }    }</code></pre><ul><li>访问:localhost:8080</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/19.png" alt=""></p><h3 id="配置授权"><a href="#配置授权" class="headerlink" title="配置授权"></a>配置授权</h3><ul><li>pom文件引入security模块</li></ul><pre><code>    &lt;dependency&gt;    　　&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    　　&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><ul><li>现在所有人都能访问武功秘籍，这时我们要设置一下权限</li></ul><pre><code>    @EnableWebSecurity    public class MySercurityConfig extends WebSecurityConfigurerAdapter {        public void configure(HttpSecurity http) throws Exception {    //定制请求的授权规则    http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()            .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;)            .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;)            .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;VIP3&quot;);    }</code></pre><p>我们现在访问罗汉拳，将会提示403，访问拒绝。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/21.png" alt=""></p><h3 id="开启登陆功能"><a href="#开启登陆功能" class="headerlink" title="开启登陆功能"></a>开启登陆功能</h3><p>这是因为我们还没有登陆访问，加入如下的这段代码，让它为我们自动配置，只要不符合等级规则，就跳转到/login的登录页</p><pre><code>    //开启自动配置的登陆功能，效果，如果没有登陆，没有权限将会来到登陆页面    http.formLogin();    //1./login来到登陆页    //2.重定向来到/login?error表示登陆失败    //3.更多的详细规定</code></pre><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/20.png" alt=""></p><ul><li>登陆成功，访问页面</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/22.png" alt=""></p><h3 id="定义认证功能"><a href="#定义认证功能" class="headerlink" title="定义认证功能"></a>定义认证功能</h3><ul><li>讲我们拥有的用户信息对应匹配规则，然后使用这些账户登录试一下~（这里为了简单说明，我用的是内存保存，当然，可以使用“auth.jdbc…..”来进行数据库的链接使用）</li></ul><pre><code>    //定义认证功能    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        //这里可以改进连数据库        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())                .withUser(&quot;zhangsan&quot;).password(passwordEncoder.encode(&quot;heihei&quot;)).roles(&quot;VIP1&quot;, &quot;VIP2&quot;)                .and()                .withUser(&quot;lisi&quot;).password(passwordEncoder.encode(&quot;123456&quot;)).roles(&quot;VIP2&quot;, &quot;VIP3&quot;)                .and()                .withUser(&quot;wangwu&quot;).password(passwordEncoder.encode(&quot;12456&quot;)).roles(&quot;VIP1&quot;, &quot;VIP3&quot;);</code></pre><h3 id="开启注销功能"><a href="#开启注销功能" class="headerlink" title="开启注销功能"></a>开启注销功能</h3><ul><li>welcome.html</li></ul><pre><code>    &lt;!-- 把这段代码放到你想要的位置，比如登录后边边 --&gt;    &lt;form th:action=&quot;@{/logout}&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;submit&quot; value=&quot;注销&quot;/&gt;    &lt;/form&gt;</code></pre><ul><li>开启自动配置的注销功能</li></ul><pre><code>    http.logout().logoutSuccessUrl(&quot;/&quot;);    //注销成功后去初始页面    //1.访问/logout 表示用户注销，清空session    //2.退出成功将来到/login?logout页面</code></pre><h3 id="优化页面"><a href="#优化页面" class="headerlink" title="优化页面"></a>优化页面</h3><ul><li>让不同用户看到首页展示不同，没有登录的呢，就看不到具体内容。</li><li>pom文件引入springsecurity5；</li></ul><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;        &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><ul><li>在html中改造一下，引入springsecurity5（加两个div做判断是否授权-sec:authorize），如果没有认证（!isAuthenticated()）就展示游客请登录，如果认证了就展示角色信息；读取角色信息（sec:authentication）；</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;          xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity4&quot;&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;        &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;h1 align=&quot;center&quot;&gt;欢迎光临武林秘籍管理系统&lt;/h1&gt;    &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt;        &lt;h2 align=&quot;center&quot;&gt;游客您好，如果想查看武林秘籍 &lt;a th:href=&quot;@{/login}&quot;&gt;请登录&lt;/a&gt;&lt;/h2&gt;    &lt;/div&gt;    &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;        &lt;h2&gt;&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt;，您好，您的角色有:            &lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;&lt;/h2&gt;        &lt;form th:action=&quot;@{/logout}&quot; method=&quot;post&quot;&gt;            &lt;input type=&quot;submit&quot; value=&quot;注销&quot;/&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;hr&gt;    &lt;div sec:authorize=&quot;hasRole(&#39;VIP1&#39;)&quot;&gt;        &lt;h3&gt;普通武功秘籍&lt;/h3&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level1/1}&quot;&gt;罗汉拳&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level1/2}&quot;&gt;武当长拳&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level1/3}&quot;&gt;全真剑法&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div sec:authorize=&quot;hasRole(&#39;VIP2&#39;)&quot;&gt;        &lt;h3&gt;高级武功秘籍&lt;/h3&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level2/1}&quot;&gt;太极拳&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level2/2}&quot;&gt;七伤拳&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level2/3}&quot;&gt;梯云纵&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div sec:authorize=&quot;hasRole(&#39;VIP3&#39;)&quot;&gt;        &lt;h3&gt;绝世武功秘籍&lt;/h3&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level3/1}&quot;&gt;葵花宝典&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level3/2}&quot;&gt;龟派气功&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level3/3}&quot;&gt;独孤九剑&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><p>再次启动就会发现差别</p><ul><li>没登陆状态，只会显示一个请登录页面</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/24.png" alt=""></p><ul><li>登陆状态，成功会显示注销，用户名字，权限等信息</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/23.png" alt=""></p><h3 id="完善页面"><a href="#完善页面" class="headerlink" title="完善页面"></a>完善页面</h3><ul><li>登陆的时候进入我们自己设计的页面，并用用户名和密码作关联<br>http.formLogin().usernameParameter(“user”).passwordParameter(“pwd”).loginPage(“/userlogin”);</li></ul><ul><li><p>welcome.html优化，将登录请求变成userlogin请求；</p></li><li><p>login.html</p></li></ul><pre><code>    &lt;div align=&quot;center&quot;&gt;        &lt;form th:action=&quot;@{/userlogin}&quot; method=&quot;post&quot;&gt;            用户名:&lt;input name=&quot;user&quot;/&gt;&lt;br&gt;            密码:&lt;input name=&quot;pwd&quot;&gt;&lt;br/&gt;            &lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt;记住我&lt;br/&gt;            &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;        &lt;/form&gt;    &lt;/div&gt;</code></pre><ul><li>remeberme优化<br>http.rememberMe().rememberMeParameter(“remember”);</li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot消息(JMS、AMQP、RabbitMQ)</title>
      <link href="/2020/02/11/sprintboot-yu-xiao-xi/"/>
      <url>/2020/02/11/sprintboot-yu-xiao-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot与消息-JMS、AMQP、RabbitMQ"><a href="#SpringBoot与消息-JMS、AMQP、RabbitMQ" class="headerlink" title="SpringBoot与消息(JMS、AMQP、RabbitMQ)"></a>SpringBoot与消息(JMS、AMQP、RabbitMQ)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>1.大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力</li></ul><ul><li><p>2.消息服务中两个重要概念：</p><ul><li>消息代理（message broker）和目的地（destination）<br>当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递指定目的地。</li></ul></li><li><p>3.消息队列主要有两种形式的目的地</p><p>  1.队列（queue）：点对点消息通信（point-to-point）</p><p>  2.主题（topic）：发布（publish）/订阅（subscribe）消息通信</p></li><li><p>4.点对点式：</p><ul><li><p>消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列</p></li><li><p>消息只有唯一的发送者和接受者，但并不是说只能有一个接收者</p></li></ul></li><li><p>5.发布订阅式：</p><ul><li>发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息</li></ul></li><li><p>6.JMS（Java Message Service）JAVA消息服务：</p><ul><li>基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现</li></ul></li><li><p>7.AMQP（Advanced Message Queuing Protocol）</p><ul><li>高级消息队列协议，也是一个消息代理的规范，兼容JMS<br>RabbitMQ是AMQP的实现</li></ul></li><li><p>8.Spring支持</p><ul><li>spring-jms提供了对JMS的支持</li><li>spring-rabbit提供了对AMQP的支持</li><li>需要ConnectionFactory的实现来连接消息代理</li><li>提供JmsTemplate、RabbitTemplate来发送消息</li><li>@JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息</li><li>@EnableJms、@EnableRabbit开启支持</li></ul></li><li><p>9.Spring Boot自动配置</p><ul><li>JmsAutoConfiguration</li><li>RabbitAutoConfiguration</li></ul></li></ul><h2 id="rabbitmq简介"><a href="#rabbitmq简介" class="headerlink" title="rabbitmq简介"></a>rabbitmq简介</h2><ul><li>RabbitMQ简介：</li></ul><p>RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>Message</li></ul><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、pririty（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持性存储）等。</p><ul><li>Publisher</li></ul><p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p><ul><li>Exchange</li></ul><p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。<br>Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别</p><ul><li>Queue</li></ul><p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><ul><li>Binding</li></ul><p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。<br>Exchange 和Queue的绑定可以是多对多的关系。</p><ul><li>Connection</li></ul><p>网络连接，比如一个TCP连接。</p><ul><li>Channel</li></ul><p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><ul><li>Consumer</li></ul><p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><ul><li>Virtual Host</li></ul><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><ul><li>Broker</li></ul><p>表示消息队列服务器实体</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/1.png" alt=""></p><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><ul><li>AMQP 中的消息路由</li></ul><p>AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/2.png" alt=""></p><h3 id="exchange类型"><a href="#exchange类型" class="headerlink" title="exchange类型"></a>exchange类型</h3><ul><li>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键， headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</li></ul><ul><li>Direct Exchange</li></ul><p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/3.png" alt=""></p><ul><li>Fanout Exchange</li></ul><p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/4.png" alt=""></p><ul><li>Topic Exchange</li></ul><p>topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“<em>”。#匹配0个或多个单词，</em>匹配一个单词。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/5.png" alt=""></p><h2 id="docker快速安装"><a href="#docker快速安装" class="headerlink" title="docker快速安装"></a>docker快速安装</h2><ul><li><p>1.拉取镜像</p><ul><li><p>指定版本，该版本包含了web控制页面</p><p>docker pull rabbitmq:3.8.2-management</p></li></ul></li><li><p>2.运行镜像</p><ul><li><p>方式一：默认guest 用户，密码也是 guest</p><p>docker run -d –hostname my-rabbit –name rabbit -p 15672:15672 -p 5672:5672 rabbitmq:3.8.2-management</p></li><li><p>方式二：设置用户名和密码</p><p>docker run -d –hostname my-rabbit –name rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:3.8.2-management</p></li></ul></li><li><p>3.访问url页面</p></li></ul><p><a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/6.jpg" alt=""></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>1.运行流程</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/8.jpg" alt=""></p><ul><li>2.添加交换器</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/7.jpg" alt=""></p><ul><li>3.添加绑定规则</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/9.jpg" alt=""></p><ul><li>4.发布消息</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/10.jpg" alt=""></p><ul><li>5.获取消息</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/11.jpg" alt=""></p><h2 id="整合rabbitmq"><a href="#整合rabbitmq" class="headerlink" title="整合rabbitmq"></a>整合rabbitmq</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>    &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;                &lt;scope&gt;test&lt;/scope&gt;                &lt;exclusions&gt;                    &lt;exclusion&gt;                        &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                        &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                    &lt;/exclusion&gt;                &lt;/exclusions&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;                &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;                &lt;scope&gt;test&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;</code></pre><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>application.properties</p><pre><code>    spring.rabbitmq.host=192.168.206.131    #linux主机地址    spring.rabbitmq.username=guest    spring.rabbitmq.password=guest    spring.rabbitmq.port=5672</code></pre><h3 id="测试rabbitmq"><a href="#测试rabbitmq" class="headerlink" title="测试rabbitmq"></a>测试rabbitmq</h3><ul><li>RabbitTemplate：消息发送处理组件</li></ul><h4 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h4><pre><code>    @Autowired    RabbitTemplate rabbitTemplate;    /**     * 1.单播（点对点）     */    @Test    void test01() {        //需要自己构造一个Message，定义消息体和消息头        //rabbitTemplate.send(exchange,routekey,message);        //object默认当成消息体，只需要传入要发送的对象，自动序列化发送给rabbitmq        //rabbitTemplate.convertAndSend(exchange,routekey,message);        Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,&quot;这是第一条消息&quot;);        map.put(&quot;data&quot;, Arrays.asList(&quot;helloworld&quot;,123,true));        //对象被默认序列化发送出去，是java的序列化规则，我们需要把它转换为json规则        //rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;atguigu.news&quot;,map);        rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;atguigu.news&quot;,map);    }    /**         * 广播（所有键全部发送）         */        @Test        public void test02(){            rabbitTemplate.convertAndSend(&quot;exchange.fanout&quot;,&quot;&quot;,new Book(&quot;上海堡垒&quot;,&quot;江南&quot;));        }</code></pre><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ul><li>对象被默认序列化发送出去，是java的序列化规则，我们需要把它转换为json规则</li></ul><p>MyAMQPConfig</p><pre><code>    //序列化配置    @Configuration    public class MyAMQPConfig {        @Bean        public MessageConverter messageConverter(){                return new Jackson2JsonMessageConverter();        }    }</code></pre><h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><pre><code>    //获取消息，获取完之后就从消息队列里删除        @Test        public void receive(){            Object o = rabbitTemplate.receiveAndConvert(&quot;atguigu.emps&quot;);            System.out.println(o.getClass());            System.out.println(o);        }</code></pre><h3 id="监听机制"><a href="#监听机制" class="headerlink" title="监听机制"></a>监听机制</h3><ul><li><p>@RabbitListener + @EnableRabbit(放于主程序前)    </p><p>  //开启基于注解的rabbitmq监听机制</p></li></ul><pre><code>    @Service    public class BookService {        @RabbitListener(queues = &quot;atguigu.news&quot;)    //参数类型是数组，可以监听多个消息队列        //只要这个消息队列中有消息进来，这个方法就会进行        public void receive(Object o){            System.out.println(&quot;收到消息&quot;+o);        }    }</code></pre><h3 id="amqpadmin"><a href="#amqpadmin" class="headerlink" title="amqpadmin"></a>amqpadmin</h3><ul><li>AmqpAdmin</li></ul><p>rabbitmq系统管理功能组件</p><ul><li>功能</li></ul><p>创建和删除Queue，Exchange，Binding</p><pre><code>    @Autowired    AmqpAdmin amqpAdmin;    /**     * declare是创建，delete是删除     * destination：目的地（哪个消息队列）     * Binding.DestinationType.QUEUE  绑定的类型是queue     * durable:是否持久化     * routingkey：路由键     */    @Test    public void create(){        //创建exchange        amqpAdmin.declareExchange(new DirectExchange(&quot;amqpadmin.exchange&quot;));        System.out.println(&quot;创建exchange成功&quot;);        //创建queue        amqpAdmin.declareQueue(new Queue(&quot;amqpadmin.queue&quot;,true));    //durable:是否持久化        //创建Binding        amqpAdmin.declareBinding(new Binding(&quot;amqpadmin.queue&quot;,Binding.DestinationType.QUEUE,&quot;amqpadmin.exchange&quot;,&quot;amqpadmin.haha&quot;,null));    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot消息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot高级缓存</title>
      <link href="/2020/02/10/springboot-gao-ji-huan-cun-cache/"/>
      <url>/2020/02/10/springboot-gao-ji-huan-cun-cache/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot高级-缓存cache并且整合redis"><a href="#springboot高级-缓存cache并且整合redis" class="headerlink" title="springboot高级,缓存cache并且整合redis"></a>springboot高级,缓存cache并且整合redis</h1><h1 id="springboot缓存"><a href="#springboot缓存" class="headerlink" title="springboot缓存"></a>springboot缓存</h1><p>缓存的场景</p><ul><li>临时性数据存储【校验码】</li><li>避免频繁因为相同的内容查询数据库【查询的信息】</li></ul><h2 id="jsr107缓存规范"><a href="#jsr107缓存规范" class="headerlink" title="jsr107缓存规范"></a>jsr107缓存规范</h2><blockquote><p>用的比较少</p></blockquote><p>Java Caching定义了5个核心接口</p><ul><li><p>CachingProvider</p><p>定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期间访问多个CachingProvider</p></li><li><p>CacheManager</p><p>定义了创建、配置、获取、管理和控制多个唯一命名的Cache,这些Cache存在于CacheManage的上下文中，一个CacheManage只被一个CachingProvider拥有</p></li><li><p>Cache</p><p>类似于Map的数据结构并临时储存以key为索引的值，一个Cache仅仅被一个CacheManage所拥有</p></li><li><p>Entry</p><p>存储在Cache中的key-value对</p></li><li><p>Expiry</p><p>存储在Cache的条目有一个定义的有效期，一旦超过这个时间，就会设置过期的状态，过期无法被访问，更新，删除。缓存的有效期可以通过ExpiryPolicy设置。</p></li></ul><h2 id="spring的缓存抽象"><a href="#spring的缓存抽象" class="headerlink" title="spring的缓存抽象"></a>spring的缓存抽象</h2><p>包括一些JSR107的注解</p><p>CahceManager</p><p>Cache</p><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><p><strong>重要的概念&amp;缓存注解</strong></p><table><thead><tr><th></th><th align="left">功能</th></tr></thead><tbody><tr><td>Cache</td><td align="left">缓存接口，定义缓存操作，实现有：RedisCache、EhCacheCache、ConcurrentMapCache等</td></tr><tr><td>CacheManager</td><td align="left">缓存管理器，管理各种缓存（Cache）组件</td></tr><tr><td>@Cacheable</td><td align="left">针对方法配置，根据方法的请求参数对其结果进行缓存</td></tr><tr><td>@CacheEvict</td><td align="left">清空缓存</td></tr><tr><td>@CachePut</td><td align="left">保证方法被调用，又希望结果被缓存 update，调用，将信息更新缓存</td></tr><tr><td>@EnableCaching</td><td align="left">开启基于注解的缓存</td></tr><tr><td>KeyGenerator</td><td align="left">缓存数据时key生成的策略</td></tr><tr><td>serialize</td><td align="left">缓存数据时value序列化策略</td></tr></tbody></table><h2 id="整合项目"><a href="#整合项目" class="headerlink" title="整合项目"></a>整合项目</h2><p>springboot 2.2.3+web+mysql+mybatis+cache</p><h3 id="导入相关配置"><a href="#导入相关配置" class="headerlink" title="导入相关配置"></a>导入相关配置</h3><pre><code>    &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;                &lt;scope&gt;test&lt;/scope&gt;                &lt;exclusions&gt;                    &lt;exclusion&gt;                        &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                        &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                    &lt;/exclusion&gt;                &lt;/exclusions&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;2.1.1&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                &lt;scope&gt;runtime&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;                &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;1.1.20&lt;/version&gt;            &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>application.yml</p><pre><code>spring:        datasource:          username: root          password: 980508          url: jdbc:mysql://localhost:3306/spring-cache?serverTimezone=UTC          driver-class-name: com.mysql.cj.jdbc.Driver          initialization-mode: always#开启驼峰命名法mybatis:  configuration:    map-underscore-to-camel-case: true</code></pre><p>application.properties</p><pre><code># 开启日志，打印sql语句logging.level.com.atguigu.mapper = debug# 打印配置报告debug=true</code></pre><h3 id="创建bean实例"><a href="#创建bean实例" class="headerlink" title="创建bean实例"></a>创建bean实例</h3><p>Department</p><pre><code>package com.atguigu.bean;public class Department {    private Integer id;    private String departmentName;    public Department() {        super();        // TODO Auto-generated constructor stub    }    public Department(Integer id, String departmentName) {        super();        this.id = id;        this.departmentName = departmentName;    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getDepartmentName() {        return departmentName;    }    public void setDepartmentName(String departmentName) {        this.departmentName = departmentName;    }    @Override    public String toString() {        return &quot;Department [id=&quot; + id + &quot;, departmentName=&quot; + departmentName + &quot;]&quot;;    }}</code></pre><p>Employee</p><pre><code>package com.atguigu.bean;public class Employee {    private Integer id;    private String lastName;    private String email;    private Integer gender; //性别 1男  0女    private Integer dId;    public Employee() {        super();    }    public Employee(Integer id, String lastName, String email, Integer gender, Integer dId) {        super();        this.id = id;        this.lastName = lastName;        this.email = email;        this.gender = gender;        this.dId = dId;    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getLastName() {        return lastName;    }    public void setLastName(String lastName) {        this.lastName = lastName;    }    public String getEmail() {        return email;    }    public void setEmail(String email) {        this.email = email;    }    public Integer getGender() {        return gender;    }    public void setGender(Integer gender) {        this.gender = gender;    }    public Integer getdId() {        return dId;    }    public void setdId(Integer dId) {        this.dId = dId;    }    @Override    public String toString() {        return &quot;Employee [id=&quot; + id + &quot;, lastName=&quot; + lastName + &quot;, email=&quot; + email + &quot;, gender=&quot; + gender + &quot;, dId=&quot;                + dId + &quot;]&quot;;    }}</code></pre><h3 id="创建mapper接口映射数据库"><a href="#创建mapper接口映射数据库" class="headerlink" title="创建mapper接口映射数据库"></a>创建mapper接口映射数据库</h3><p>DepartmentMapper</p><pre><code>package com.atguigu.mapper;import com.atguigu.bean.Department;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;public interface DepartmentMapper {    @Select(&quot;select * from department where id = #{id}&quot;)    public Department getDepById(Integer id);    @Update(&quot;update department set departmentName=#{departmentName} where id=#{id}&quot;)    public void updateDep(Department department);    @Delete(&quot;delete from department where id=#{id}&quot;)    public void deleteDepById(Integer id);    @Insert(&quot;insert into department (departmentName)values(#{departmentName})&quot;)    public void insertDep(Department department);}</code></pre><p>EmployeeMapper</p><pre><code>package com.atguigu.mapper;import com.atguigu.bean.Employee;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;public interface EmployeeMapper {    @Select(&quot;select * from Employee where id = #{id}&quot;)    public Employee getEmpById(Integer id);    @Update(&quot; update Employee set lastName=#{lastName},email=#{email},gender=#{gender},d_id=#{dId} where id=#{id}&quot;)    public void updateEmp(Employee employee);    @Delete(&quot;delete form Employee where id=#{id}&quot;)    public void deleteEmpById(Integer id);    @Insert(&quot;insert into Employee(lastName,email,gender,d_id)values(#{lastName},#{email},#{gender},#{dId})&quot;)    public void insertEmp(Employee employee);    @Select(&quot;select * from Employee where lastName = #{lastName}&quot;)    public Employee getEmpByLastName(String lastName);}</code></pre><h3 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h3><p>主程序添加注解MapperScan，并且使用@EnableCaching开启缓存</p><pre><code>@EnableCaching@MapperScan(&quot;com.atguigu.mapper&quot;)@SpringBootApplicationpublic class SpringBoot01CacheApplication {    public static void main(String[] args) {        SpringApplication.run(SpringBoot01CacheApplication.class, args);    }}</code></pre><h3 id="编写service来具体实现mapper中的方法"><a href="#编写service来具体实现mapper中的方法" class="headerlink" title="编写service来具体实现mapper中的方法"></a>编写service来具体实现mapper中的方法</h3><p>将方法的运行结果进行缓存，以后要是再有相同的数据，直接从缓存中获取，不用调用方法</p><p> CacheManager中管理多个Cache组件，对缓存的真正CRUD操作在Cache组件中，每个缓存组件都有自己的唯一名字；</p><p> 属性：</p><ul><li>CacheName/value:指定存储缓存组件的名字</li><li>key:缓存数据使用的key,可以使用它来指定。默认是使用方法参数的值，1-方法的返回值</li><li>编写Spel表达式：#id 参数id的值， #a0/#p0 #root.args[0]</li><li>keyGenerator:key的生成器，自己可以指定key的生成器的组件id</li><li>key/keyGendertor二选一使用</li><li>cacheManager指定Cache管理器，或者cacheReslover指定获取解析器</li><li>condition:指定符合条件的情况下，才缓存； ex:condition = “#id&gt;0”</li><li>unless：否定缓存，unless指定的条件为true，方法的返回值就不会被缓存，可以获取到结果进行判断  ;  ex:unless = “#result == null”</li><li>sync:是否使用异步模式，unless不支持</li></ul><h4 id="各种注解的使用"><a href="#各种注解的使用" class="headerlink" title="各种注解的使用"></a>各种注解的使用</h4><pre><code>@Servicepublic class EmployeeService {    @Autowired    EmployeeMapper employeeMapper;    /**     * cacheName：  指定缓存组件的名字，也可以用value来表示     * key: #id表示id的值作为key   还有另一种keyGenerator:key的生成器，自己可以指定key的生成器的组件id,自己了解，这里就不演示了     * condition： 符合条件下，才缓存，这里表示id&gt;1才缓存     * unless:  符合条件下，不缓存，这里表示id==0则不缓存     * @param id     * @return     */    @Cacheable(cacheNames = &quot;emp&quot;,key = &quot;#id&quot;,condition = &quot;#id&gt;1&quot;,unless = &quot;#id==0&quot;)    public Employee getEmp(Integer id){        System.out.println(&quot;查询&quot;+id+&quot;号员工&quot;);        Employee employee=employeeMapper.getEmpById(id);        return employee;    }     /**     *@CachePut：既调用方法，又更新缓存     * 修改了数据库的某个数据，同时又更新了缓存     * 运行时机：（与Cacheable相反）     *      1.先调用目标方法     *      2.将目标方法缓存起来     *     * 测试步骤     * 1.查询1号员工，查询到的结果会放到缓存中     *          key：1   value：lastName：zhangsan     * 2.以后查询的结果还是之前的结果     * 3.更新1号员工     * 4.查询1号员工，应该是更新后的员工，key应该这样写     *      key=&quot;#employee.id&quot;   使用传入参数的员工id     *      key=&quot;#result.id&quot;     使用返回后的员工id     *      注：@Cacheable中不能写#result.id     * @param employee     * @return     */    @CachePut(cacheNames = &quot;emp&quot;,key = &quot;#result.id&quot;)    public Employee updateEmp(Employee employee){        System.out.println(&quot;更新&quot;+employee.getId()+&quot;号员工&quot;);        employeeMapper.updateEmp(employee);        return employee;    }     /**     * @CacheEvict：清除缓存（常用于删除之类的）     * key：指定清除的数据     * allEntries=true：指定清除这个缓存中的所有数据，默认是false     * beforeInvocation = false : 缓存的清除是否在方法之前清除，默认是false     *      默认是在方法之后清除（如果出现异常错误则不清除）     * beforeInvocation = true ：缓存的清除在方法之前清除，不管是否出现异常都会清除     * @param id     */    @CacheEvict(cacheNames = &quot;emp&quot;,key = &quot;#id&quot;,beforeInvocation = true)    public void deleteEmp(Integer id){        System.out.println(&quot;清除&quot;+id+&quot;号员工缓存&quot;);        //employeeMapper.deleteEmpById(id);     //同时删除数据库中的数据        int i=10/0;    }    //@Caching 定义复杂的缓存规则    /**     * 这里通过查询lastName来测试     * 当查询lastName完之后，再通过id和email来查就不需要通过数据库了     * 但是通过lastName来查询还是需要通过数据库，因为CachePut注解的作用是先调用目标方法，方法必被执行     *     * 公共的配置可以通过@CacheConfig写在一起，标注在类前，比如配置cacheName     * @param lastName     * @return     */    @Caching(            cacheable = {                    @Cacheable(key = &quot;#lastName&quot;)            },            put = {                    @CachePut(key = &quot;#result.id&quot;),                    @CachePut(key = &quot;#result.email&quot;)            }    )    public Employee getEmpByLastName(String lastName){        System.out.println(&quot;查询&quot;+lastName);        Employee emp = employeeMapper.getEmpByLastName(lastName);        return emp;    }}</code></pre><h3 id="编写controller测试"><a href="#编写controller测试" class="headerlink" title="编写controller测试"></a>编写controller测试</h3><pre><code>@RestControllerpublic class EmployeeController {    @Autowired    EmployeeService employeeService;    @GetMapping(&quot;/emp/{id}&quot;)    public Employee getEmployee(@PathVariable(&quot;id&quot;) Integer id){        Employee emp = employeeService.getEmp(id);        return emp;    }    @GetMapping(&quot;/emp&quot;)    public Employee updateEmployee(Employee employee){        Employee emp = employeeService.updateEmp(employee);        return emp;    }    @GetMapping(&quot;/delemp/{id}&quot;)    public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id){        employeeService.deleteEmp(id);        return &quot;清除&quot;+id+&quot;号员工缓存成功&quot;;    }    @GetMapping(&quot;/emp/lastname/{lastName}&quot;)    public Employee getEmpByLastName(@PathVariable(&quot;lastName&quot;) String lastName){        Employee emp= employeeService.getEmpByLastName(lastName);        return emp;    }}</code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>第一次访问会查询数据库，继续访问缓存中取值</p><h2 id="整合redis"><a href="#整合redis" class="headerlink" title="整合redis"></a>整合redis</h2><ul><li>在上面的基础上加一部分东西</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>下载windows版本的压缩包 <a href="https://github.com/microsoftarchive/redis/releases" target="_blank" rel="noopener">链接</a></li><li>下载RedisDesktopManager（一个桌面化的redis工具）</li></ul><h3 id="导入相关依赖"><a href="#导入相关依赖" class="headerlink" title="导入相关依赖"></a>导入相关依赖</h3><pre><code>    &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>application.yml</p><pre><code>    # REDIS (RedisProperties)    # Redis数据库索引（默认为0）    spring.redis.database=0    # Redis服务器地址    spring.redis.host=localhost    # Redis服务器连接端口    spring.redis.port=6379    # Redis服务器连接密码（默认为空）    #spring.redis.password=980508    # 连接池最大连接数（使用负值表示没有限制）    spring.redis.jedis.pool.max-active=8    # 连接池最大阻塞等待时间（使用负值表示没有限制）    spring.redis.jedis.pool.max-wait=-1    # 连接池中的最大空闲连接    spring.redis.jedis.pool.max-idle=8    # 连接池中的最小空闲连接    spring.redis.jedis.pool.min-idle=0</code></pre><h3 id="测试redis"><a href="#测试redis" class="headerlink" title="测试redis"></a>测试redis</h3><ul><li><p>redis中常见的五大数据类型</p><ul><li>String（字符串），List（列表），Set（集合），Hash（散列），ZSet   有序集合）</li></ul></li><li><p>redis两个template</p><ul><li><p>StringRedisTemplate stringRedisTemplate;    //操作k-v都是字符串的</p></li><li><p>RedisTemplate redisTemplate;    //操作k-v都是对象的</p></li></ul></li><li><p>具体用法（redisTemplate是一样的）</p><ul><li>stringRedisTemplate.opsForValue()    [String（字符串）]</li><li>stringRedisTemplate.opsForList()    [List（列表）]</li><li>stringRedisTemplate.opsForSet()    [Set（集合）]</li><li>stringRedisTemplate.opsForHash()    [Hash（散列）]</li><li>stringRedisTemplate.opsForZSet()    [ZSet（有序集合）]</li></ul></li></ul><h4 id="test01"><a href="#test01" class="headerlink" title="test01"></a>test01</h4><pre><code>    //测试给redis中保存数据，操作k-v都是字符串的    @Autowired    StringRedisTemplate stringRedisTemplate;    //操作k-v都是字符串的    @Test    public void test01(){        //stringRedisTemplate.opsForValue().append(&quot;msg&quot;,&quot;lihua&quot;);        //字符串        //String msg=stringRedisTemplate.opsForValue().get(&quot;msg&quot;);        //System.out.println(msg);        stringRedisTemplate.opsForList().leftPush(&quot;mylist&quot;,&quot;1&quot;);        //列表        stringRedisTemplate.opsForList().leftPush(&quot;mylist&quot;,&quot;2&quot;);    }</code></pre><h4 id="test02"><a href="#test02" class="headerlink" title="test02"></a>test02</h4><pre><code>    //测试保存对象    @Autowired    RedisTemplate redisTemplate;    //操作k-v都是对象的    @Autowired    EmployeeMapper employeeMapper;    @Test    public void test02(){        Employee EmpById=employeeMapper.getEmpById(1);        //默认如果保存对象，使用jdk序列化机制，序列化的数据保存到redis中        redisTemplate.opsForValue().set(&quot;emp-01&quot;,EmpById);        redisTemplate.opsForValue().set(&quot;dept-01&quot;,departmentMapper.getDepById(1));    }</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul><li><p>保存对象存进redis中的数据不是json数据，我们需要把它转换成json数据，这样我们就需要使用序列话机制，改变redisTemplate默认的序列化规则</p></li><li><p>默认保存对象，是使用jdk序列化规则，我们需要改成json序列化规则</p></li></ul><p>Employee</p><pre><code>    //实现一个接口    public class Employee implements Serializable{</code></pre><ul><li>创建一个配置类</li></ul><p>config.MyRedisConfig</p><pre><code>    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        // 配置连接工厂        template.setConnectionFactory(factory);        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）        Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jacksonSeial.setObjectMapper(om);        // 值采用json序列化        template.setValueSerializer(jacksonSeial);        //使用StringRedisSerializer来序列化和反序列化redis的key值        template.setKeySerializer(new StringRedisSerializer());        // 设置hash key 和value序列化模式        template.setHashKeySerializer(new StringRedisSerializer());        template.setHashValueSerializer(jacksonSeial);        template.afterPropertiesSet();        return template;    }</code></pre><h3 id="自定义Cachemanager"><a href="#自定义Cachemanager" class="headerlink" title="自定义Cachemanager"></a>自定义Cachemanager</h3><ul><li>缓存管理器,转换为json数据</li><li>当我们运行存入缓存中的数据不是json数据，这时我们需要自定义CacheManager，把它转换为json数据</li></ul><p>config.MyRedisConfig</p><pre><code>    /**     * 缓存管理器,转换为json数据     */    @Bean    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {        //初始化一个RedisCacheWriter        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory);        //设置CacheManager的值序列化方式为json序列化        RedisSerializer&lt;Object&gt; jsonSerializer = new GenericJackson2JsonRedisSerializer();        RedisSerializationContext.SerializationPair&lt;Object&gt; pair = RedisSerializationContext.SerializationPair                .fromSerializer(jsonSerializer);        RedisCacheConfiguration defaultCacheConfig=RedisCacheConfiguration.defaultCacheConfig()                .serializeValuesWith(pair);        //设置默认超过期时间是30秒        defaultCacheConfig.entryTtl(Duration.ofSeconds(30));        //初始化RedisCacheManager        return new RedisCacheManager(redisCacheWriter, defaultCacheConfig);    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot高级缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot jdbc</title>
      <link href="/2020/01/13/springboot-lian-jie-jdbc/"/>
      <url>/2020/01/13/springboot-lian-jie-jdbc/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot连接jdbc数据库并且整合Druid数据源"><a href="#springboot连接jdbc数据库并且整合Druid数据源" class="headerlink" title="springboot连接jdbc数据库并且整合Druid数据源"></a>springboot连接jdbc数据库并且整合Druid数据源</h1><h1 id="连接jdbc数据库"><a href="#连接jdbc数据库" class="headerlink" title="连接jdbc数据库"></a>连接jdbc数据库</h1><h2 id="导入相关依赖"><a href="#导入相关依赖" class="headerlink" title="导入相关依赖"></a>导入相关依赖</h2><pre><code>&lt;!--导入jdbc相关依赖--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.1.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><h2 id="配置数据库连接信息"><a href="#配置数据库连接信息" class="headerlink" title="配置数据库连接信息"></a>配置数据库连接信息</h2><ul><li>application.yml</li></ul><pre><code>    spring:      datasource:        username: root        password: 数据库密码        url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC        driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><h2 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h2><ul><li>在测试类中测试</li></ul><pre><code>    @SpringBootTest    class SpringBootData06JdbcApplicationTests {      @Autowired      DataSource dataSource;      //测试连接数据库      @Test      void contextLoads() throws SQLException {        System.out.println(dataSource.getClass());        Connection connection = dataSource.getConnection();        System.out.println(connection);      }    }</code></pre><ul><li>springboot默认是使用com.zaxxer.hikari.HikariDataSource作为数据源，</li></ul><p>2.0以下是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p><pre><code>    如果出现com.zaxxer.hikari.HikariDataSource则表示连接成功</code></pre><h2 id="数据库查询数据返回网页"><a href="#数据库查询数据返回网页" class="headerlink" title="数据库查询数据返回网页"></a>数据库查询数据返回网页</h2><pre><code>    @RestController    public class JdbcController {        //查询数据库的数据返回网页        @Autowired        JdbcTemplate jdbcTemplate;        @GetMapping(&quot;/query&quot;)        public Map&lt;String,Object&gt; map(){            List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;SELECT * from department&quot;);            return list.get(0);        }    }</code></pre><p><a href="http://localhost:8080/query" target="_blank" rel="noopener">查询</a>  </p><h1 id="整合Druid数据源"><a href="#整合Druid数据源" class="headerlink" title="整合Druid数据源"></a>整合Druid数据源</h1><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><ul><li>在springboot项目中导入druid数据源依赖<a href="https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter" target="_blank" rel="noopener">点击查询最新依赖</a></li></ul><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.20&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><ul><li>application.yml</li></ul><pre><code>    #jdbc的配置    spring:      datasource:        password: 980508        username: root        url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8        driver-class-name: com.mysql.cj.jdbc.Driver        initialization-mode: always        #整合Druid数据源        type: com.alibaba.druid.pool.DruidDataSource        druid:          # 连接池配置          # 配置初始化大小、最小、最大          initial-size: 1          min-idle: 1          max-active: 20          # 配置获取连接等待超时的时间          max-wait: 3000          validation-query: SELECT 1 FROM DUAL          test-on-borrow: false          test-on-return: false          test-while-idle: true          pool-prepared-statements: true          time-between-eviction-runs-millis: 60000          min-evictable-idle-time-millis: 300000          filters: stat,wall,slf4j          # 配置web监控,默认配置也和下面相同(除用户名密码，enabled默认false外)，其他可以不配          web-stat-filter:            enabled: true            url-pattern: /*            exclusions: &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;          stat-view-servlet:            enabled: true            url-pattern: /druid/*            login-username: lihuazhou            login-password: 980508            allow: 192.168.182.1</code></pre><h2 id="测试类查看使用的数据源"><a href="#测试类查看使用的数据源" class="headerlink" title="测试类查看使用的数据源"></a>测试类查看使用的数据源</h2><pre><code>    @SpringBootTest    class SpringbootJdbcApplicationTests {        @Autowired        private DataSource dataSource;        @Test        void contextLoads() throws SQLException {            System.out.println(dataSource.getClass());            System.out.println(dataSource.getConnection());        }    }</code></pre><h2 id="编写一个Druid配置类"><a href="#编写一个Druid配置类" class="headerlink" title="编写一个Druid配置类"></a>编写一个Druid配置类</h2><ul><li><p>DruidConfig</p></li><li><p>需要把配置信息从application.yml中加入到容器中</p></li></ul><pre><code>    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)            @Bean            public DataSource druid(){                return  new DruidDataSource();            }</code></pre><ul><li>配置一个Servelet容器来管理后台（Druid的监控）</li></ul><pre><code>    @Bean    public ServletRegistrationBean statViewServlet(){        ServletRegistrationBean bean=new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;); //druid后台的路径        Map&lt;String,String&gt; initParams =new HashMap&lt;&gt;();        initParams.put(&quot;loginUsername&quot;,&quot;lihuazhou&quot;);        initParams.put(&quot;loginPassword&quot;,&quot;980508&quot;);        initParams.put(&quot;allow&quot;,&quot;&quot;);//可以设置为localhost下才能访问，默认是所有都可以访问        initParams.put(&quot;deny&quot;,&quot;&quot;);//默认是不禁用路径        bean.setInitParameters(initParams);        return bean;    }</code></pre><ul><li>配置一个web监控的Filter（拦截一些操作，有点类似拦截器）</li></ul><pre><code>    @Bean    public FilterRegistrationBean webStatFilter(){        FilterRegistrationBean bean = new FilterRegistrationBean();        bean.setFilter(new WebStatFilter());        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);     //除了这些操作的数据，其他都会被拦截        bean.setInitParameters(initParams);        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));      return  bean;      }</code></pre><ul><li>Druid页面<h1 id="springboot连接jdbc数据库并且整合Druid数据源-1"><a href="#springboot连接jdbc数据库并且整合Druid数据源-1" class="headerlink" title="springboot连接jdbc数据库并且整合Druid数据源"></a>springboot连接jdbc数据库并且整合Druid数据源</h1></li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>1.<a href="#连接jdbc数据库">连接jdbc数据库</a><ul><li>1.<a href="#导入相关依赖">导入相关依赖</a></li><li>2.<a href="#配置数据库连接信息">配置数据库连接信息</a></li><li>3.<a href="#测试连接">测试连接</a></li><li>4.<a href="#数据库查询数据返回网页">数据库查询数据返回网页</a></li></ul></li><li>1.<a href="#整合Druid数据源">整合Druid数据源</a><ul><li>1.<a href="#导入依赖">导入依赖</a></li><li>2.<a href="#配置信息">配置信息</a></li><li>3.<a href="#测试类查看使用的数据源">测试类查看使用的数据源</a></li><li>4.<a href="#编写一个Druid配置类">编写一个Druid配置类</a></li></ul></li></ul><h1 id="连接jdbc数据库-1"><a href="#连接jdbc数据库-1" class="headerlink" title="连接jdbc数据库"></a>连接jdbc数据库</h1><h2 id="导入相关依赖-1"><a href="#导入相关依赖-1" class="headerlink" title="导入相关依赖"></a>导入相关依赖</h2><pre><code>&lt;!--导入jdbc相关依赖--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.1.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><h2 id="配置数据库连接信息-1"><a href="#配置数据库连接信息-1" class="headerlink" title="配置数据库连接信息"></a>配置数据库连接信息</h2><ul><li>application.yml</li></ul><pre><code>    spring:      datasource:        username: root        password: 数据库密码        url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC        driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><h2 id="测试连接-1"><a href="#测试连接-1" class="headerlink" title="测试连接"></a>测试连接</h2><ul><li>在测试类中测试</li></ul><pre><code>    @SpringBootTest    class SpringBootData06JdbcApplicationTests {      @Autowired      DataSource dataSource;      //测试连接数据库      @Test      void contextLoads() throws SQLException {        System.out.println(dataSource.getClass());        Connection connection = dataSource.getConnection();        System.out.println(connection);      }    }</code></pre><ul><li>springboot默认是使用com.zaxxer.hikari.HikariDataSource作为数据源，</li></ul><p>2.0以下是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p><pre><code>    如果出现com.zaxxer.hikari.HikariDataSource则表示连接成功</code></pre><h2 id="数据库查询数据返回网页-1"><a href="#数据库查询数据返回网页-1" class="headerlink" title="数据库查询数据返回网页"></a>数据库查询数据返回网页</h2><pre><code>    @RestController    public class JdbcController {        //查询数据库的数据返回网页        @Autowired        JdbcTemplate jdbcTemplate;        @GetMapping(&quot;/query&quot;)        public Map&lt;String,Object&gt; map(){            List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;SELECT * from department&quot;);            return list.get(0);        }    }</code></pre><p><a href="http://localhost:8080/query" target="_blank" rel="noopener">查询</a>  </p><h1 id="整合Druid数据源-1"><a href="#整合Druid数据源-1" class="headerlink" title="整合Druid数据源"></a>整合Druid数据源</h1><h2 id="导入依赖-1"><a href="#导入依赖-1" class="headerlink" title="导入依赖"></a>导入依赖</h2><ul><li>在springboot项目中导入druid数据源依赖<a href="https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter" target="_blank" rel="noopener">点击查询最新依赖</a></li></ul><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.20&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h2 id="配置信息-1"><a href="#配置信息-1" class="headerlink" title="配置信息"></a>配置信息</h2><ul><li>application.yml</li></ul><pre><code>    #jdbc的配置    spring:      datasource:        password: 980508        username: root        url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8        driver-class-name: com.mysql.cj.jdbc.Driver        initialization-mode: always        #整合Druid数据源        type: com.alibaba.druid.pool.DruidDataSource        druid:          # 连接池配置          # 配置初始化大小、最小、最大          initial-size: 1          min-idle: 1          max-active: 20          # 配置获取连接等待超时的时间          max-wait: 3000          validation-query: SELECT 1 FROM DUAL          test-on-borrow: false          test-on-return: false          test-while-idle: true          pool-prepared-statements: true          time-between-eviction-runs-millis: 60000          min-evictable-idle-time-millis: 300000          filters: stat,wall,slf4j          # 配置web监控,默认配置也和下面相同(除用户名密码，enabled默认false外)，其他可以不配          web-stat-filter:            enabled: true            url-pattern: /*            exclusions: &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;          stat-view-servlet:            enabled: true            url-pattern: /druid/*            login-username: lihuazhou            login-password: 980508            allow: 192.168.182.1</code></pre><h2 id="测试类查看使用的数据源-1"><a href="#测试类查看使用的数据源-1" class="headerlink" title="测试类查看使用的数据源"></a>测试类查看使用的数据源</h2><pre><code>    @SpringBootTest    class SpringbootJdbcApplicationTests {        @Autowired        private DataSource dataSource;        @Test        void contextLoads() throws SQLException {            System.out.println(dataSource.getClass());            System.out.println(dataSource.getConnection());        }    }</code></pre><h2 id="编写一个Druid配置类-1"><a href="#编写一个Druid配置类-1" class="headerlink" title="编写一个Druid配置类"></a>编写一个Druid配置类</h2><ul><li><p>DruidConfig</p></li><li><p>需要把配置信息从application.yml中加入到容器中</p></li></ul><pre><code>    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)            @Bean            public DataSource druid(){                return  new DruidDataSource();            }</code></pre><ul><li>配置一个Servelet容器来管理后台（Druid的监控）</li></ul><pre><code>    @Bean    public ServletRegistrationBean statViewServlet(){        ServletRegistrationBean bean=new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;); //druid后台的路径        Map&lt;String,String&gt; initParams =new HashMap&lt;&gt;();        initParams.put(&quot;loginUsername&quot;,&quot;lihuazhou&quot;);        initParams.put(&quot;loginPassword&quot;,&quot;980508&quot;);        initParams.put(&quot;allow&quot;,&quot;&quot;);//可以设置为localhost下才能访问，默认是所有都可以访问        initParams.put(&quot;deny&quot;,&quot;&quot;);//默认是不禁用路径        bean.setInitParameters(initParams);        return bean;    }</code></pre><ul><li>配置一个web监控的Filter（拦截一些操作，有点类似拦截器）</li></ul><pre><code>    @Bean    public FilterRegistrationBean webStatFilter(){        FilterRegistrationBean bean = new FilterRegistrationBean();        bean.setFilter(new WebStatFilter());        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);     //除了这些操作的数据，其他都会被拦截        bean.setInitParameters(initParams);        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));      return  bean;      }</code></pre><ul><li>Druid页面</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/25.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot jdbc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
