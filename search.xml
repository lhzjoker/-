<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GC垃圾回收机制</title>
      <link href="/2020/07/13/mian-shi-gc-la-ji-hui-shou-ji-zhi/"/>
      <url>/2020/07/13/mian-shi-gc-la-ji-hui-shou-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本篇主要记录java垃圾回收机制的一些主要面试问题</li></ul><h2 id="java垃圾回收机制"><a href="#java垃圾回收机制" class="headerlink" title="java垃圾回收机制"></a>java垃圾回收机制</h2><ul><li>java回收机制主要是回收java堆中的对象</li></ul><h3 id="对象被判定为垃圾的标准"><a href="#对象被判定为垃圾的标准" class="headerlink" title="对象被判定为垃圾的标准"></a>对象被判定为垃圾的标准</h3><ul><li>没有被其他对象引用</li></ul><h3 id="判断对象是否为垃圾的算法"><a href="#判断对象是否为垃圾的算法" class="headerlink" title="判断对象是否为垃圾的算法"></a>判断对象是否为垃圾的算法</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>判断对象的引用数量</p><ul><li>通过判断对象的引用数量来决定对象是否可以回收</li><li>每个对象都有一个引用计数器，如果被引用就+1，完成引用就-1</li><li>任何引用计数为0的对象实例都可以被当作垃圾收集</li><li>优点：执行效率高，程序执行受影响小</li><li>缺点：无法检测出循环引用的情况，导致内存泄漏（如父对象对子对象有一个引用，子对象又反过来引用父对象，这样引用数量永远不可能为0）</li></ul><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>通过判断对象的引用链是否可达来决定对象是否可以回收</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/62.png" alt=""></p><h4 id="可作为GC-Root的对象"><a href="#可作为GC-Root的对象" class="headerlink" title="可作为GC Root的对象"></a>可作为GC Root的对象</h4><ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）</li><li>方法区中的常量引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>本地方法栈中JNI（Native方法）的引用对象</li><li>活跃线程的引用对象</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><ul><li>标记：从根集合进行扫描，把存活的对象进行标记（可达性算法）</li><li>清除：从堆内存从头到尾进行线性遍历，回收不可达对象</li><li>缺点：一是效率问题，两个过程的效率都不高。二是空间问题，清除之后会产生大量不连续的内存，容易造成内存碎片化</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/63.png" alt=""></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法是将原有的内存空间分成两块，每次只使用其中的一块。在GC时，将正在使用的内存块中的存活对象复制到未使用的那一块中，然后清除正在使用的内存块中的所有对象，并交换两块内存的角色，完成一次垃圾回收。它比标记-清除算法要高效，但不适用于存活对象较多的内存，因为复制的时候会有较多的时间消耗。它的致命缺点是会有一半的内存浪费。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/64.png" alt=""></p><p>优点：</p><ul><li>解决碎片化</li><li>顺序分配内存，简单高效</li><li>适用于对象存活率低的场景</li></ul><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记整理算法适用于存活对象较多的场合，它的标记阶段和标记-清除算法中的一样。整理阶段是将所有存活的对象压缩到内存的一端，之后清理边界外所有的空间。它的效率也不高。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/65.png" alt=""></p><ul><li>标记：从根集合进行扫描，对存活的对象进行标记</li><li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收</li><li>避免内存的不连续</li><li>不用设置两块内存互换</li><li>适用于存活率高的场景</li></ul><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><ul><li>垃圾回收算法的组合拳</li><li>按照对象生命周期的不同划分区域采用不同的垃圾回收算法</li><li>目的：提高JVM的回收效率</li></ul><h4 id="GC的分类"><a href="#GC的分类" class="headerlink" title="GC的分类"></a>GC的分类</h4><p>GC：垃圾收集器</p><p>Minor GC：新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂。因为存活率较低，所以常用复制算法</p><p>Major GC/Full GC：老年代GC，指发生在老年代的GC，因为存活率高，所以常用标记整理算法</p><h4 id="新生代和老年代"><a href="#新生代和老年代" class="headerlink" title="新生代和老年代"></a>新生代和老年代</h4><ul><li>jdk8以前java堆分为新生代，老年代和永久代。jdk8以后java堆就只分为年轻代和老年代</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/66.png" alt=""></p><h5 id="为什么要划分成年轻代和老年代？"><a href="#为什么要划分成年轻代和老年代？" class="headerlink" title="为什么要划分成年轻代和老年代？"></a>为什么要划分成年轻代和老年代？</h5><p>因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。</p><h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><p>主要是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收,尽可能快速收集掉那些生命周期短的对象</p><p>新生代又分为 Eden区、SurvivorFrom、SurvivorTo三个区。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/67.png" alt=""></p><ul><li>Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。</li><li>ServivorTo：保留了一次MinorGC过程中的幸存者。</li><li>ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。</li></ul><p>当JVM无法为新建对象分配内存空间的时候(Eden满了)，Minor GC被触发。因此新生代空间占用率越高，Minor GC越频繁。</p><p>MinorGC的过程：采用复制算法。</p><ul><li>首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，一般是15，则赋值到老年代区）</li><li>同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）</li><li>然后，清空Eden和ServicorFrom中的对象；最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。</li></ul><h5 id="年轻代为什么被划分成eden、survivor区域？"><a href="#年轻代为什么被划分成eden、survivor区域？" class="headerlink" title="年轻代为什么被划分成eden、survivor区域？"></a>年轻代为什么被划分成eden、survivor区域？</h5><p>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC（因为Major GC一般伴随着Minor GC，也可以看做触发了Full GC）。老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。</p><p>没有survivor的解决办法：</p><ul><li>增加老年代内存，那么老年代清理频次减少，但清理一次花费时间更长。</li><li>减少老年代内存，老年代一次FullGC时间更少，频率增加。</li></ul><p>都不行，只有再加一层Survivor。将Eden区满了的对象，添加到Survivor区，等对象反复清理几遍之后都没清理掉，再放到老年区，这样老年区的压力就会小很多。即Survivor相当于一个筛子，筛掉生命周期短的，将生命周期长的放到老年代区，减少老年代被清理的次数。</p><h5 id="对象如何晋升到老年代"><a href="#对象如何晋升到老年代" class="headerlink" title="对象如何晋升到老年代"></a>对象如何晋升到老年代</h5><ul><li>经历一定次数的Minor GC依然存活的对象</li><li>Suivivor区中存放不下的对象</li><li>新生成的大对象(设置大对象的标准：-XX:+PretenuerSizeThreshold)</li></ul><h5 id="常见的调优参数"><a href="#常见的调优参数" class="headerlink" title="常见的调优参数"></a>常见的调优参数</h5><ul><li>-XX:SurvivorRatio：Eden和Survivor的比值，默认是8：1</li><li>-XX:NewRatio：老年代和新生代内存大小的比例</li><li>-XX:MaxTenuringThreshold：对象从新生代晋升到老年代经过Gc次数的最大阈值</li></ul><h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><ul><li>存放生命周期较长的对象</li></ul><p>MajorGC比MinorGC慢10倍以上，但是它不会频繁执行</p><p>老年代的对象比较稳定，所以MajorGC不会频繁执行。</p><p>在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。</p><p>MajorGC采用标记—清除算法或者标记-整理算法</p><h5 id="Full-GC和Major-GC"><a href="#Full-GC和Major-GC" class="headerlink" title="Full GC和Major GC"></a>Full GC和Major GC</h5><ul><li>都是发生在老年代的GC，通常情况下这两个GC是一样的概念，但是经过这么多年的发展，名词的解释可能存在有些许不同，所以你要问清楚FullGC是不是指的就是MajorGC</li><li>FullGC可能是清理整个堆中的年轻代和老年代，而MajorGC是清理老年代</li></ul><h4 id="触发MinorGC和FullGC的条件"><a href="#触发MinorGC和FullGC的条件" class="headerlink" title="触发MinorGC和FullGC的条件"></a>触发MinorGC和FullGC的条件</h4><ul><li>触发MinorGC的条件：当Eden区满的时候，触发Minor</li><li>触发FullGC的条件：<ul><li>老年代空间不足</li><li>永久代空间不足</li><li>CMSGC出现promotion failed，concurrent mode failure</li><li>MinorGC晋升到老年代的平均大小大于老年代剩余空间</li><li>调用System.gc()，系统建议执行Full GC，但是不必然执行</li><li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li><li>使用RMI来进行RPC或管理的JDK应用，每小时执行一次FullGC</li></ul></li></ul><h3 id="stop-the-world"><a href="#stop-the-world" class="headerlink" title="stop-the-world"></a>stop-the-world</h3><ul><li>jvm由于要执行GC而停止了应用程序的执行</li><li>任何一种GC算法中都会发生</li><li>多数GC优化通过减少stop-the-world发生的时间来提高程序性能</li></ul><h3 id="safepoint"><a href="#safepoint" class="headerlink" title="safepoint"></a>safepoint</h3><ul><li>分析过程中对象引用关系不会发生变化的点（即在垃圾进行回收的时候不会产生垃圾）</li><li>产生safepoint的地方：方法调用，循环跳转，异常跳转等</li><li>安全点数量要适中</li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集器是垃圾回收算法（标记-清除算法、复制算法、标记-整理算法）的具体实现，不同商家、不同版本的JVM所提供的垃圾收集器可能会有很在差别.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/68.png" alt=""></p><ul><li>图中展示了7种不同分代的收集器：</li></ul><p>Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；</p><ul><li>而它们所处区域，则表明其是属于新生代收集器还是老年代收集器：</li></ul><p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p><p>老年代收集器：Serial Old、Parallel Old、CMS；</p><p>整堆收集器：G1；</p><ul><li>两个收集器间有连线，表明它们可以搭配使用：</li></ul><p>Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>相关概念</p><ul><li><p>并行和并发</p><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。</li></ul></li><li><p>吞吐量（Throughput）</p></li></ul><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即</p><p>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。</p><p>假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><ul><li>VM client模式和Server模式</li></ul><p>JVM Server模式与client模式启动，最主要的差别在于：-Server模式启动时，速度较慢，但是一旦运行起来后，性能将会有很大的提升。</p><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>Serial（串行）收集器是最基本、发展历史最悠久的收集器，它是采用复制算法的新生代收集器，曾经（JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。它是一个单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）。这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接收的。</p><ul><li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li><li>简单高效，Client模式下默认的年轻代收集器</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/69.png" alt=""></p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><ul><li>多线程收集，其余的行为，特点都和Serial收集器一样</li><li>单核执行效率不如Serial，在多核下执行才有优势</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/70.png" alt=""></p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge收集器也是一个并行的多线程新生代收集器，它也使用复制算法。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。</p><ul><li>比起关注用户线程停顿时间，更关注系统的吞吐量</li><li>在多核下执行才有优势，Server模式下默认的年轻代收集器</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/70.png" alt=""></p><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old 是 Serial收集器的老年代版本，它同样是一个单线程收集器，使用<strong>“标记-整理”（Mark-Compact）</strong>算法。</p><p>此收集器的主要意义也是在于给Client模式下的虚拟机使用</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/71.png" alt=""></p><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和<strong>“标记-整理”算法。前面已经提到过，这个收集器是在JDK 1.6中才开始提供的，在此之前，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old以外别无选择，所以在Parallel Old诞生以后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感</strong>的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作流程与Parallel Scavenge相同</p><ul><li>多线程，吞吐量优先</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/72.png" alt=""></p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。从名字上（“Mark Sweep”）就可以看出它是基于<strong>“标记-清除”</strong>算法实现的。</p><ul><li>初始标记：stop-the-world</li><li>并发标记：并发追溯标记，程序不会停顿</li><li>并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象</li><li>重新标记：暂停虚拟机，扫描CMS堆中的对象，stop-the-world</li><li>并发清理：清理垃圾对象，程序不会停顿</li><li>并发重置：重置CMS收集器的数据结构</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/73.png" alt=""></p><p>优点：</p><p>CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，因此CMS收集器也被称为并发低停顿收集器（Concurrent Low Pause Collector）。</p><p>缺点：</p><ul><li>无法处理浮动垃圾（Floating Garbage） 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为“浮动垃圾”。</li><li>标记-清除算法导致的空间碎片 CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。</li></ul><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，采用复制和标记整理算法，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p><ul><li>并行和并发</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li><li>将整个java堆内存划分成多个大小相等的Region</li><li>年轻代和老年代将不再物理隔离</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th align="left">收集器</th><th align="left">串行、并行or并发</th><th align="left">新生代/老年代</th><th align="left">算法</th><th align="left">目标</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">Serial</td><td align="left">串行</td><td align="left">新生代</td><td align="left">复制算法</td><td align="left">响应速度优先</td><td align="left">单CPU环境下的Client模式</td></tr><tr><td align="left">Serial Old</td><td align="left">串行</td><td align="left">老年代</td><td align="left">标记-整理</td><td align="left">响应速度优先</td><td align="left">单CPU环境下的Client模式、CMS的后备预案</td></tr><tr><td align="left">ParNew</td><td align="left">并行</td><td align="left">新生代</td><td align="left">复制算法</td><td align="left">响应速度优先</td><td align="left">多CPU环境时在Server模式下与CMS配合</td></tr><tr><td align="left">Parallel Scavenge</td><td align="left">并行</td><td align="left">新生代</td><td align="left">复制算法</td><td align="left">吞吐量优先</td><td align="left">在后台运算而不需要太多交互的任务</td></tr><tr><td align="left">Parallel Old</td><td align="left">并行</td><td align="left">老年代</td><td align="left">标记-整理</td><td align="left">吞吐量优先</td><td align="left">在后台运算而不需要太多交互的任务</td></tr><tr><td align="left">CMS</td><td align="left">并发</td><td align="left">老年代</td><td align="left">标记-清除</td><td align="left">响应速度优先</td><td align="left">集中在互联网站或B/S系统服务端上的Java应用</td></tr><tr><td align="left">G1</td><td align="left">并发</td><td align="left">both</td><td align="left">标记-整理+复制算法</td><td align="left">响应速度优先</td><td align="left">面向服务端应用，将来替换CMS</td></tr></tbody></table><h3 id="java的四种引用类型"><a href="#java的四种引用类型" class="headerlink" title="java的四种引用类型"></a>java的四种引用类型</h3><p>强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul><li>最普遍的引用，例如：Object obj = new Object()</li><li>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收</li><li>如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，obj=null</li></ul><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><ul><li>对象处在有用但非必需的状态</li><li>只有当内存空间不足时，GC才会回收该引用的对象的内存</li><li>常常用来实现高速缓存</li></ul><pre><code>    String str = new String(&quot;abc&quot;) //强引用    SoftReference&lt;String&gt; softRef = new SoftReference&lt;String&gt;(str); //软引用</code></pre><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><ul><li>非必需的对象，比软引用更弱一些</li><li>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</li><li>适于引用被偶尔使用且不影响垃圾收集的对象</li></ul><pre><code>String str = new String(&quot;abc&quot;) //强引用WeakReference&lt;String&gt; weakRef = new WeakReference&lt;String&gt;(str); //弱引用</code></pre><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><ul><li>不会决定对象的生命周期</li><li>任何时候都可能被垃圾回收器回收</li><li>跟踪对象被垃圾回收器回收的活动，起哨兵作用</li><li>必须和引用队列ReferenceQueue联合使用</li></ul><pre><code>String str = new String(&quot;abc&quot;) //强引用ReferenceQueue queue = new ReferenceQueue();    //引用队列PhantomReference&lt;String&gt; phantomRef = new PhantomReference&lt;String&gt;(str); //虚引用</code></pre><h3 id="引用队列（ReferenceQueue）"><a href="#引用队列（ReferenceQueue）" class="headerlink" title="引用队列（ReferenceQueue）"></a>引用队列（ReferenceQueue）</h3><p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p><p>与软引用、弱引用不同，虚引用必须和引用队列一起使用。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm</title>
      <link href="/2020/07/13/mian-shi-jvm/"/>
      <url>/2020/07/13/mian-shi-jvm/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这些都是面试中常问到到jvm知识</li></ul><h2 id="谈谈你对java的理解"><a href="#谈谈你对java的理解" class="headerlink" title="谈谈你对java的理解"></a>谈谈你对java的理解</h2><ul><li>平台无关性：java是一门跨平台的语言</li><li>GC：垃圾回收机制，不用手动去释放堆内存</li><li>语言特性：泛型，反射，lambda表达式</li><li>面向对象：封装，继承，多态</li><li>类库</li><li>异常处理</li></ul><h3 id="如何实现跨平台"><a href="#如何实现跨平台" class="headerlink" title="如何实现跨平台"></a>如何实现跨平台</h3><p>java源码首先被编译成字节码，再由不同平台的JVM进行解析，java语言在不同平台下运行时不需要重新编译，java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令</p><ul><li>为什么JVM不直接解释执行源码<ul><li>准备工作：每次执行都要进行各种检查，语法，安全等；且这些都不会被保存下来，这样每次都会做很多重复的操作，通过生成中间字节码至少可以在重复执行代码的时候省去很多校验和检查</li><li>兼容性：字节码不一定要java源码生成，其他一些语言比如scala也可以编译生成字节码。这样其他语言就可以利用经过多年发展的JVM</li></ul></li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/49.png" alt=""></p><h3 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h3><p>java反射机制是运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制</p><h3 id="jvm如何加载-class文件"><a href="#jvm如何加载-class文件" class="headerlink" title="jvm如何加载.class文件"></a>jvm如何加载.class文件</h3><p>java虚拟机主要包含四个部分：Class Loader,Runtime Data Area,Execution Engine,Native Interface</p><ul><li>Class Loader：依据特定格式将.class文件加载进内存</li><li>Execution Engine：将命令进行解析</li><li>Native Interface：融合不同语言的原生库为java所用</li><li>Runtime Data Area：jvm内存空间结构模型</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/50.png" alt=""></p><p>组件的作用： 首先通过类加载器（ClassLoader）会加载类文件到内存，Class loader只管加载，只要符合文件结构就加载。运行时数据区（Runtime Data Area)是jvm的重点，我们所有所写的程序都被加载到这里，之后才开始运行。而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来融合不同的语言为java所用,从而实现整个程序的功能</p><p>ClassLoader在java中有着非要重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获得Class二进制数据流，它是java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责将Class文件里的二进制数据流装载进系统，然后交给java虚拟机进行连接，初始化等操作。</p><h3 id="类从编译到执行的过程"><a href="#类从编译到执行的过程" class="headerlink" title="类从编译到执行的过程"></a>类从编译到执行的过程</h3><ul><li>编译器把Robot.java源文件编译成Robot.class字节码文件</li><li>ClassLoader将字节码转换为JVM中Class<Robot>对象</li><li>JVM利用Class<Robot>对象实例化为Robot对象</li></ul><h3 id="类加载的执行过程？"><a href="#类加载的执行过程？" class="headerlink" title="类加载的执行过程？"></a>类加载的执行过程？</h3><ul><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>检查：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ul><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><h4 id="什么是ClassLoader"><a href="#什么是ClassLoader" class="headerlink" title="什么是ClassLoader"></a>什么是ClassLoader</h4><p>大家都知道，当我们写好一个Java程序之后，不是管是CS还是BS应用，都是由若干个.class文件组织而成的一个完整的Java应用程序，当程序在运行时，即会调用该程序的一个入口函数来调用系统的相关功能，而这些功能都被封装在不同的class文件当中，所以经常要从这个class文件中要调用另外一个class文件中的方法，如果另外一个文件不存在的，则会引发系统异常。而程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。</p><ul><li>loadClass方法：它接收一个全类名，然后返回一个Class类型的实例，用于加载类</li><li>getParent方法：返回其父类ClassLoader</li></ul><h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>JVM 运行并不是一次性加载所需要的全部类的，它是按需加载，也就是延迟加载。程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会调用 ClassLoader 来加载这些类。加载完成后就会将 Class 对象存在 ClassLoader 里面，下次就不需要重新加载了。</p><p>比如你在调用某个类的静态方法时，首先这个类肯定是需要被加载的，但是并不会触及这个类的实例字段，那么实例字段的类别 Class 就可以暂时不必去加载，但是它可能会加载静态字段相关的类别，因为静态方法会访问静态字段。而实例字段的类别需要等到你实例化对象的时候才可能会加载。</p><h4 id="ClassLoader的种类"><a href="#ClassLoader的种类" class="headerlink" title="ClassLoader的种类"></a>ClassLoader的种类</h4><ul><li>BootStrap ClassLoader：c++编写，称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库java.*，如：rt.jar、resources.jar、charsets.jar等</li><li>Extension ClassLoader：java编写，称为扩展类加载器，负责加载Java的扩展类库javax.*，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。</li><li>App ClassLoader：java编写，称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件</li><li>自定义ClassLoader：java编写，定制化加载</li></ul><p>loadClass() 方法是加载目标类的入口，它首先会查找当前 ClassLoader 以及它的双亲里面是否已经加载了目标类，如果没有找到就会让双亲尝试加载，如果双亲都加载不了，就会调用 findClass() 让自定义加载器自己来加载目标类。ClassLoader 的 findClass() 方法是需要子类来覆盖的，不同的加载器将使用不同的逻辑来获取目标类的字节码。拿到这个字节码之后再调用 defineClass() 方法将字节码转换成 Class 对象</p><p>关键函数：</p><ul><li>findClass方法：用于寻找类文件</li><li>defineClass方法：接收一组字节，然后将它具体化为一个Class类型的实例，它一般从磁盘上加载一个文件，然后将文件的字节传给JVM（native方法）对于class的定义，将其具体化，实例化为一个Class类型实例</li></ul><p>defineClass 通常是和findClass 方法一起使用的，我们通过覆盖ClassLoader父类的findClass 方法来实现类的加载规则，从而取得要加载类的字节码，然后调用defineClass方法生成类的Class 对象</p><h4 id="类加载器的双亲委派机制"><a href="#类加载器的双亲委派机制" class="headerlink" title="类加载器的双亲委派机制"></a>类加载器的双亲委派机制</h4><ul><li>双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。</li><li>先自底向上的检查这个类曾经是否已经完成加载，如果没有加载则自顶向下的尝试加载类</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/51.png" alt=""></p><h4 id="为什么要用双亲委派机制去加载类"><a href="#为什么要用双亲委派机制去加载类" class="headerlink" title="为什么要用双亲委派机制去加载类"></a>为什么要用双亲委派机制去加载类</h4><ul><li>避免多份同样字节码的加载</li><li>保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全</li></ul><h4 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h4><ul><li>隐式加载：new</li><li>显示加载：loadClass，forName；（生成实例需要newInstance，而隐式加载不要）</li></ul><h4 id="loadClass和forName的区别"><a href="#loadClass和forName的区别" class="headerlink" title="loadClass和forName的区别"></a>loadClass和forName的区别</h4><h5 id="类的装载过程"><a href="#类的装载过程" class="headerlink" title="类的装载过程"></a>类的装载过程</h5><ul><li>加载：通过ClassLoader加载class文件字节码，生成Class对象</li><li>链接：<ul><li>校验：检查加载的class的正确性和安全性</li><li>准备：为类变量分配存储空间并设置类变量初始值</li><li>解析：JVM将常量池中的符号引用转换为直接引用（可选）</li></ul></li><li>初始化：执行类变量赋值和静态代码块</li></ul><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul><li>Class.forName得到的class是已经初始化完成的</li><li>Class.loadClass得到的class是还没有进行链接的</li></ul><h5 id="为什么要使用loadClass"><a href="#为什么要使用loadClass" class="headerlink" title="为什么要使用loadClass"></a>为什么要使用loadClass</h5><p>使用loadClass不需要执行初始化类中代码和链接的步骤，这样可以加快类的加载，把类的初始化步骤留给实际使用到这个类的时候去执行</p><h3 id="java的内存模型"><a href="#java的内存模型" class="headerlink" title="java的内存模型"></a>java的内存模型</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/52.png" alt=""></p><ul><li>JVM内存模型-JDK8</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/53.png" alt=""></p><ul><li>线程私有：程序计数器，虚拟机栈，本地方法栈</li><li>线程共享：MetaSpace，Java堆</li></ul><p>各内存模型的具体实现：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/60.png" alt=""></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>它是逻辑计数器，而非物理计数器</p><ul><li>当前线程所执行的字节码的行号指示器</li><li>改变计数器的值就可以获取下一条需要执行的字节码指令</li><li>是线程私有的</li><li>对Java方法进行计数，如果是Native方法则计数器值为Undefined</li><li>不会发生内存泄漏，也是唯一一个不会发生内存溢出的区域。（因为只是记录行号）</li></ul><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><ul><li>Java虚拟机栈也是线程私有的，描述的是Java方法执行的内存模型，每一个方法执行都会开辟一个栈帧，线程请求的栈的深度如果大于虚拟机所允许的最大深度则会抛出StackOverflowError异常,（太多的递归则会出现这个错误，因为每一个递归都会开辟一个栈帧）</li><li>虚拟机栈过多会引发java.lang.OutOfMemoryError异常</li><li>当每一个方法执行完之后，这个栈帧就会自动释放掉，也就是说不需要GC的垃圾回收机制来处理</li><li>一个栈帧包含：局部变量表，操作栈，动态链接，返回地址</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/54.png" alt=""></p><h5 id="局部变量表和操作数栈"><a href="#局部变量表和操作数栈" class="headerlink" title="局部变量表和操作数栈"></a>局部变量表和操作数栈</h5><ul><li>局部变量表：包含方法执行过程中的所有变量</li><li>操作数栈：入栈，出栈，复制，交换，产生消费变量</li></ul><p>局部变量表和操作数栈的关系：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/55.png" alt=""></p><h5 id="i-操作的字节码指令⭐"><a href="#i-操作的字节码指令⭐" class="headerlink" title="i++操作的字节码指令⭐"></a>i++操作的字节码指令⭐</h5><ul><li>将int类型常量加载到操作数栈顶</li><li>将int类型数值从操作数栈顶取出，并存储到到局部变量表的第1个Slot中</li><li>将int类型变量从局部变量表的第1个Slot中取出，并放到操作数栈顶</li><li>将局部变量表的第1个Slot中的int类型变量加1</li><li>表示将int类型数值从操作数栈顶取出，并存储到到局部变量表的第1个Slot中，即i中</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ul><li>与虚拟机栈类似，不过虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务</li></ul><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><ul><li>java堆是java虚拟机中管理的内存中最大的一部分，是线程共享的，唯一的目的就是存放对象实例。所有的对象实例以及数组都要在堆上分配内存，java堆也是垃圾回收器管理的主要区域，也被称为gc堆，收集器基本都采用分代收集算法，java堆还可以细分为新生代，老年代</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/56.png" alt=""></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul><li>方法区是线程共享的，用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，很多人也愿意称之为“永久代”</li><li>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。</li><li>JDK 1.8 中，已经没有方法区(永久代)，而是将方法区直接放在一个与堆不相连的本地内存区域(Native Memory)，这个区域被叫做元空间。</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>是方法区的一部分，用于存储编译器生成的各种字面量和符号引用</li></ul><h4 id="永久代，元空间与方法区的关系"><a href="#永久代，元空间与方法区的关系" class="headerlink" title="永久代，元空间与方法区的关系"></a>永久代，元空间与方法区的关系</h4><ul><li>涉及到内存模型时，往往会提到永久代，那么它和方法区又是什么关系呢？《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。在HotSpot上把GC分代收集扩展至方法区，或者说使用永久代来实现方法区。方法区是java虚拟机中定义，是一种规范，而永久代是一种实现，一个是标准，一个是实现</li><li>对于Java8， HotSpots取消了永久代，那么是不是也就没有方法区了呢？当然不是，方法区是一个规范，规范没变，它就一直在。那么取代永久代的就是元空间</li></ul><h4 id="元空间与永久代"><a href="#元空间与永久代" class="headerlink" title="元空间与永久代"></a>元空间与永久代</h4><p>元空间（MetaSpace）与永久代（PermGen）的区别：</p><ul><li>元空间使用本地内存（比较大），而永久代使用的是jvm内存</li></ul><p>MetaSpace相比PermGen的优势：</p><ul><li>字符串常量存在永久代中，容易出现性能问题和内存溢出</li><li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li><li>永久代会给GC带来不必要的复杂性</li><li>方便HotSpot与其他JVM如Jrockit的集成</li></ul><h3 id="JVM三大性能调优参数"><a href="#JVM三大性能调优参数" class="headerlink" title="JVM三大性能调优参数"></a>JVM三大性能调优参数</h3><ul><li>-Xms：堆的初始值</li><li>-Xmx：堆能达到的最大值</li><li>-Xss：规定了每个线程虚拟机栈（堆栈）的大小</li></ul><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><ul><li>栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</li><li>堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/57.png" alt=""></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/61.png" alt=""></p><p>所以堆与栈的区别很明显：</p><p>1.栈内存存储的是局部变量而堆内存存储的是实体；</p><p>2.栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p><p>3.栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾收机制不定时的回收。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>存放字符串常量和基本类型常量（public static final）。常量池位于堆内存</p><p>常量池的好处是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><p>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p><p>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</p><p>（2）节省运行时间：比较字符串时，== 比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</p><h3 id="理解堆，栈，常量池的几种实例"><a href="#理解堆，栈，常量池的几种实例" class="headerlink" title="理解堆，栈，常量池的几种实例"></a>理解堆，栈，常量池的几种实例</h3><ul><li>int a = 3;int b = 3;的内部工作</li></ul><p>栈有一个很重要的特殊性，就是存在栈中的数据可以共享。编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。</p><ul><li>String是一个特殊的包装类数据</li></ul><pre><code>    即可以用    String str = new String(&quot;abc&quot;); 的形式来创建    也可以用    String str = &quot;abc&quot;; 的形式来创建</code></pre><ul><li>关于String str = “abc”的内部工作。Java内部将此语句转化为以下几个步骤：<ul><li>(1) 先定义一个名为str的对String类的对象引用变量放入栈中。</li><li>(2) 在常量池中查找是否存在内容为”abc”字符串对象。</li><li>(3) 如果不存在则在常量池中创建”abc”，并让str引用该对象。</li><li>(4) 如果存在则直接让str引用该对象。</li></ul></li></ul><ul><li>我们再来看看 String str = new String(“abc”)创建过程<ul><li>(1) 先定义一个名为str的对String类的对象引用变量放入栈中。</li><li>(2) 然后在堆中（不是常量池）创建一个指定的对象，并让str引用指向该对象。</li><li>(3) 在常量池中查找是否存在内容为”abc”字符串对象。</li><li>(4) 如果不存在，则在常量池中创建内容为”abc”的字符串对象，并将堆中的对象与之联系起来。</li><li>(5) 如果存在，则将new出来的字符串对象与字符串常量池中的对象联系起来（即让个特殊* 成员变量value的指针指向它）</li></ul></li></ul><p>我们再接着看以下的代码</p><pre><code>    String str1 = new String(&quot;abc&quot;);     String str2 = &quot;abc&quot;;     System.out.println(str1==str2); //false </code></pre><p>创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。</p><p>对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份</p><p>这也就是有道面试题：String s = new String(“abc”);产生几个对象？答：一个或两个，如果常量池中原来没有”abc”,就是两个。</p><ul><li>String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</li></ul><pre><code>    String str1 = &quot;abc&quot;;      String str2 = new String(&quot;abc&quot;);     String str3 = str2.intern();    System.out.println( str1==str2 );  //false    System.out.println( str1==str3 );  //true</code></pre><ul><li>String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。 基本数据类型包装类的值不可修改。不仅仅是String类的值不可修改，所有的基本数据数据类型包装类都不能更改其内部的值。</li></ul><pre><code>    String str1 = &quot;abc&quot;;     String str2 = &quot;abc&quot;;     str1 = &quot;bcd&quot;;     System.out.println(str1 + &quot;,&quot; + str2); //bcd, abc     System.out.println(str1==str2); //false</code></pre><h3 id="元空间，堆，线程独占部分间的联系——内存角度"><a href="#元空间，堆，线程独占部分间的联系——内存角度" class="headerlink" title="元空间，堆，线程独占部分间的联系——内存角度"></a>元空间，堆，线程独占部分间的联系——内存角度</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/58.png" alt=""></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/59.png" alt=""></p><h3 id="Java中对象创建的几种方式。"><a href="#Java中对象创建的几种方式。" class="headerlink" title="Java中对象创建的几种方式。"></a>Java中对象创建的几种方式。</h3><p>创建对象的方式有四种：</p><ul><li>用new关键字创建。</li></ul><pre><code>User user = new User();</code></pre><ul><li>调用对象的clone方法。</li><li>利用反射，调用Class类的或者是Constructor类的newInstance（）方法。</li></ul><pre><code>    User user = User.class.newInstance();</code></pre><p>或者是</p><pre><code>    Constructor&lt;User&gt; constructor =User.class.getConstructor();    User user= constructor.newInstance();</code></pre><ul><li>用反序列化，调用ObjectInputStream类的readObject（）方法。</li></ul><h3 id="什么情况下会发生栈内存溢出。"><a href="#什么情况下会发生栈内存溢出。" class="headerlink" title="什么情况下会发生栈内存溢出。"></a>什么情况下会发生栈内存溢出。</h3><p>在HotSpot虚拟机中是不区分虚拟机栈和本地方法栈，栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈桢在虚拟机栈中入栈到出栈的过程。本地方法栈与虚拟机栈相似，区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><p>栈内存溢出是指线程请求的栈深度大于虚拟机所允许的最大深度，则将抛出StackOverflowError异常（StackOverflowError 不属于 OOM 异常）。最有可能的原因就是方法递归产生的这种结果。</p><p>另一个可能是引用了大的变量，在拓展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常（这个属于内存溢出）。</p><h3 id="Java对象创建的过程是怎么样的。"><a href="#Java对象创建的过程是怎么样的。" class="headerlink" title="Java对象创建的过程是怎么样的。"></a>Java对象创建的过程是怎么样的。</h3><p>对于一个普通的Java对象的创建，大致过程如下：</p><ul><li>虚拟机遇到new指令，到常量池定位到这个类的符号引用。</li><li>检查符号引用代表的类是否被加载、解析、初始化过 ，如果没有的话，则执行相应的类加载过程。</li><li>虚拟机为对象分配内存。 根据Java内存是否规整，分别通过“指针碰撞”或“空闲列表”来分配。</li><li>虚拟机将分配到的内存空间都初始化为零值。</li><li>虚拟机对对象进行必要的设置。</li><li>执行方法，成员变量进行初始化</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射</title>
      <link href="/2020/07/10/java-fan-she/"/>
      <url>/2020/07/10/java-fan-she/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>此文章用来记录java反射的用途和基本用法</li></ul><h3 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h3><p>java反射机制是运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制</p><h3 id="反射的用途"><a href="#反射的用途" class="headerlink" title="反射的用途"></a>反射的用途</h3><p>1、反编译：.class–&gt;.java</p><p>2、通过反射机制访问java对象的属性，方法，构造方法等（包括私有）</p><p>3、当我们在使用IDE,比如Ecplise时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。</p><p>4、反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。</p><p>比如，加载数据库驱动的，用到的也是反射。</p><pre><code>    Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 动态加载mysql驱动</code></pre><h3 id="反射的基本使用"><a href="#反射的基本使用" class="headerlink" title="反射的基本使用"></a>反射的基本使用</h3><ul><li>通过反射机制可以访问java对象的属性，方法和构造方法等（包括私有）</li></ul><pre><code>    //但访问私有东西需要突破访问限制，调用setAccessible(true)方法，设置成true    私有东西.setAccessible(true);//暴力访问(忽略掉访问修饰符)</code></pre><h4 id="获取Class类"><a href="#获取Class类" class="headerlink" title="获取Class类"></a>获取Class类</h4><p>主要有三种方法</p><ul><li>getClass()</li><li>任何数据类型（包括基本数据类型）都有一个”静态”的class属性</li><li>forName(String className),最常用</li></ul><pre><code>    package fanshe;    public class Fanshe {        public static void main(String[] args) {            //第一种方式获取Class对象              Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。            Class stuClass = stu1.getClass();//获取Class对象            System.out.println(stuClass.getName());            //第二种方式获取Class对象            Class stuClass2 = Student.class;            System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个            //第三种方式获取Class对象            try {                Class stuClass3 = Class.forName(&quot;fanshe.Student&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名                System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象            } catch (ClassNotFoundException e) {                e.printStackTrace();            }        }    }</code></pre><p>三种方式中，常用第三种，第一种对象都有了还要反射干什么，第二种需要导入类包，依赖太强，不导包就抛编译错误。一般都使用第三种，一个字符串可以传入也可以写在配置文件中等多种方法。</p><h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><p>通过反射创建实例主要有两种方式</p><ul><li>使用Class的newInstance()方法来创建Class对象对应类的实例</li></ul><pre><code>    Class c = Class.forName(&quot;fanshe.Student&quot;);    Object str = c.newInstance();</code></pre><ul><li>先通过Class对象获取指定的Constructor对象，再调用Constuctor对象的newInstance()方法来创建对象，这种方法可以用指定的构造器构造类的实例,上述是无参构造实例</li></ul><pre><code>    //获取Class对象    Class c = Class.forName(&quot;fanshe.Student&quot;);    //通过Class对象获取指定的Constructor构造器对象    Constructor constructor = c.getConstructor(String.class);    //创建指定的构造器构造类实例    Object str = constructor.newInstance(&quot;Hello reflection&quot;);</code></pre><h4 id="通过反射获取构造方法并使用"><a href="#通过反射获取构造方法并使用" class="headerlink" title="通过反射获取构造方法并使用"></a>通过反射获取构造方法并使用</h4><p>1）批量获取的方法：</p><ul><li>public Constructor[] getConstructors()：所有”公有的”构造方法</li><li>public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</li></ul><p>（2）单个获取的方法，并调用：</p><ul><li>public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法：</li><li>public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有；</li></ul><p>（3） 调用构造方法：</p><p>Constructor–&gt;newInstance(Object… initargs)</p><p>newInstance是 Constructor类的方法（管理构造函数的类）</p><p>api的解释为：newInstance(Object… initargs) ，使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</p><p>它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象，并为之调用。</p><ul><li>例子：Student类：共六个方法</li></ul><pre><code>    package fanshe;    public class Student {        //---------------构造方法-------------------        //（默认的构造方法）        Student(String str){            System.out.println(&quot;(默认)的构造方法 s = &quot; + str);        }        //无参构造方法        public Student(){            System.out.println(&quot;调用了公有、无参构造方法执行了。。。&quot;);        }        //有一个参数的构造方法        public Student(char name){            System.out.println(&quot;姓名：&quot; + name);        }        //有多个参数的构造方法        public Student(String name ,int age){            System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age);//这的执行效率有问题，以后解决。        }        //受保护的构造方法        protected Student(boolean n){            System.out.println(&quot;受保护的构造方法 n = &quot; + n);        }        //私有构造方法        private Student(int age){            System.out.println(&quot;私有的构造方法   年龄：&quot;+ age);        }    }</code></pre><ul><li>测试类</li></ul><pre><code>    package fanshe;    import java.lang.reflect.Constructor;    /*     * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；     *      * 1.获取构造方法：     *         1).批量的方法：     *             public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法                public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)     *         2).获取单个的方法，并调用：     *             public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法：     *             public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；              *         3).调用构造方法：     *             Constructor--&gt;newInstance(Object... initargs)     */    public class Constructors {        public static void main(String[] args) throws Exception {            //1.加载Class对象            Class clazz = Class.forName(&quot;fanshe.Student&quot;);            //2.获取所有公有构造方法            System.out.println(&quot;**********************所有公有构造方法*********************************&quot;);            Constructor[] conArray = clazz.getConstructors();            for(Constructor c : conArray){                System.out.println(c);            }            System.out.println(&quot;************所有的构造方法(包括：私有、受保护、默认、公有)***************&quot;);            conArray = clazz.getDeclaredConstructors();            for(Constructor c : conArray){                System.out.println(c);            }            System.out.println(&quot;*****************获取公有、无参的构造方法*******************************&quot;);            Constructor con = clazz.getConstructor(null);            //1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型            //2&gt;、返回的是描述这个无参构造函数的类对象。            System.out.println(&quot;con = &quot; + con);            //调用构造方法            Object obj = con.newInstance();        //    System.out.println(&quot;obj = &quot; + obj);        //    Student stu = (Student)obj;            System.out.println(&quot;******************获取私有构造方法，并调用*******************************&quot;);            con = clazz.getDeclaredConstructor(char.class);            System.out.println(con);            //调用构造方法            con.setAccessible(true);//暴力访问(忽略掉访问修饰符)            obj = con.newInstance(&#39;男&#39;);        }    }</code></pre><ul><li>控制台输出</li></ul><pre><code>    **********************所有公有构造方法*********************************    public fanshe.Student(java.lang.String,int)    public fanshe.Student(char)    public fanshe.Student()    ************所有的构造方法(包括：私有、受保护、默认、公有)***************    private fanshe.Student(int)    protected fanshe.Student(boolean)    public fanshe.Student(java.lang.String,int)    public fanshe.Student(char)    public fanshe.Student()    fanshe.Student(java.lang.String)    *****************获取公有、无参的构造方法*******************************    con = public fanshe.Student()    调用了公有、无参构造方法执行了。。。    ******************获取私有构造方法，并调用*******************************    public fanshe.Student(char)    姓名：男</code></pre><h4 id="获取成员变量并调用"><a href="#获取成员变量并调用" class="headerlink" title="获取成员变量并调用"></a>获取成员变量并调用</h4><p>1.批量的</p><ul><li>1).Field[] getFields():获取所有的”公有字段”</li><li>2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</li></ul><p>2.获取单个的：</p><ul><li>1).Field getField(String fieldName):获取某个”公有的”字段；</li><li>2).Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</li></ul><ul><li>设置字段的值：</li></ul><pre><code>     Field --&gt; public void set(Object obj,Object value):                 参数说明：                 1.obj:要设置的字段所在的对象；                 2.value:要为字段设置的值；</code></pre><ul><li>Student类：</li></ul><pre><code>    package fanshe.field;    public class Student {        public Student(){        }        //**********字段*************//        public String name;        protected int age;        char sex;        private String phoneNum;        @Override        public String toString() {            return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex                    + &quot;, phoneNum=&quot; + phoneNum + &quot;]&quot;;        }    }</code></pre><ul><li>测试类</li></ul><pre><code>    package fanshe.field;    import java.lang.reflect.Field;    public class Fields {            public static void main(String[] args) throws Exception {                //1.获取Class对象                Class stuClass = Class.forName(&quot;fanshe.field.Student&quot;);                //2.获取字段                System.out.println(&quot;************获取所有公有的字段********************&quot;);                Field[] fieldArray = stuClass.getFields();                for(Field f : fieldArray){                    System.out.println(f);                }                System.out.println(&quot;************获取所有的字段(包括私有、受保护、默认的)********************&quot;);                fieldArray = stuClass.getDeclaredFields();                for(Field f : fieldArray){                    System.out.println(f);                }                System.out.println(&quot;*************获取公有字段**并调用***********************************&quot;);                Field f = stuClass.getField(&quot;name&quot;);                System.out.println(f);                //获取一个对象                Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student();                //为字段设置值                f.set(obj, &quot;刘德华&quot;);//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;                //验证                Student stu = (Student)obj;                System.out.println(&quot;验证姓名：&quot; + stu.name);                System.out.println(&quot;**************获取私有字段****并调用********************************&quot;);                f = stuClass.getDeclaredField(&quot;phoneNum&quot;);                System.out.println(f);                f.setAccessible(true);//暴力反射，解除私有限定                f.set(obj, &quot;18888889999&quot;);                System.out.println(&quot;验证电话：&quot; + stu);            }        }</code></pre><ul><li>控制台输出</li></ul><pre><code>    ************获取所有公有的字段********************    public java.lang.String fanshe.field.Student.name    ************获取所有的字段(包括私有、受保护、默认的)********************    public java.lang.String fanshe.field.Student.name    protected int fanshe.field.Student.age    char fanshe.field.Student.sex    private java.lang.String fanshe.field.Student.phoneNum    *************获取公有字段**并调用***********************************    public java.lang.String fanshe.field.Student.name    验证姓名：刘德华    **************获取私有字段****并调用********************************    private java.lang.String fanshe.field.Student.phoneNum    验证电话：Student [name=刘德华, age=0, sex=</code></pre><h4 id="获取成员方法并调用"><a href="#获取成员方法并调用" class="headerlink" title="获取成员方法并调用"></a>获取成员方法并调用</h4><p>1.批量的：<br>Method[] getMethods():获取所有”公有方法”；（包含了父类的方法也包含Object类）<br>public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</p><p>2.获取单个的：</p><ul><li>Method getMethod(String name,Class&lt;?&gt;… parameterTypes):</li><li>public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes)</li></ul><pre><code>    参数：    name : 方法名；    Class ... : 形参的Class类型对象</code></pre><ul><li>调用方法：</li></ul><pre><code>    Method --&gt; public Object invoke(Object obj,Object... args):                参数说明：                obj : 要调用方法的对象；                args:调用方式时所传递的实参；</code></pre><ul><li>Student类</li></ul><pre><code>    package fanshe.method;    public class Student {        //**************成员方法***************//        public void show1(String s){            System.out.println(&quot;调用了：公有的，String参数的show1(): s = &quot; + s);        }        protected void show2(){            System.out.println(&quot;调用了：受保护的，无参的show2()&quot;);        }        void show3(){            System.out.println(&quot;调用了：默认的，无参的show3()&quot;);        }        private String show4(int age){            System.out.println(&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot; + age);            return &quot;abcd&quot;;        }    }</code></pre><ul><li>测试类</li></ul><pre><code>    package fanshe.method;    import java.lang.reflect.Method;    public class MethodClass {        public static void main(String[] args) throws Exception {            //1.获取Class对象            Class stuClass = Class.forName(&quot;fanshe.method.Student&quot;);            //2.获取所有公有方法            System.out.println(&quot;***************获取所有的”公有“方法*******************&quot;);            stuClass.getMethods();            Method[] methodArray = stuClass.getMethods();            for(Method m : methodArray){                System.out.println(m);            }            System.out.println(&quot;***************获取所有的方法，包括私有的*******************&quot;);            methodArray = stuClass.getDeclaredMethods();            for(Method m : methodArray){                System.out.println(m);            }            System.out.println(&quot;***************获取公有的show1()方法*******************&quot;);            Method m = stuClass.getMethod(&quot;show1&quot;, String.class);            System.out.println(m);            //实例化一个Student对象            Object obj = stuClass.getConstructor().newInstance();            m.invoke(obj, &quot;刘德华&quot;);            System.out.println(&quot;***************获取私有的show4()方法******************&quot;);            m = stuClass.getDeclaredMethod(&quot;show4&quot;, int.class);            System.out.println(m);            m.setAccessible(true);//解除私有限定            Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参            System.out.println(&quot;返回值：&quot; + result);            }    }</code></pre><ul><li>控制台输出</li></ul><pre><code>    ***************获取所有的”公有“方法*******************    public void fanshe.method.Student.show1(java.lang.String)    public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException    public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException    public final void java.lang.Object.wait() throws java.lang.InterruptedException    public boolean java.lang.Object.equals(java.lang.Object)    public java.lang.String java.lang.Object.toString()    public native int java.lang.Object.hashCode()    public final native java.lang.Class java.lang.Object.getClass()    public final native void java.lang.Object.notify()    public final native void java.lang.Object.notifyAll()    ***************获取所有的方法，包括私有的*******************    public void fanshe.method.Student.show1(java.lang.String)    private java.lang.String fanshe.method.Student.show4(int)    protected void fanshe.method.Student.show2()    void fanshe.method.Student.show3()    ***************获取公有的show1()方法*******************    public void fanshe.method.Student.show1(java.lang.String)    调用了：公有的，String参数的show1(): s = 刘德华    ***************获取私有的show4()方法******************    private java.lang.String fanshe.method.Student.show4(int)    调用了，私有的，并且有返回值的，int参数的show4(): age = 20    返回值：abcd</code></pre><h4 id="反射main方法"><a href="#反射main方法" class="headerlink" title="反射main方法"></a>反射main方法</h4><ul><li>Student类</li></ul><pre><code>    package fanshe.main;    public class Student {        public static void main(String[] args) {            System.out.println(&quot;main方法执行了。。。&quot;);        }    }</code></pre><ul><li>测试类</li></ul><pre><code>    package fanshe.main;    import java.lang.reflect.Method;    /**     * 获取Student类的main方法、不要与当前的main方法搞混了     */    public class Main {        public static void main(String[] args) {            try {                //1、获取Student对象的字节码                Class clazz = Class.forName(&quot;fanshe.main.Student&quot;);                //2、获取main方法                 Method methodMain = clazz.getMethod(&quot;main&quot;, String[].class);//第一个参数：方法名称，第二个参数：方法形参的类型，                //3、调用main方法                // methodMain.invoke(null, new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;});                 //第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数                 //这里拆的时候将  new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;} 拆成3个对象。。。所以需要将它强转。                 methodMain.invoke(null, (Object)new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;});//方式一                // methodMain.invoke(null, new Object[]{new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}});//方式二                        } catch (Exception e) {                e.printStackTrace();            }        }    }</code></pre><ul><li>控制台输出</li></ul><pre><code>    main方法执行了。。。</code></pre><h4 id="反射方法的其他使用–通过反射越过泛型检查："><a href="#反射方法的其他使用–通过反射越过泛型检查：" class="headerlink" title="反射方法的其他使用–通过反射越过泛型检查："></a>反射方法的其他使用–通过反射越过泛型检查：</h4><p>泛型用在编译期，编译过后泛型擦除（消失掉），所以是可以通过反射越过泛型检查的</p><ul><li>测试类：</li></ul><pre><code>    import java.lang.reflect.Method;    import java.util.ArrayList;    /*     * 通过反射越过泛型检查     * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？     */    public class Demo {        public static void main(String[] args) throws Exception{            ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;();            strList.add(&quot;aaa&quot;);            strList.add(&quot;bbb&quot;);        //    strList.add(100);            //获取ArrayList的Class对象，反向的调用add()方法，添加数据            Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象            //获取add()方法            Method m = listClass.getMethod(&quot;add&quot;, Object.class);            //调用add()方法            m.invoke(strList, 100);            //遍历集合            for(Object obj : strList){                System.out.println(obj);            }        }    }</code></pre><ul><li>控制台输出</li></ul><pre><code>    aaa    bbb    100</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2020/07/07/mian-shi-shu-ju-ku/"/>
      <url>/2020/07/07/mian-shi-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这些都是面试的时候常被问到的一些数据库方面的问题</li></ul><h3 id="如何设计一个关系型数据库"><a href="#如何设计一个关系型数据库" class="headerlink" title="如何设计一个关系型数据库"></a>如何设计一个关系型数据库</h3><h4 id="首先将数据库设计成两大部分"><a href="#首先将数据库设计成两大部分" class="headerlink" title="首先将数据库设计成两大部分"></a>首先将数据库设计成两大部分</h4><ul><li>存储部分：该部分类似于一个文件系统，将数据持久化到存储设备中</li><li>程序实例部分：对存储进行逻辑化的管理</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/43.png" alt=""></p><h4 id="程序实例部分"><a href="#程序实例部分" class="headerlink" title="程序实例部分"></a>程序实例部分</h4><ul><li>存储管理模块：数据的逻辑关系转换成物理的存储关系</li><li>缓存机制：优化执行效率</li><li>sql解析：用于将sql语句解析</li><li>日志管理：记录操作</li><li>权限划分：进行多用户管理</li><li>灾难机制：灾难恢复模块</li><li>索引管理：优化查询效率</li><li>锁管理：让数据库支持并发操作</li></ul><h4 id="提高执行效率的方法"><a href="#提高执行效率的方法" class="headerlink" title="提高执行效率的方法"></a>提高执行效率的方法</h4><p>减少IO、缓存、淘汰机制 </p><ul><li>尽可能减少IO</li><li>一次性读取多行（块，或者页）：这些块或者页中的一部分，可能并不是我们本次所要使用的，而是将其取出存放在缓存中，根据将要使用的行周边这些行业极有可能被使用的经验，缓存的非本次使用数据，也能起到优化效率的作用。</li><li>缓存不宜过大，并且需要有相应的缓存淘汰机制</li></ul><h3 id="数据库的三范式是什么"><a href="#数据库的三范式是什么" class="headerlink" title="数据库的三范式是什么"></a>数据库的三范式是什么</h3><p>数据库第一、第二、第三范式的理解。</p><p>第一范式，是指没有重复的列， 表示数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p><p>第二范式，是指属性完全依赖主键， 要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。</p><p>第三范式，是要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。 也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。</p><h3 id="char-和-varchar-的区别是什么？"><a href="#char-和-varchar-的区别是什么？" class="headerlink" title="char 和 varchar 的区别是什么？"></a>char 和 varchar 的区别是什么？</h3><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p><p>char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p><p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p><p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p><h3 id="说一下-mysql-常用的引擎？"><a href="#说一下-mysql-常用的引擎？" class="headerlink" title="说一下 mysql 常用的引擎？"></a>说一下 mysql 常用的引擎？</h3><p>InnoDB 引擎：MySQL 的5.5之后的默认引擎，InnoDB 引擎提供了对数据库事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p><p>MyISAM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p><h3 id="Myisam和InnoDB的区别⭐"><a href="#Myisam和InnoDB的区别⭐" class="headerlink" title="Myisam和InnoDB的区别⭐"></a>Myisam和InnoDB的区别⭐</h3><ul><li>是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁，适合高并发操作。</li><li>是否支持外键： MyISAM不支持，而InnoDB支持</li><li>是否支持事务：MyISAM不支持，而InnoDB支持</li><li>缓存：MyISAM只缓存索引，InnoDB缓存索引和真实数据，所以对内存要求高</li><li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li></ul><h3 id="如何定位并优化慢查询sql"><a href="#如何定位并优化慢查询sql" class="headerlink" title="如何定位并优化慢查询sql"></a>如何定位并优化慢查询sql</h3><p>具体场景具体分析，这里是大概思路</p><ul><li>根据慢日志来定位慢sql</li><li>通过explain来分析慢sql</li><li>修改sql或者尽量让sql走索引</li></ul><h3 id="SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。"><a href="#SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。" class="headerlink" title="SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。"></a>SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。</h3><p>SQL优化步骤一般是：</p><ul><li>通过show status命令了解各种SQL的执行频率</li><li>定位执行效率较低的SQL语句</li><li>通过EXPLAIN分析较低SQL的执行计划</li><li>通过show profile分析SQL</li><li>通过trace分析优化器如何选择执行计划</li><li>确定问题并采取相应的优化措施</li></ul><p>执行计划是SQL在数据库执行时的表现情况，通常用于SQL性能分析、优化等场景。在MySQL中使用explain关键字来查看。</p><h2 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h2><h3 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h3><ul><li>当我们没有使用索引的时候是如何查询数据的呢？答案是全表扫描，把所有的数据都查询出来缓存，然后进行轮询，但是这个只适用于数据量小的表，当我们表中的数据量非常大的时候进行全表扫描那将变得非常慢。此时我们建立索引就可以优化我们的查询速度</li></ul><h3 id="什么样的信息可以建立索引"><a href="#什么样的信息可以建立索引" class="headerlink" title="什么样的信息可以建立索引"></a>什么样的信息可以建立索引</h3><ul><li>主键，唯一键和普通键都可，只要能让数据有一定区分性的字段。</li></ul><h3 id="密集索引和稀疏索引的区别"><a href="#密集索引和稀疏索引的区别" class="headerlink" title="密集索引和稀疏索引的区别"></a>密集索引和稀疏索引的区别</h3><h3 id="索引是建立的越多越好吗"><a href="#索引是建立的越多越好吗" class="headerlink" title="索引是建立的越多越好吗"></a>索引是建立的越多越好吗</h3><p>当然不是</p><ul><li>数据量小的表不需要建立索引，建立会增加额外的开销</li><li>数据变更需要维护索引，因此更多的索引意味着更高的维护成本</li><li>更多的索引意味着也需要更多的空间</li></ul><h3 id="mysql-索引是怎么实现的？"><a href="#mysql-索引是怎么实现的？" class="headerlink" title="mysql 索引是怎么实现的？"></a>mysql 索引是怎么实现的？</h3><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的 。</p><h3 id="MySQL的索引原理"><a href="#MySQL的索引原理" class="headerlink" title="MySQL的索引原理"></a>MySQL的索引原理</h3><p>mysql索引采用的数据结构主要时B+-Tree，Hash，平衡二叉树</p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><ul><li>从理论上来说二叉查找树的时间复杂度为O(logn)，查找速度和比较次数都是最少的，但为什么不用二叉查找树呢</li><li>因为我们要考虑磁盘IO的影响，每查询下一个节点都会进行一次IO，所以我们要减少IO的次数，对于树来说，IO次数就是树的高度，所以我们要把树变得矮胖，b树和b+树就是这样的树</li></ul><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小</p><p>定义：</p><ul><li>根节点至少包含两个孩子</li><li>树中每个节点最多包含有m个孩子（m&gt;=2）</li><li>除根节点和叶节点外，其他每个节点都因包含ceil(m/2)个孩子（向上取整）</li><li>所有的叶子节点都位于同一层</li><li>k个关键字把节点拆成k+1段，分别指向k+1个儿子，同时满足查找树的大小关系</li></ul><p>关键字：假设每个非终端结点中包含n个关键字信息</p><ul><li>Ki(i=1…n)为关键字，且关键字按顺序升序排序k(i-1)&lt;k(i)</li><li>非叶子结点的关键字个数=儿子数-1；</li><li>非叶子节点的指针：p[1],p[2],…,p[M];其中p[1]指向关键字小于k[1]的子树，p[M]指向关键字大于k[M-1]的子树，其他p[i]指向关键字属于(k[i-1],k[i])的子树</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/44.png" alt=""></p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+-Tree"></a>B+-Tree</h3><p>b+树，是b树的一种变体，查询性能更好。m阶的b+树的特征：</p><p>b+树其定义基本与b树相同，除了：</p><ul><li>非叶子节点的子树指针与关键字个数相同</li><li>非叶子节点的子树指针p[i],指向关键字值[k[i],k[i+1])</li><li>非叶子节点仅用来保存索引，所有数据都保存在叶子节点中（b树是每个关键字都保存数据）</li><li>所有叶子节点都有一个链指针指向下一个叶子节点</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/45.png" alt=""></p><h4 id="b-树相比于b树的查询优势"><a href="#b-树相比于b树的查询优势" class="headerlink" title="b+树相比于b树的查询优势"></a>b+树相比于b树的查询优势</h4><ul><li>b+树中间不保存数据，只保存索引，所以磁盘页可以保存更多节点元素，更“矮胖”</li><li>b+树查询必须找到叶子节点，b树只要匹配到即可不用管元素位置，所以b+树更加稳定（并不慢）</li><li>对于查找范围来说b+树只需遍历叶子节点链表即可，b树却需要重复的进行中序遍历</li></ul><h4 id="b-树更加适合用于做存储索引"><a href="#b-树更加适合用于做存储索引" class="headerlink" title="b+树更加适合用于做存储索引"></a>b+树更加适合用于做存储索引</h4><ul><li>B+树的磁盘读写代价更低</li><li>B+树的查询效率更加稳定</li><li>B+树更加有利于对数据库的扫描</li></ul><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>缺点：</p><ul><li>仅仅只能满足”=”,”IN”,不能使用范围查询</li><li>无法被用来避免数据的排序操作</li><li>不能利用部分索引键来查询</li><li>不能避免表扫描</li><li>遇到大量Hash值相等的情况后性能就不一定比B+-Tree索引高 </li></ul><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><h4 id="如何写SQL能够有效地使用到复合索引"><a href="#如何写SQL能够有效地使用到复合索引" class="headerlink" title="如何写SQL能够有效地使用到复合索引"></a>如何写SQL能够有效地使用到复合索引</h4><p>复合索引也叫组合索引和联合索引，用户可以在多个列上建立索引,这种索引叫做复合索引。复合索引在数据库操作期间所需的开销更小,可以代替多个单一索引。</p><ul><li>创建复合索引：CREATE INDEX columnId ON table1(col1,col2,col3) ;</li><li>使用复合索引：select * from table1 where col1= A and col2= B and col3 = C</li><li>对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高。</li><li>复合索引可以用到多个where条件查询下，比如查询年龄是12和性别是男的所有学生。这样避免了多一次的排序操作。</li></ul><h4 id="联合索引具有最左匹配原则，即最左优先"><a href="#联合索引具有最左匹配原则，即最左优先" class="headerlink" title="联合索引具有最左匹配原则，即最左优先"></a>联合索引具有最左匹配原则，即最左优先</h4><p>比如，我们建立了一个2列的联合索引(col1,col2),实际上已经建立了两个联合索引(col1)、(col1,col2），解释如下：</p><ul><li>B+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了（这种情况下无法使用联合索引）。</li></ul><p>联合索引的意义在于：</p><ul><li>一个顶三个。建了一个(a,b,c)的复合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，因为每多一个索引，都会增加写操作的开销和磁盘空间的开销。</li><li>作为覆盖索引。同样的有复合索引（a,b,c），如果有如下的sql: select a,b,c from table where a=1 and b = 1。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。</li><li>索引列越多，通过索引筛选出的数据越少。</li></ul><h3 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h3><h4 id="聚集索引和非聚集索引的区别"><a href="#聚集索引和非聚集索引的区别" class="headerlink" title="聚集索引和非聚集索引的区别"></a>聚集索引和非聚集索引的区别</h4><ul><li>非聚集索引也称之为辅助索引。聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的数据。聚集索引叶子节点存放的即为整张表的行记录数据；而辅助索引叶子节点除了包含键值以外，还包含了一个书签（bookmark），该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。 所以，聚集索引一般比辅助索引体积大</li><li>由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。在多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上只能找到数据。聚集索引的好处在于，它对于主键的排序查找和范围查找速度都非常快，叶子节点的数据就是用户所要查询的数据。需要注意的是（InnoDB）：<ul><li>如果一个主键被定义了，那么这个主键就是作为聚集索引。</li><li>如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引。</li><li>如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。</li><li>非主键索引存储相关键位和其对应的主键值，包含两次查找（一次是查找非主键索引自身，另一次查找主键索引也就是聚集索引的主键）</li></ul></li></ul><p>另外，切记的是，聚集索引的存储并不是物理上连续的，而是逻辑上连续的。 这其中有两点：</p><ul><li>每个表的数据页通过双向链表链接，页按照主键的顺序排序；</li><li>每个页的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</li></ul><p>辅助索引的存在并不影响数据在聚集索引的组织，所以每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引（也就是聚集索引）的主键，然后在通过主键索引来找到一个完整的行记录。</p><p>以上说的都是InnoDB存储引擎场景下，而对于MyISAM引擎，索引文件和数据文件是分离的，索引文件仅保存数据记录的地址，具体不细究</p><h3 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h3><ul><li>普通索引（INDEX），最基本的索引，没有任何的约束。INDEX index_name(name)</li><li>唯一索引（UNIQUE），与普通索引类似，但索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法与普通索引类似 UNIQUE index_name(name)</li><li>全文索引（FULLTEXT）,MyISAM表全系支持，InnoDB 1.2.x后支持。FULLTEXT(content)</li><li>主键索引（PRIMARY KEY）,特殊的唯一索引，不允许有空值，每张表只能有一个</li><li>复合索引，将多个列组合在一起创建索引，可以覆盖多个列</li></ul><h3 id="索引如何优化"><a href="#索引如何优化" class="headerlink" title="索引如何优化"></a>索引如何优化</h3><ul><li>非空字段not null，mysql很难对空值进行查询优化</li><li>区分度高，离散度大，作为索引尽量不要有大量相同值</li><li>索引值的长度不能太长（比较耗费时间）</li></ul><h2 id="锁模块"><a href="#锁模块" class="headerlink" title="锁模块"></a>锁模块</h2><h3 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h3><ul><li>按锁的粒度划分，分为表级锁，行级锁和页级锁（不常用）</li><li>按锁级别分类，分为共享锁（S）和排它锁（X）</li><li>按加锁方式划分，分为自动锁（进行增删改查时mysql自动加上的锁），显式锁（主动加的锁lock in share mode和for update）</li><li>按操作划分，可分为DML锁（增删改查）和DDL锁（改变表结构）</li><li>按使用方式划分，分为乐观锁和悲观锁</li></ul><h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><p>这两种锁的说法，主要是对“是否真正在数据库层面加锁”进行讨论。</p><p>悲观锁（Pessimistic Locking）</p><p>悲观锁假定当前事务操纵数据资源时，肯定还会有其他事务同时访问该数据资源，为了避免当前事务的操作受到干扰，先锁定资源。悲观锁需使用数据库的锁机制实现，如使用行级排他锁或表级排它锁。</p><p>乐观锁（Optimistic Locking）</p><p>乐观锁假定当前事务操纵数据资源时，不会有其他事务同时访问该数据资源，因此不在数据库层次上的锁定。乐观锁使用由程序逻辑控制的技术来避免可能出现的并发问题。</p><p>唯一能够同时保持高并发和高可伸缩性的方法就是使用带版本检查的乐观锁。</p><p>乐观锁不能解决脏读的问题，因此仍需要数据库至少启用“读已提交”的事务隔离级别。</p><h3 id="说一下乐观锁和悲观锁"><a href="#说一下乐观锁和悲观锁" class="headerlink" title="说一下乐观锁和悲观锁"></a>说一下乐观锁和悲观锁</h3><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</p><p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><p>（如SVN、GIT提交代码就是这样的）</p><p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p><p>一般是 where id=XX for update 来实现 （一般银行转账、工单审批）</p><p>优缺点：</p><p>乐观锁：性能高、重试失败成本不高建议乐观</p><p>悲观锁：性能低，但安全，失败成本高建议悲观，使用不当有死锁风险</p><h3 id="多版本并发控制-MVCC-⭐"><a href="#多版本并发控制-MVCC-⭐" class="headerlink" title="多版本并发控制(MVCC)⭐"></a>多版本并发控制(MVCC)⭐</h3><p>(Multi-Version Concurrency Control)</p><p>可以认为MVCC是行级锁的一个变种，innoDB采用了乐观锁的策略，在每行记录后保存两个隐藏列来实现，这两个列保存了行的版本号信息，每开启一个新事务，版本号自动更新，事务开始时刻的版本号作为事务的版本号。用来和查询到的记录所带的版本号进行比较来判断。</p><h3 id="MyISAM和InnoDB在锁方面之间的区别"><a href="#MyISAM和InnoDB在锁方面之间的区别" class="headerlink" title="MyISAM和InnoDB在锁方面之间的区别"></a>MyISAM和InnoDB在锁方面之间的区别</h3><ul><li>MyISAM用的是表级锁，不支持行级锁</li><li>InnoDB默用的是行级锁，也支持表级锁</li></ul><h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><ul><li>读锁是共享锁，写锁是排他锁</li></ul><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><ul><li>共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。</li></ul><p>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。</p><h4 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h4><ul><li>排他锁（X锁）：用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。</li></ul><p>如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</p><p>我们在操作数据库的时候，可能会由于并发问题而引起的数据的不一致性（数据冲突）</p><h4 id="如何对查询操作上排他锁"><a href="#如何对查询操作上排他锁" class="headerlink" title="如何对查询操作上排他锁"></a>如何对查询操作上排他锁</h4><ul><li>排他锁主要用于数据增删改操作，那么可以对查询表的操作上排他锁吗，当然是可以的，但是上了排他锁之后就不能上其他锁了，只需在查询语句后面加上for update 就可以上一个排他锁</li></ul><pre><code>    select * from person_info_myisam where id between 1 and 2000000 for update;</code></pre><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul><li>为什么在查询大量数据的时候进行增删改操作会很慢(像上读锁后上写锁)<ul><li>因为在进行大量数据查询的时候MyISAM会给表加上一个表级别读锁，而对数据表进行增删改的时候会给表加上一个表级别的写锁，当读锁未被释放的时候，另一个session想对同一张表加上写锁，它就会阻塞，直到所有的读锁都被释放</li></ul></li></ul><ul><li>给表上一个读锁（手动）</li></ul><pre><code>    lock tables person_info_myisam read;    unlock tables;</code></pre><h4 id="MyISAM适用场景"><a href="#MyISAM适用场景" class="headerlink" title="MyISAM适用场景"></a>MyISAM适用场景</h4><ul><li>频繁执行全表count语句(保存了表的行数值，不需要全表扫描)</li><li>对数据增删改的频率不高（增删改要锁表），查询非常频繁</li><li>没有事务</li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li>InnoDB的上锁机制是二段锁<ul><li>何为二段锁，在一个事务操作中，分为加锁阶段和解锁阶段，且所有的加锁操作在解锁操作之前</li><li>当对记录进行更新操作或者select for update(X锁)、lock in share mode(S锁)时，会对记录进行加锁</li><li>解锁，在一个事务中，只有在commit或者rollback时，才是解锁阶段</li></ul></li><li>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</li><li>行级锁和表级锁：当sql语句用到索引的时候InnoDB用的是行级锁，当sql语句没有用到索引的时候是用表级锁把整张表锁住</li></ul><pre><code>    共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE    排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE</code></pre><h4 id="InnoDB适用场景"><a href="#InnoDB适用场景" class="headerlink" title="InnoDB适用场景"></a>InnoDB适用场景</h4><ul><li>数据增删改查都相当频繁（不需要锁住整张表）</li><li>可靠性要求比较高，要求支持事务</li></ul><h3 id="数据库的ACID是什么。"><a href="#数据库的ACID是什么。" class="headerlink" title="数据库的ACID是什么。"></a>数据库的ACID是什么。</h3><p>数据库系统引入事务的主要目的在于，事务会把数据库从一种一致性状态转换为另一种一致状态。</p><p>数据库事务具有以下4个基本特征，也就是著名的ACID。</p><ul><li>Atomic（原子性）：事务中包含的操作被看作是一个整体的业务单元，这个业务单元中的操作要么全部成功，要么全部失败，不会出现部分失败、部分成功的场景。</li><li>Consistency（一致性）：事务在完成时，必须使所有的数据都保持一致状态，在数据库中所有的修改都基于事务，保证了数据的完整性。</li><li>Isolation（隔离性）：数据库定义了隔离级别的概念，通过它的选择，可以在不同程度上压制丢失更新的发生。</li><li>Durability（持久性）：事务结束后，所有的数据会固化到一个地方，如保存到磁盘中，即使断电重启后也可以提供给应用程序访问。</li></ul><h3 id="数据库隔离级别有哪些，各自的含义是什么，MySQL默认的隔离级别是多少。"><a href="#数据库隔离级别有哪些，各自的含义是什么，MySQL默认的隔离级别是多少。" class="headerlink" title="数据库隔离级别有哪些，各自的含义是什么，MySQL默认的隔离级别是多少。"></a>数据库隔离级别有哪些，各自的含义是什么，MySQL默认的隔离级别是多少。</h3><p>隔离级别有四种。</p><ul><li>未提交读：是最低的隔离级别，其含义是允许一个事务读取另外一个事务没有提交的数据。会出现脏读。</li><li>读写提交：是指一个事务只能读取另一个事务已经提交的数据，不能读取未提交的数据。克服了脏读，但会出现不可重复读现象。</li><li>可重复读：克服读写提交中出现的不可重复读现象。但会出现幻读现象。</li><li>串行化：数据库中最高的隔离级别，她会要求所有的SQL都会按照顺序执行，这样就可以克服上述隔离级别出现的各种问题，所以它能完全保证数据的一致性。</li></ul><p>MySQL默认的隔离级别是可重复读。</p><h3 id="数据库的事务隔离-事务隔离级别"><a href="#数据库的事务隔离-事务隔离级别" class="headerlink" title="数据库的事务隔离/事务隔离级别"></a>数据库的事务隔离/事务隔离级别</h3><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。（从小到大）</p><p>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</p><p>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</p><p>REPEATABLE-READ：可重复读，mysql默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</p><p>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p><p>在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决是不彻底的。 通过next key lock解决了幻读的问题。</p><ul><li>Record lock：单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li></ul><ul><li>查询事务隔离级别</li></ul><pre><code>    select @@tx_isolation;</code></pre><ul><li>设置事务隔离级别(这里设置成未提交读)</li></ul><pre><code>    set session transaction isolation level read uncommitted;</code></pre><ul><li>开启事务</li></ul><pre><code>    start transaction;</code></pre><ul><li>事务回滚</li></ul><pre><code>    rollback;</code></pre><h4 id="事务引发的问题以及如何避免"><a href="#事务引发的问题以及如何避免" class="headerlink" title="事务引发的问题以及如何避免"></a>事务引发的问题以及如何避免</h4><p>更新丢失：mysql所有事务隔离级别在数据库层面上都可以避免</p><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。READ-COMMITTED事务隔离级别以上可以避免</p><p>不可重复读 ：是指在一个事务内，多次读同一数据数据发生了变化。REPEATABLE-READ事务隔离级别以上可以避免</p><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。SERIALIZABLE事务隔离级别以上可以避免</p><h4 id="幻读与不可重复读的区别"><a href="#幻读与不可重复读的区别" class="headerlink" title="幻读与不可重复读的区别"></a>幻读与不可重复读的区别</h4><ul><li>不可重复读的重点是修改:<br>同样的条件, 你读取过的数据, 再次读取出来发现值不一样了</li></ul><ul><li>幻读的重点在于新增或者删除<br>同样的条件, 第1次和第2次读出来的记录数不一样</li></ul><h3 id="什么是幻读。"><a href="#什么是幻读。" class="headerlink" title="什么是幻读。"></a>什么是幻读。</h3><p>幻读是指在同一个事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。</p><p>事务A读取与搜索条件相匹配的若干行，事务B以插入或删除行等方式来修改事务A的结果集，然后再提交，就会发生幻读。例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</p><p>在默认的事务隔离级别下，即REPEATABLE READ（可重复读）下，InnoDB存储引擎采用Next-Key Locking机制来避免幻读。</p><h3 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h3><ul><li>当前读：select…lock in share mode, select…for update</li><li>当前读：update,insert,delete</li><li>快照读：不加锁的非阻塞读，select</li></ul><ul><li>当前读：加锁的增删改查语句，无论什么锁，因为读取的是当前最新版本，还要保证并发事务不能修改当前记录，对读取记录加锁。</li><li>快照读：可能读取到的数据不是最新版本而是历史版本。</li><li>read committed级别下。当前读与快照读读取的版本一样。</li><li>repeatable read 级别下，当前读返回的是数据的最新版本，快照读返回的可能数据未修改前的版本也可能是最新的数据版本。因为在RR级别下，事务调用快照读的时机很重要，创建快照的时机决定了读取的版本。</li></ul><ul><li>先更新数据再查询数据</li></ul><p>例： update 数据 版本一 –》版本二</p><p>当前读 —。版本二</p><p>快照读—- 版本二</p><ul><li>快照读—-。版本一数据更新前先调用快照读查询数据后，再更新数据，快照度查询可能会导致数据未获取到最新版本。</li></ul><p>update 数据 版本一 –》版本二</p><p>当前读 —。版本二</p><p>快照读—- 版本一</p><h3 id="InnoDB在RR隔离级别下是如何实现幻读问题的解决的呢？"><a href="#InnoDB在RR隔离级别下是如何实现幻读问题的解决的呢？" class="headerlink" title="InnoDB在RR隔离级别下是如何实现幻读问题的解决的呢？"></a>InnoDB在RR隔离级别下是如何实现幻读问题的解决的呢？</h3><ul><li>表象：快照读（非阻塞读），伪MVCC</li><li>底层：next-key（行锁+Gap锁）<ul><li>a.    在RU、RC隔离级别下不存在Gap锁，所以在RU、RC隔离级别下无法解决幻读；在RR、Serializable隔离级别下都实现了Gap锁，所以解决了幻读现象。</li><li>b. 在RR隔离级别下，如果删、改、查语句的where条件走的是主键索引或者唯一索引<ul><li>i. where条件全部命中，则给该记录加上记录锁。</li><li>ii. where条件不全部命中，则给该记录周围加上Gap锁。</li><li>iii. 加上记录锁或者是Gap锁都是为了防止RR隔离级别下发生幻读现象。</li></ul></li><li>c. 在RR隔离级别下，如果删、改、查语句的where条件没有走索引或者是非唯一索引或非主键索引<br>在当前读where条件如果没有走非唯一索引或者没有走索引，则会使用Gap锁锁住当前记录的Gap，防止幻读的发生</li></ul></li></ul><h3 id="InnoDB中非阻塞读（快照读）底层是怎么实现的？"><a href="#InnoDB中非阻塞读（快照读）底层是怎么实现的？" class="headerlink" title="InnoDB中非阻塞读（快照读）底层是怎么实现的？"></a>InnoDB中非阻塞读（快照读）底层是怎么实现的？</h3><ul><li>记录中存储的隐藏列DB_TRX_ID、DB_ROW_ID、DB_ROLL_ID<ul><li>DB_TRX_ID：最后一次修改本行记录的事务ID</li><li>DB_ROLL_PTR：回滚指针，指向这条记录上的一个版本(存储于rollback segment中)</li><li>DB_ROW_ID：隐含的自增ID，如果数据表没有主键，InnoDB会自动DB_ROW_ID产生一个聚簇索引</li></ul></li><li>undo日志根据上述隐藏列来进行记录数据回滚（版本回滚）</li><li>review机制</li></ul><h3 id="数据库会死锁吗，举一个死锁的例子"><a href="#数据库会死锁吗，举一个死锁的例子" class="headerlink" title="数据库会死锁吗，举一个死锁的例子"></a>数据库会死锁吗，举一个死锁的例子</h3><ul><li>数据库会出现死锁，死锁是两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种相互等待的现象</li><li>举个例子，一个用户A访问表A（锁住了表A），然后访问表B；另一个用户B访问表B（锁住了表B），然后访问表A。这时用户A因为用户B已经锁住了表B，它必须等待用户B进行下一步释放表B，同时用户B需要等待用户A释放表A才能继续，死锁产生了</li></ul><h3 id="解决死锁的办法"><a href="#解决死锁的办法" class="headerlink" title="解决死锁的办法"></a>解决死锁的办法</h3><ul><li>解决死锁最简单的方法就是不要有等待，把所有等待都转换成回滚，并且事务重新开启，但是此方法可能会导致并发性能降低，甚至一个事务都开启不了，所以此方法不适用</li><li>解决死锁的另一个简单方法就是设置超时时间，两个事务在同时等待时，当某一个等待时间超过阈值，其中一个事务进行回滚，另一个事务就能继续进行</li><li>除了超时时间外，当前的数据库还都普遍采用wait-for graph（等待图），来进行死锁检测，这是一种更为主动的死锁检测方法，InnoDB存储引擎中也采用这种方式</li></ul><h2 id="关键语法"><a href="#关键语法" class="headerlink" title="关键语法"></a>关键语法</h2><ul><li>GROUP BY</li><li>HAVING</li><li>统计相关：COUNT,SUM,MAX,MIN,AVG</li></ul><h3 id="三张表"><a href="#三张表" class="headerlink" title="三张表"></a>三张表</h3><ul><li>student表：student_id,name,age,sex</li><li>score表：student_id,course_id,score</li><li>course表：course_id,name</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/46.png" alt=""></p><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><ul><li>满足SELECT子句中的列名必须为分组列或列函数</li><li>列函数对于group by子句定义的每个组各返回一个结果</li><li>GROUP BY我们可以先从字面上来理解，GROUP表示分组，BY后面写字段名，就表示根据哪个字段进行分组</li><li>GROUP BY必须得配合聚合函数来用，分组之后你可以计数（COUNT），求和（SUM），求平均数（AVG）等。</li></ul><h4 id="常见的聚合函数"><a href="#常见的聚合函数" class="headerlink" title="常见的聚合函数"></a>常见的聚合函数</h4><ul><li>count() 计数</li><li>sum() 求和</li><li>avg() 平均数</li><li>max() 最大值</li><li>min() 最小值</li></ul><h4 id="MySQL中Distinct与Group-by的区别。"><a href="#MySQL中Distinct与Group-by的区别。" class="headerlink" title="MySQL中Distinct与Group by的区别。"></a>MySQL中Distinct与Group by的区别。</h4><p>distinct简单来说就是用来去重的，而group by的设计目的则是用来聚合统计的，两者在能够实现的功能上有些相同之处。</p><p>单纯的去重操作使用distinct，速度是快于group by的。</p><h4 id="语法例子"><a href="#语法例子" class="headerlink" title="语法例子"></a>语法例子</h4><ul><li>查询所有同学的学号，选课数和总成绩</li></ul><pre><code>    select student_id,count(course_id),sum(score)    from score    group by student_id</code></pre><ul><li>查询所有同学的学号，姓名，选课数和总成绩</li></ul><pre><code>    select s.student_id,stu.name,count(s.course_id),sum(s.score)    from score s,student stu    where stu.student_id = s.student_id    group by student_id</code></pre><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><ul><li>通常与group by子句一起使用</li><li>where过滤行，having过滤组</li><li>出现在同一sql的顺序：where&gt;group by&gt;having</li></ul><h4 id="语法例子-1"><a href="#语法例子-1" class="headerlink" title="语法例子"></a>语法例子</h4><ul><li>查询平均成绩大于60分的同学的学号和平均成绩</li></ul><pre><code>    select student_id,avg(score)    from score    group by student_id    having avg(score) &gt; 60</code></pre><ul><li>查询学号为1的学生成绩情况</li></ul><pre><code>    #如果省略了group by，那么where的作用就和having是一样的    select * from score where stuent_id = 1    或者    select * from score having student_id = 1</code></pre><ul><li>查询没有学所有课的同学的学号和姓名</li></ul><pre><code>    select stu.student_id,stu.name    from score s,student stu    where s.student_id = stu.student_id    group by s.student_id    having count(*) &lt; {select count(*) form course}</code></pre><h3 id="where与having的区别"><a href="#where与having的区别" class="headerlink" title="where与having的区别"></a>where与having的区别</h3><ul><li>用的地方不一样</li></ul><p>where可以用于select、update、delete和insert into values(select * from table where ..)语句中。</p><p>having只能用于select语句中</p><ul><li>执行的顺序不一样</li></ul><p>where的搜索条件是在执行语句进行分组之前应用</p><p>having的搜索条件是在分组条件后执行的</p><p>即如果where和having一起用时，where会先执行，having后执行</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css样式积累</title>
      <link href="/2020/07/03/css-yang-shi-ji-lei/"/>
      <url>/2020/07/03/css-yang-shi-ji-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="css样式积累"><a href="#css样式积累" class="headerlink" title="css样式积累"></a>css样式积累</h2><ul><li>图标的样式设置一般用span标签</li></ul><pre><code>    /*        背景图标一般用backgroud,no-repeat为不平铺        background-size: contain；使其宽高完全填充至内容区域    */    background: url(&#39;/imgs/icon-cart-checked.png&#39;) no-repeat center;    background-size: contain;</code></pre><ul><li>鼠标移上去时切换图片，header-logo相当于相框，a标签相当于相册，存放两张图片切换（before和after）</li></ul><pre><code>    .header-logo{                        display: inline-block;                        width: 55px;                        height: 55px;                        background-color: #FF6600;                        a{                            display: inline-block;                            width: 110px;                            height: 55px;                            &amp;:before{                                content: &#39; &#39;;   //给图片留白,一定要留白占位置                                display: inline-block;                                width: 55px;                                height: 55px;                                background: url(&#39;/imgs/mi-logo.png&#39;) no-repeat center;                                background-size: contain;                                transition:margin .2s;                            }                            &amp;:after{                                content: &#39; &#39;;                                display: inline-block;                                width: 55px;                                height: 55px;                                background: url(&#39;/imgs/mi-home.png&#39;) no-repeat center;                                background-size: contain;                            }                            //鼠标移上去的时候切换图片，前面的图片向左移动55px                            &amp;:hover:before{                                margin-left: -55px;                                transition:margin .2s;  //过渡动画效果                            }                        }                    }</code></pre><ul><li>cursor: pointer;    //鼠标放上去就会出现一个小手（a标签自带这样的效果）</li><li>transition: all .5s;  //所有元素出现一个0.5s的动画效果</li></ul><h3 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h3><ul><li>scss的引入使css样式更加灵活，把需要重复使用的css样式放在scss文件中供我们调用</li><li>通过import的方式导入 ： @import “./../assets/scss/base.scss”;</li><li>既可以直接调用，又可以通过函数封装进行调用</li></ul><pre><code>    //定义    @mixin flex($fd:row,$hov:space-between,$col:center){        display: flex;        flex-direction: $fd;        align-items: $col;        justify-content: $hov;    }    //调用，可以传参，不传参就用默认值    @include flex();</code></pre><h3 id="隐藏和显示"><a href="#隐藏和显示" class="headerlink" title="隐藏和显示"></a>隐藏和显示</h3><ul><li>如何制造一个鼠标移上去就显示，不移上去就隐藏的效果,先设置高度为0，透明度为0，鼠标移上去的时候显示高度和透明度</li></ul><pre><code>    &amp;:hover {                color: $colorA;                .children {                  height: 220px;                  opacity: 1;                }              }              .children {                position: absolute;                top: 112px;                left: 0px;                width: 1226px;                border-top: 1px solid #e5e5e5;                box-shadow: 0px 7px 6px 0px rgba(0, 0, 0, 0.11);                z-index: 10;                height: 0;                opacity: 0;         //透明度为0                overflow: hidden;   //内容会被修剪，并且其余内容是不可见的。                transition: all .5s;                .product {                  float: left;                  height: 220px;                  width: 16.6%;                  font-size: 12px;                  line-height: 12px;                  text-align: center;                  position: relative;                  a {                    display: inline-block;                  }                  img {                    width: auto;                    height: 111px;                    margin-top: 26px;                  }                  .product-img {                    height: 137px;                  }                  .product-name {                    font-weight: bold; //字体加粗                    margin-top: 19px;                    margin-bottom: 8px;                    color: $colorB;                  }                  .product-price {                    color: $colorA;                  }                  &amp;:before{                      content: &#39; &#39;;                      position: absolute;                      top: 28px;                      right: 0px;                      border-right: 1px solid $colorF;                      height: 100px;                      width: 1px;                  }                  &amp;:last-child::before{                      display: none;    //最后一个before元素不显示                  }                }              }</code></pre><ul><li>还可以用block和none来显示和隐藏 block为显示 none为不显示</li></ul><pre><code>    //本来显示为隐藏，鼠标移上去的时候显示    display: none;    &amp;:hover {                background-color: $colorA;                .children {                  display: block ;                }              }</code></pre><h3 id="如何用循环显示多行多列（用多维数组）"><a href="#如何用循环显示多行多列（用多维数组）" class="headerlink" title="如何用循环显示多行多列（用多维数组）"></a>如何用循环显示多行多列（用多维数组）</h3><h4 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h4><ul><li>用ul和li标签（这些标签都有自动换行的功能）</li><li>骨架</li></ul><pre><code>    &lt;div class=&quot;children&quot;&gt;                    &lt;ul class=&quot;products&quot; v-for=&quot;(item,i) in menuList&quot; :key=&quot;i&quot;&gt;                      &lt;li class=&quot;product&quot; v-for=&quot;(sub,j) in item&quot; :key=&quot;j&quot;&gt;                        &lt;a :href=&quot;sub?&#39;/#/product/&#39;+sub.id:&#39;&#39;&quot;&gt;                          &lt;img :src=&quot;sub?sub.image:&#39;/imgs/item-box-1.png&#39;&quot; alt /&gt;                          {{sub?sub.name:'小米CC9'}}                        &lt;/a&gt;                      &lt;/li&gt;                    &lt;/ul&gt;                  &lt;/div&gt;</code></pre><ul><li>设置一个多维数组</li></ul><pre><code>    menuList: [            [              {                id: 30,                image: &quot;/imgs/item-box-1.png&quot;,                name: &quot;小米CC9&quot;              },              {                id: 31,                image: &quot;/imgs/item-box-2.png&quot;,                name: &quot;小米8青春版&quot;              },              {                id: 32,                image: &quot;/imgs/item-box-3.jpg&quot;,                name: &quot;Redmi K20 Pro&quot;              },              {                id: 33,                image: &quot;/imgs/item-box-4.jpg&quot;,                name: &quot;移动4G专区&quot;              }            ],            [0, 0, 0, 0],            [0, 0, 0, 0],            [0, 0, 0, 0],            [0, 0, 0, 0],            [0, 0, 0, 0]          ]</code></pre><ul><li>样式（注意使用flex布局，flex=1为平均分布）</li></ul><pre><code>    .children {                display: none;                width: 962px;                position: absolute;                top: -26px;                left: 264px;                background-color: $colorG;                border: 1px solid $colorH;                ul {                  display: flex;                  flex-direction: row;                  justify-content: space-between;                  height: 75px;                  li {                    height: 75px;                    line-height: 75px;                    flex: 1; //平均分布                    padding-left: 23px;                  }                  img {                    width: 42px;                    height: 35px;                    vertical-align: middle; //图片和文字居中                    margin-right: 15px;                  }                  a {                    display: inline-block;                    color: #333333;                    font-size: 14px;                  }                }              }</code></pre><h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><ul><li>用div标签，有自动换行的功能</li><li>骨架</li></ul><pre><code>    &lt;div class=&quot;list-box&quot;&gt;                &lt;div class=&quot;list&quot; v-for=&quot;(arr,i) in phoneList&quot; :key=&quot;i&quot;&gt;                  &lt;div class=&quot;item&quot; v-for=&quot;(item,j) in arr&quot; :key=&quot;j&quot;&gt;                    &lt;span :class=&quot;{&#39;new-pro&#39;:j%2==0}&quot;&gt;新品&lt;/span&gt;                    &lt;div class=&quot;item-img&quot;&gt;                      &lt;img :src=&quot;item.mainImage&quot; /&gt;                    &lt;/div&gt;                    &lt;h3&gt;{{item.name}}&lt;/h3&gt;                    &lt;div class=&quot;item-info&quot;&gt;                      &lt;p&gt;{{item.subtitle}}&lt;/p&gt;                    &lt;/div&gt;                    &lt;div class=&quot;item-price&quot;&gt;                      &lt;p @click=&quot;addCart(item.id)&quot;&gt;{{item.price}}元&lt;/p&gt;                    &lt;/div&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;</code></pre><ul><li>css样式</li></ul><pre><code>    list-box {            .list {              @include flex();              width: 986px;              margin-bottom: 14px;              &amp;:last-child {                margin-bottom: 0;              }              .item {                height: 302px;                width: 236px;                background-color: #ffffff;                text-align: center;                span {                  display: inline-block;                  width: 67px;                  height: 24px;                  line-height: 24px;                  color: #ffffff;                  //设置不同情况不同样式                  &amp;.new-pro {                    background-color: #7ecf68;                  }                  &amp;.kill-pro {                    background-color: #e82626;                  }                }                .item-img {                  img {                    width: 100%;                    height: 195px;                    display: inline-block;                  }                }                .item-info {                  color: #999999;                  margin-bottom: 10px;                  margin-top: 6px;                }                .item-price {                  cursor: pointer;                  height: 30px;                  p {                    display: inline-block;                    color: #f20a0a;                    font-size: 14px;                    font-weight: bold;                    &amp;:after {                      @include bgImg(20px, 30px, &quot;/imgs/icon-cart-hover.png&quot;);                      margin-left: 5px;                      vertical-align: middle;                      content: &quot;&quot;;                    }                  }                }              }            }          }</code></pre><h3 id="如何作一个弹框动画css样式难点"><a href="#如何作一个弹框动画css样式难点" class="headerlink" title="如何作一个弹框动画css样式难点"></a>如何作一个弹框动画css样式难点</h3><ul><li>如何是弹框一直居中，注意position和transform要搭配使用</li></ul><pre><code>    position: fixed;    //fixed固定定位，相对于浏览器    top: 40%;    left: 50%;    width: 660px;    height: auto;    transform: translate(-50%,-50%);    //往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置</code></pre><ul><li>absolute和fixed的区别<ul><li>fixed:固定定位</li><li>absolute:绝对定位</li><li>1、没有滚动条的情况下没有差异</li><li>2、在有滚动条的情况下，fixed定位不会随滚动条移动而移动，而absolute则会随滚动条移动</li></ul></li><li>放大效果 transform: scale(1.5);  //放大1.5倍</li></ul><h3 id="视频播放时需要注意的css样式"><a href="#视频播放时需要注意的css样式" class="headerlink" title="视频播放时需要注意的css样式"></a>视频播放时需要注意的css样式</h3><ul><li>object-fit: cover; //保持原有尺寸比例。宽度和高度中短的那条边跟容器大小一致，长的那条等比缩放。可能会有部分区域不可见。</li><li>outline: none; //元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用,这里的作用是去掉这条线</li></ul><h4 id="如何实现吸顶功能"><a href="#如何实现吸顶功能" class="headerlink" title="如何实现吸顶功能"></a>如何实现吸顶功能</h4><ul><li>首先我们要知道当前滚动条的高度，当滚动条的高度高于要实现吸顶功能的模块时吸顶，不然不变</li></ul><pre><code>    methods: {        initHeight() {          //获取当前滚动条所处的高度          let scrollTop =            window.pageXOffset ||            document.documentElement.scrollTop ||            document.body.scrollTop;          this.isFixed = scrollTop &gt; 151 ? true : false;        }      },</code></pre><ul><li>监听滚动条的事件</li></ul><pre><code>    mounted() {        //一个监听滚动条的事件        window.addEventListener(&quot;scroll&quot;, this.initHeight);      },</code></pre><ul><li>当退出这个页面时摧毁方法</li></ul><pre><code>    destroyed() {        window.removeEventListener(&quot;scroll&quot;, this.initHeight, false);      }</code></pre><ul><li>设置一个样式，滚动条滑动到模块以下时显示</li></ul><pre><code>    :class=&quot;{&#39;is-fixed&#39;:isFixed}&quot;    &amp;.is-fixed {    position: fixed;    top: 0;    width: 100%;    box-shadow: 0px 5px 5px $colorE; //阴影x轴横向为0，y轴竖向为5px，宽度为5px    }</code></pre><h3 id="添加浮动通用浮动样式"><a href="#添加浮动通用浮动样式" class="headerlink" title="添加浮动通用浮动样式"></a>添加浮动通用浮动样式</h3><ul><li>页面虽然可以使用flex弹性布局，但是有时候还是要用到float浮动样式，我们可以先设置定义好全局通用，要用的时候就拿来用就是了</li><li>记住使用浮动最后要记得清除浮动</li><li>clearfix 是在父组件上设置 </li></ul><pre><code>    .fl {        float: left;    }    .fr {        float: right;    }    .clearfix:before,    .clearfix:after {        content: &#39; &#39;;        display: table;    }    .clearfix:after {        clear: both;    }</code></pre><ul><li>使用</li></ul><pre><code>    &lt;div class=&quot;item-version clearfix&quot;&gt;        &lt;h2&gt;选择版本&lt;/h2&gt;        &lt;div class=&quot;phone fl&quot; :class=&quot;{&#39;checked&#39;:version==1}&quot; @click=&quot;version=1&quot;&gt;6GB+64GB 全网通&lt;/div&gt;        &lt;div class=&quot;phone fr&quot; :class=&quot;{&#39;checked&#39;:version==2}&quot; @click=&quot;version=2&quot;&gt;4GB+64GB 移动4G&lt;/div&gt;      &lt;/div&gt;</code></pre><h3 id="点击选择切换框"><a href="#点击选择切换框" class="headerlink" title="点击选择切换框"></a>点击选择切换框</h3><ul><li>在挑选货物的时候会有很多个样式供我们选则，我们可以点击切换，选择不同的版本，version默认为1，:class=”{‘checked’:version==1}”的意思就是version为1的时候才会显示这个样式</li></ul><pre><code>    &lt;div class=&quot;item-version clearfix&quot;&gt;        &lt;h2&gt;选择版本&lt;/h2&gt;        &lt;div class=&quot;phone fl&quot; :class=&quot;{&#39;checked&#39;:version==1}&quot; @click=&quot;version=1&quot;&gt;6GB+64GB 全网通&lt;/div&gt;        &lt;div class=&quot;phone fr&quot; :class=&quot;{&#39;checked&#39;:version==2}&quot; @click=&quot;version=2&quot;&gt;4GB+64GB 移动4G&lt;/div&gt;      &lt;/div&gt;</code></pre><h3 id="划线"><a href="#划线" class="headerlink" title="划线"></a>划线</h3><ul><li>如何把一行字添加删除划线</li></ul><pre><code>    text-decoration: line-through; //加一条线，划掉</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css动画效果和优化</title>
      <link href="/2020/07/03/css-dong-hua-xiao-guo-he-you-hua/"/>
      <url>/2020/07/03/css-dong-hua-xiao-guo-he-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本片笔记主要讲述了swiper轮播，图片懒加载，组件吸顶，弹框效果（包括遮罩层），animation实现动画效果，svg的使用</li></ul><h3 id="swiper"><a href="#swiper" class="headerlink" title="swiper"></a>swiper</h3><ul><li>如何实现轮播效果，swiper已经帮我们解决了，我们只需要下载vue-awesome-swiper插件</li><li>我们只暂时只需要用到里面的两个组件，直接导入就好了，还有其中的css样式也需要导入</li></ul><pre><code>    import { Swiper, SwiperSlide } from &quot;vue-awesome-swiper&quot;;    import &quot;swiper/css/swiper.css&quot;;</code></pre><h4 id="html骨架"><a href="#html骨架" class="headerlink" title="html骨架"></a>html骨架</h4><ul><li>箭头和分页器</li></ul><pre><code>    &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;swiper-button-prev&quot; slot=&quot;button-prev&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;swiper-button-next&quot; slot=&quot;button-next&quot;&gt;&lt;/div&gt;</code></pre><ul><li>应用</li></ul><pre><code>    &lt;swiper :options=&quot;swiperOptions&quot;&gt;              &lt;swiper-slide v-for=&quot;(item,index) in swiperList&quot; :key=&quot;index&quot;&gt;                &lt;a :href=&quot;&#39;/#/product/&#39; + item.id&quot;&gt;                  &lt;img :src=&quot;item.image&quot; alt /&gt;                &lt;/a&gt;              &lt;/swiper-slide&gt;              &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt;              &lt;div class=&quot;swiper-button-prev&quot; slot=&quot;button-prev&quot;&gt;&lt;/div&gt;              &lt;!--左箭头。如果放置在swiper-container外面，需要自定义样式。--&gt;              &lt;div class=&quot;swiper-button-next&quot; slot=&quot;button-next&quot;&gt;&lt;/div&gt;              &lt;!--右箭头。如果放置在swiper-container外面，需要自定义样式。--&gt;            &lt;/swiper&gt;</code></pre><h4 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h4><ul><li>想实现更多样式还得看中文文档</li></ul><pre><code>    swiperOptions: {            //环绕            loop: true,            //自动切换            autoplay: true,            //方块旋转            effect: &quot;cube&quot;,            cubeEffect: {              slideShadows: true,              shadow: true,              shadowOffset: 100,              shadowScale: 0.6            },            //分页器            pagination: {              el: &quot;.swiper-pagination&quot;,              clickable: true //点击原点可切换            },            //箭头实现切换效果            navigation: {              nextEl: &quot;.swiper-button-next&quot;,              prevEl: &quot;.swiper-button-prev&quot;            }          },</code></pre><h3 id="modal组件"><a href="#modal组件" class="headerlink" title="modal组件"></a>modal组件</h3><ul><li>实现页面弹框效果，这个东西在很多地方都能够复用所以把他设置成一个动态的组件</li><li>因为很多地方都要用这个组件，而且显示的都不一样，所以这些数据都要靠外部先设置，这里就要引入一个新的属性props相当于小程序的properties</li><li>还有把事件抛出，让外部来处理</li></ul><pre><code>    //组件自定义事件    @click=&quot;$emit(&#39;submit&#39;)&quot;    //外部处理事件    @cancel=&quot;showModal=false&quot;</code></pre><ul><li>插槽的使用</li></ul><pre><code>    //设置插槽    &lt;div class=&quot;modal-body&quot;&gt;       &lt;slot name=&quot;body&quot;&gt;标题&lt;/slot&gt;        &lt;/div&gt;    //使用插槽，需要用template包装起来    &lt;template v-slot:body&gt;            &lt;p&gt;商品添加成功！&lt;/p&gt;          &lt;/template&gt;</code></pre><h4 id="如何做出动画效果"><a href="#如何做出动画效果" class="headerlink" title="如何做出动画效果"></a>如何做出动画效果</h4><ul><li>需要在组件的最外层包裹一层，详情去vue的官网</li></ul><pre><code>    //name在写样式的时候有用    &lt;transition name=&quot;slide&quot;&gt;    &lt;/transition&gt;    //然后在样式中加入,注意顺序不能乱    &amp;.slide-enter-active{    top: 0;    }    &amp;.slide-leave-active{        top: -100%;    }    &amp;.slide-enter{        top: -100%;    }    &amp;.slide-leave-to{        top: 0;    }</code></pre><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><ul><li>当一个页面数据太多的时候，会给服务器造成很大的压力，有时候一下加载不出来，我们需要帮服务器减轻这些压力，只有在当前页面显示的先加载，其他的后加载，这时我们需要用到一个插件vue-lazyload,具体的使用方法可以去官网，这里只是用了插件的loading功能</li><li>main.js中use这个插件</li></ul><pre><code>    Vue.use(VueLazyload,{      loading: &#39;/imgs/loading-svg/loading-bars.svg&#39;     //懒加载loading动画    })</code></pre><ul><li>然后使用这个插件，把里面图片:src全换成v-lazy，注意如果是直接是图片路径的话要加单引号</li></ul><pre><code>    :src=&quot;/imgs/mix-alpha.jpg&quot;    v-lazy=&quot;&#39;/imgs/mix-alpha.jpg&#39;&quot;</code></pre><h3 id="商品详情页"><a href="#商品详情页" class="headerlink" title="商品详情页"></a>商品详情页</h3><h4 id="如何实现吸顶功能"><a href="#如何实现吸顶功能" class="headerlink" title="如何实现吸顶功能"></a>如何实现吸顶功能</h4><ul><li>首先我们要知道当前滚动条的高度，当滚动条的高度高于要实现吸顶功能的模块时吸顶，不然不变</li></ul><pre><code>    methods: {        initHeight() {          //获取当前滚动条所处的高度          let scrollTop =            window.pageXOffset ||            document.documentElement.scrollTop ||            document.body.scrollTop;          this.isFixed = scrollTop &gt; 151 ? true : false;        }      },</code></pre><ul><li>监听滚动条的事件</li></ul><pre><code>    mounted() {        //一个监听滚动条的事件        window.addEventListener(&quot;scroll&quot;, this.initHeight);      },</code></pre><ul><li>当退出这个页面时摧毁方法</li></ul><pre><code>    destroyed() {        window.removeEventListener(&quot;scroll&quot;, this.initHeight, false);      }</code></pre><ul><li>设置一个样式，滚动条滑动到模块以下时显示</li></ul><pre><code>    :class=&quot;{&#39;is-fixed&#39;:isFixed}&quot;    &amp;.is-fixed {    position: fixed;    top: 0;    width: 100%;    box-shadow: 0px 5px 5px $colorE; //阴影x轴横向为0，y轴竖向为5px，宽度为5px    }</code></pre><h3 id="视频模块"><a href="#视频模块" class="headerlink" title="视频模块"></a>视频模块</h3><ul><li>先展示视频，aotuplay是自动播放，muted是静音，两者要结合一起使用，不然可能不会自动播放，controls是显示播放控制的一些按钮</li></ul><pre><code>    &lt;video src=&quot;/imgs/product/video.mp4&quot; autoplay muted controls=&quot;controls&quot;&gt;&lt;/video&gt;</code></pre><h4 id="transition实现动画效果"><a href="#transition实现动画效果" class="headerlink" title="transition实现动画效果"></a>transition实现动画效果</h4><ul><li>我们点击视频观看和关闭时都要实现一个动画效果，还要实现一个遮罩效果，overlay就是遮罩效果</li></ul><pre><code>    &lt;div class=&quot;video-box&quot;&gt;      &lt;div class=&quot;overlay&quot; v-if=&quot;showVideo&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;video&quot; :class=&quot;{&#39;slide&#39;:showVideo}&quot;&gt;        &lt;span class=&quot;icon-close&quot; @click=&quot;offvideo&quot;&gt;&lt;/span&gt;        &lt;video src=&quot;/imgs/product/video.mp4&quot; autoplay muted controls=&quot;controls&quot;&gt;&lt;/video&gt;      &lt;/div&gt;    &lt;/div&gt;</code></pre><ul><li>用css样式来实现这个效果</li><li>遮罩层</li></ul><pre><code>    .overlay {            @include position(fixed);            background-color: $colorI;            opacity: 0.5;            z-index: 10;          }</code></pre><ul><li>video，先把它隐藏起来top:-50%，点击展示的时候top:50%，这样就实现了一个动画效果</li></ul><pre><code>    .video {            position: fixed;            top: -50%;            left: 50%;            width: 1000px;            height: 536px;            transform: translate(-50%, -50%);            z-index: 10;            transition: all 0.5s;            &amp;.slide {              top: 50%;            }            video {              width: 100%;              height: 100%;              object-fit: cover; //保持原有尺寸比例。宽度和高度中短的那条边跟容器大小一致，长的那条等比缩放。可能会有部分区域不可见。              outline: none; //元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用,这里的作用是去掉这条线            }            }</code></pre><h4 id="animation实现动画效果"><a href="#animation实现动画效果" class="headerlink" title="animation实现动画效果"></a>animation实现动画效果</h4><ul><li>设置动画名称，在video-box中</li></ul><pre><code>    @keyframes slideDown{        from{          top:-50%;          opacity:0;        }        to{          top:50%;          opacity:1;        }      }      @keyframes slideUp{        from{          top:50%;          opacity:1;        }        to{          top:-50%;          opacity:0;        }      }</code></pre><ul><li>在video中实现</li></ul><pre><code>    &amp;.slideDown{          animation:slideDown .6s linear;          top:50%;        }        &amp;.slideUp{          animation:slideUp .6s linear;        }</code></pre><ul><li>还要在html文件中设置class，不同的情况，切换不同的样式</li></ul><pre><code>    &lt;div class=&quot;video-bg&quot; @click=&quot;showSlide=&#39;slideDown&#39;&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;video-box&quot; v-show=&quot;showSlide&quot;&gt;              &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;              &lt;div class=&quot;video&quot; v-bind:class=&quot;showSlide&quot;&gt;                &lt;span class=&quot;icon-close&quot; @click=&quot;closeVideo&quot;&gt;&lt;/span&gt;                &lt;video src=&quot;/imgs/product/video.mp4&quot; muted autoplay controls=&quot;controls&quot;&gt;&lt;/video&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;</code></pre><h3 id="商品页轮播图效果"><a href="#商品页轮播图效果" class="headerlink" title="商品页轮播图效果"></a>商品页轮播图效果</h3><ul><li>跟上次做的不太一样，这次多加了一些功能</li><li>初始化</li></ul><pre><code>    &lt;swiper :options=&quot;swiperOptions&quot;&gt;              &lt;swiper-slide v-for=&quot;(item,index) in swiperList&quot; :key=&quot;index&quot;&gt;                &lt;img :src=&quot;item&quot; alt /&gt;              &lt;/swiper-slide&gt;              &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt;            &lt;/swiper&gt;</code></pre><ul><li>记住swiperOptions一定要放在data里面</li></ul><pre><code>    swiperOptions: {            autoplay: true,            slidesPerView: 3, //设置slider容器能够同时显示的slides数量            spaceBetween: 30, //在slide之间设置距离            freeMode: true, //默认为false，普通模式：slide滑动时只滑动一格，并自动贴合wrapper，设置为true则变为free模式，slide会根据惯性滑动可能不止一格且不会贴合            //分页器            pagination: {              el: &quot;.swiper-pagination&quot;,              clickable: true //点击原点可切换            }          },</code></pre><ul><li>css样式就很简单了</li></ul><pre><code>    .item-swiper {          margin: 36px auto 56px;          img {            width: 100%;  //撑满swiper-slide容器          }          }</code></pre><h3 id="svg的使用"><a href="#svg的使用" class="headerlink" title="svg的使用"></a>svg的使用</h3><h4 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h4><ul><li>放在整个大容器里面，这里的svg包含三种图片，添加，编辑和删除</li></ul><pre><code>    &lt;svg          version=&quot;1.1&quot;          xmlns=&quot;http://www.w3.org/2000/svg&quot;          xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;          style=&quot;position: absolute; width: 0px; height: 0px; overflow: hidden;&quot;        &gt;          &lt;defs&gt;            &lt;symbol id=&quot;icon-add&quot; viewBox=&quot;0 0 31 32&quot;&gt;              &lt;title&gt;add&lt;/title&gt;              &lt;path                d=&quot;M30.745 15.152h-14.382v-14.596c0-0.308-0.243-0.557-0.543-0.557s-0.543 0.249-0.543 0.557v14.596h-14.665c-0.3 0-0.543 0.249-0.543 0.557s0.243 0.557 0.543 0.557h14.665v15.177c0 0.307 0.243 0.557 0.543 0.557s0.543-0.249 0.543-0.557v-15.177h14.382c0.3 0 0.543-0.249 0.543-0.557s-0.243-0.557-0.543-0.557z&quot;                class=&quot;path1&quot;              /&gt;            &lt;/symbol&gt;            &lt;symbol id=&quot;icon-edit&quot; viewBox=&quot;0 0 32 32&quot;&gt;              &lt;title&gt;edit&lt;/title&gt;              &lt;path                d=&quot;M28.287 8.51l-4.805-4.806 0.831-0.831c0.472-0.472 1.086-0.777 1.564-0.777 0.248 0 0.452 0.082 0.622 0.253l3.143 3.144c0.539 0.54 0.133 1.529-0.524 2.186l-0.831 0.831zM26.805 9.992l-1.138 1.138-4.805-4.806 1.138-1.138 4.805 4.806zM24.186 12.612l-14.758 14.762-4.805-4.806 14.758-14.762 4.805 4.806zM7.379 28.288l-4.892 1.224 1.223-4.894 3.669 3.67zM31.123 4.011l-3.143-3.144c-0.567-0.567-1.294-0.867-2.103-0.867-1.036 0-2.174 0.52-3.045 1.391l-20.429 20.436c-0.135 0.134-0.23 0.302-0.276 0.487l-2.095 8.385c-0.089 0.355 0.017 0.736 0.276 0.995 0.198 0.198 0.461 0.307 0.741 0.307 0.085 0 0.171-0.010 0.254-0.031l8.381-2.096c0.185-0.047 0.354-0.142 0.487-0.276l20.43-20.436c1.409-1.41 2.042-3.632 0.524-5.15v0z&quot;                class=&quot;path1&quot;              /&gt;            &lt;/symbol&gt;            &lt;symbol id=&quot;icon-del&quot; viewBox=&quot;0 0 32 32&quot;&gt;              &lt;title&gt;delete&lt;/title&gt;              &lt;path                d=&quot;M11.355 4.129v-2.065h9.29v2.065h-9.29zM6.194 29.935v-23.742h19.613v23.742h-19.613zM30.968 4.129h-8.258v-3.097c0-0.569-0.463-1.032-1.032-1.032h-11.355c-0.569 0-1.032 0.463-1.032 1.032v3.097h-8.258c-0.569 0-1.032 0.463-1.032 1.032s0.463 1.032 1.032 1.032h3.097v24.774c0 0.569 0.463 1.032 1.032 1.032h21.677c0.569 0 1.032-0.463 1.032-1.032v-24.774h3.097c0.569 0 1.032-0.463 1.032-1.032s-0.463-1.032-1.032-1.032v0z&quot;                class=&quot;path1&quot;              /&gt;              &lt;path                d=&quot;M10.323 9.806c-0.569 0-1.032 0.463-1.032 1.032v14.452c0 0.569 0.463 1.032 1.032 1.032s1.032-0.463 1.032-1.032v-14.452c0-0.569-0.463-1.032-1.032-1.032z&quot;                class=&quot;path2&quot;              /&gt;              &lt;path                d=&quot;M16 9.806c-0.569 0-1.032 0.463-1.032 1.032v14.452c0 0.569 0.463 1.032 1.032 1.032s1.032-0.463 1.032-1.032v-14.452c0-0.569-0.463-1.032-1.032-1.032z&quot;                class=&quot;path3&quot;              /&gt;              &lt;path                d=&quot;M21.677 9.806c-0.569 0-1.032 0.463-1.032 1.032v14.452c0 0.569 0.463 1.032 1.032 1.032s1.032-0.463 1.032-1.032v-14.452c0-0.569-0.463-1.032-1.032-1.032z&quot;                class=&quot;path4&quot;              /&gt;            &lt;/symbol&gt;          &lt;/defs&gt;        &lt;/svg&gt;</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>这里把它包含在一个a标签里，实际上可以防御任何标签，相当于一张图片，当然也可以调整样式</li></ul><pre><code>    &lt;a href=&quot;javascript:;&quot; class=&quot;fr&quot; @click=&quot;editAddr(item)&quot;&gt;        &lt;svg class=&quot;icon&quot;&gt;            &lt;use xlink:href=&quot;#icon-edit&quot; /&gt;        &lt;/svg&gt;    &lt;/a&gt;</code></pre><ul><li>样式</li></ul><pre><code>    fill: $colorA; //XML-SVG专属样式，把颜色填充进去</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/06/29/mian-shi-ji-suan-ji-wang-luo-zhi-shi/"/>
      <url>/2020/06/29/mian-shi-ji-suan-ji-wang-luo-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>此文章用来记录面试中计算机网络的一些核心问题</li></ul><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><ul><li>第一次：客户端向服务端发送SYN包(SYN=1，seq=j),此时进入SYN_SEND状态，等待服务器确认</li><li>第二次：服务端收到SYN包后，必须确认(ACK=1,ack=j+1),然后同时发送一个SYN包(SYN=1,seq=k)，发送完毕后等待客户端确认，进入SYN_RCVD状态</li><li>第三次：客户端收到服务端发送的SYN包和ACK包，进行确认，向服务端发送ACK包(ACK=1,ack=k+1),发送完毕后客户端进入ESTABLISHED 状态，当服务端接收到这个包时，服务端也进入ESTABLISHED 状态，完成三次握手，即可以进行数据传输</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/40.png" alt=""></p><h4 id="为什么-TCP-连接需要三次握手，两次不可以么，为什么？"><a href="#为什么-TCP-连接需要三次握手，两次不可以么，为什么？" class="headerlink" title="为什么 TCP 连接需要三次握手，两次不可以么，为什么？"></a>为什么 TCP 连接需要三次握手，两次不可以么，为什么？</h4><p>为了防止服务器开启一些无用的连接增加服务器开销以及以及防止已经失效的连接请求报文段又传送到了服务端，因而产生错误</p><ul><li>为了防止服务器开启一些无用的请求连接增加服务器开销<ul><li>如果没有第三次握手，服务端直接创建这个连接并且返回SYN,ACK,Seq等数据包给客户端，这些数据包因为网络传输原因丢失了，丢失之后客户端就一直没有收到来自服务端返回的数据包</li><li>服务器端是不知道客户端有没有接收到服务器端返回的信息的，这样没有给服务器端一个创建还是关闭连接端口的请求，服务器端的端口就一直开着，</li><li>客户端可能设置了一个超时时间，当超过了这个时间就会重新发送连接请求，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。那么服务器端上没有接收到请求数据的上一个端口就一直开着，长此以往，这样的端口多了，就会造成服务器端开销的严重浪费</li></ul></li><li>为了防止已经失效的请求报文段突然又传送到了服务端造成错误<ul><li>客户端发送的连接请求报文段并未丢失，而是因为某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间点才到达服务端</li><li>如果没有三次握手，服务端直接确认连接，由于此时客户端并没有发送建立连接的请求，所以不理会服务端，也不与它通信。而此时服务端还在一直等待客户端的请求，就白白浪费了一定的资源</li></ul></li></ul><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p>主要流程为：</p><ul><li>第一次挥手(FIN=1，seq=a)，发送完毕后，客户端进入 FIN_WAIT_1 状态。</li><li>第二次挥手(ACK=1，ACKnum=a+1)，发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态。</li><li>第三次挥手(FIN=1，seq=b)，发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</li><li>第四次挥手(ACK=1，ACKnum=b+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/41.png" alt=""></p><ul><li>为什么需要四次挥手：因为TCP连接是全双工的网络协议，允许同时通信的双方同时进行数据的收发，同样也允许收发两个方向的连接被独立关闭，以避免client数据发送完毕，向server发送FIN关闭连接，而server还有发送到client的数据没有发送完毕的情况。所以关闭TCP连接需要进行四次握手，每次关闭一个方向上的连接需要FIN和ACK两次握手。</li></ul><ul><li>握手过程如果只有两次，可能会出现已失效的连接请求报文突然又传送到了服务端，因而产生错误。</li></ul><ul><li>在三次握手过程中，为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。</li></ul><h4 id="TIME-WAIT和CLOSE-WAIT的区别。"><a href="#TIME-WAIT和CLOSE-WAIT的区别。" class="headerlink" title="TIME_WAIT和CLOSE_WAIT的区别。"></a>TIME_WAIT和CLOSE_WAIT的区别。</h4><p>TIME_WAIT表示主动关闭，CLOSE_WAIT表示被动关闭。</p><p>TCP协议规定，对于已经建立的连接，网络双方要进行四次挥手才能断开连接，如果缺少了其中某个步骤，将会使连接处于假死状态，连接本身占用的资源不会被释放。网络服务器程序要同时管理大量连接，所以很有必要保证无用连接完全断开，否则大量僵死的连接会浪费许多服务器资源。在众多TCP状态中，最值得注意的状态有两个：CLOSE_WAIT和TIME_WAIT。</p><ul><li>TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。一方面是为了把原来的连接里面的重复数据包都已经在网络中消逝。避免老的连接的数据影响新建立的连接（新老连接的IP和端口号相同，新的被称为老的连接到化身）。 另一方面， 假如客户端回复的ACK丢失，服务端会重发FIN，客户端此时还能接收到FIN，还能再回复一个ACK（此时time_wait会重新计时）（MSL是指一个包的最大存活时间，一般是两分钟。）</li><li>另一种对于TIME_WAIT的解释：如果没有TIME_WEIT这个等待，释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的 TCP 报文可能与新 TCP 连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的 TCP 连接的活跃报文全部死翘翘，2MSL 时间可以满足这个需求（尽管非常保守）！</li><li>CLOSE_WAIT是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。</li></ul><h3 id="为什么“握手”是三次，“挥手”却要四次？"><a href="#为什么“握手”是三次，“挥手”却要四次？" class="headerlink" title="为什么“握手”是三次，“挥手”却要四次？"></a>为什么“握手”是三次，“挥手”却要四次？</h3><p>TCP建立连接时之所以只需要”三次握手”，是因为在第二次”握手”过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。</p><p>即SYN建立连接报文与ACK确认接收报文是在同一次”握手”当中传输的，所以”三次握手”不多也不少，正好让双方明确彼此信息互通。</p><p>TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。为何建立连接时一起传输，释放连接时却要分开传输？</p><ul><li>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。</li><li>释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。</li></ul><p>所以是“三次握手”，“四次挥手”。</p><h3 id="为什么客户端在TIME-WAIT阶段要等2MSL"><a href="#为什么客户端在TIME-WAIT阶段要等2MSL" class="headerlink" title="为什么客户端在TIME-WAIT阶段要等2MSL?"></a>为什么客户端在TIME-WAIT阶段要等2MSL?</h3><p>为的是确认服务器端是否收到客户端发出的ACK确认报文</p><p>当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。</p><ul><li>服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；</li></ul><ul><li><p>如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；</p></li><li><p>否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。</p></li><li><p>所以，客户端要经历时长为2MSL的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因</p></li></ul><h3 id="对于TCP连接，客户端不断进行请求链接会怎么样？"><a href="#对于TCP连接，客户端不断进行请求链接会怎么样？" class="headerlink" title="对于TCP连接，客户端不断进行请求链接会怎么样？"></a>对于TCP连接，客户端不断进行请求链接会怎么样？</h3><p>服务器端准备为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认后创建。如果此时客户端一直不确认，会造成 SYN 攻击，即：SYN 攻击，英文为 SYN Flood ，是一种典型的 DoS/DDoS 攻击。</p><ul><li>客户端向服务端发送请求连接数据包。</li><li>服务端向客户端发送确认数据包。</li><li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认。</li></ul><p>这时候服务器上有大量的半连接状态，特别是源IP地址是随机的，基本可以断定是一次SYN攻击。</p><p>对于SYN攻击，只能预防，没有彻底根治的办法，除非不使用 TCP 。方法主要如下：</p><ul><li>限制同时打开SYN半链接的数目。</li><li>缩短SYN半链接的超时时间。</li><li>关闭不必要的服务。</li><li>增加半链接数据。</li><li>过滤网关防护。</li></ul><h3 id="TCP和UDP的区别。"><a href="#TCP和UDP的区别。" class="headerlink" title="TCP和UDP的区别。"></a>TCP和UDP的区别。</h3><p>TCP和UDP都属于传输层协议，它们之间的区别在于：</p><ul><li>TCP 是面向连接的；UDP 是无连接的。</li><li>TCP 是可靠的；UDP 是不可靠的。</li><li>TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多的通信模式。</li><li>TCP 是面向字节流的；UDP 是面向报文的。</li><li>TCP 有拥塞控制机制；UDP 没有拥塞控制，适合媒体通信。</li><li>TCP 首部开销(20 个字节)，比 UDP 的首部开销(8 个字节)要大。</li></ul><h3 id="TCP中RST标志位的作用。"><a href="#TCP中RST标志位的作用。" class="headerlink" title="TCP中RST标志位的作用。"></a>TCP中RST标志位的作用。</h3><p>TCP报文中一共有6个标志位，分别为：URG/ACK/PSH/RST/SYN/FIN。</p><ul><li>SYN：TCP三次握手时，如果A是发起端，则A就对服务器发送一个SYN报文，表示想要建立连接。</li><li>ACK：收到数据或者请求后发送响应时发送ACK报文。</li><li>RST：关闭异常连接。</li><li>FIN：TCP四次挥手时，表示关闭连接。</li><li>PSH：发送端需要发送一段数据，这个数据需要接收端一收到就进行向上交付。而接收端在收到PSH标志位有效的数据时，迅速将数据交付给应用层，所以PSH又叫做急迫比特。</li><li>URG：紧急指针，意思为URG位有效的数据包，是一个紧急需要处理的数据包，需要接收端在接收到之后迅速处理。</li></ul><p>RST标志位应用场景如下。</p><p>TCP正常关闭连接的时候使用FIN，但是如果是关闭异常连接，则使用RST，发送RST包。与FIN包存在两点不同：</p><ul><li>RST不必等缓冲区的包都发出去，直接就丢弃缓冲区的包去发送RST包，而FIN需要先处理完缓冲区的包才行。</li><li>接收端收到RST包之后，不需要发送ACK包进行确认，而接收端接收到FIN包的时候需要ACK包应答。</li></ul><h3 id="说说你知道的几种HTTP响应码，比如200，302和404。"><a href="#说说你知道的几种HTTP响应码，比如200，302和404。" class="headerlink" title="说说你知道的几种HTTP响应码，比如200，302和404。"></a>说说你知道的几种HTTP响应码，比如200，302和404。</h3><p>HTTP响应码主要分为五种：</p><ul><li>1XX：请求处理中，请求已被接收，正在处理。</li><li>2XX：请求成功，请求被成功处理。比如200，OK，表示客户端请求成功。</li><li>3XX：重定向，要完成请求必须进行进一步处理。比如301，Moved Permanently，永久重定向，使用域名跳转；302，Found，临时重定向，未登录的用户访问用户中心重定向到登陆界面。</li><li>4XX：客户端错误，请求不合符。比如400，Bad Request，客户端请求有语法错误，不能被服务器所理解；401，Unauthrized，请求未经授权，这个状态代码必须和WWW-Authenticate 报头域一起使用；403，Forbidden，服务器收到请求，但是拒绝提供服务；404，Not Found，请求资源不存在，输入了错误的URL。</li><li>5XX：服务器端错误，服务器不能处理合法请求。比如500，Internal Servel Error，服务器发生不可预期的错误；503，Server Unavailable，服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li></ul><h3 id="如何理解HTTP协议的无状态性。"><a href="#如何理解HTTP协议的无状态性。" class="headerlink" title="如何理解HTTP协议的无状态性。"></a>如何理解HTTP协议的无状态性。</h3><p>无状态，是指协议对于事务处理没有记忆功能。HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。无状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就很快。</p><p>无状态，更容易做服务的扩容，支撑更大的访问量。</p><h3 id="简述Http请求中get和post的区别及数据包格式。"><a href="#简述Http请求中get和post的区别及数据包格式。" class="headerlink" title="简述Http请求中get和post的区别及数据包格式。"></a>简述Http请求中get和post的区别及数据包格式。</h3><p>GET：对服务器资源的简单请求，把参数包含在URL中。</p><p>POST：用于发送包含用户提交数据的请求，通过request body传递阐述。</p><p>另外，对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><h3 id="HTTP的长连接是什么意思。"><a href="#HTTP的长连接是什么意思。" class="headerlink" title="HTTP的长连接是什么意思。"></a>HTTP的长连接是什么意思。</h3><p>HTTP1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求，此外，由于大多数网页的流量都比较小，一次TCP连接很少能通过slow-start区，不利于提高带宽利用率。</p><p>HTTP 1.1支持<strong>长连接（PersistentConnection）和请求的流水线（Pipelining）</strong>处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。例如：一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。</p><p>HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间（请求的流水线）。</p><p>在HTTP/1.0中，要建立长连接，可以在请求消息中包含Connection: Keep-Alive头域，如果服务器愿意维持这条连接，在响应消息中也会包含一个Connection: Keep-Alive的头域。同时，可以加入一些指令描述该长连接的属性，如max，timeout等。</p><h3 id="HTTPS的加密方式是什么，讲讲整个加密解密流程。"><a href="#HTTPS的加密方式是什么，讲讲整个加密解密流程。" class="headerlink" title="HTTPS的加密方式是什么，讲讲整个加密解密流程。"></a>HTTPS的加密方式是什么，讲讲整个加密解密流程。</h3><p>HTTP直接通过明文在浏览器和服务器之间传递消息，容易被监听抓取到通信内容。</p><p>HTTPS采用对称加密和非对称加密结合的方式来进行通信，HTTPS不是应用层的新协议，而是HTTP通信接口用SSL/TLS来加强加密和认证机制。</p><p>整个加密流程如下：</p><p>需要注意的是，第一次服务器向客户端传输证书的具体过程为：</p><ul><li>把公钥以及服务器的个人信息通过Hash算法生成信息摘要；</li><li>为了防止信息摘要被人调换，服务器还会用CA提供的私钥对信息摘要进行加密来形成数字签名；</li><li>最后还会把原来没Hash算法之前的个人信息以及公钥 和 数字签名合并在一起，形成数字证书。</li></ul><p>当客户端拿到这份数字证书之后，就会用CA提供的公钥来对数字证书里面的数字签名进行解密来得到信息摘要，然后对数字证书里服务器的公钥以及个人信息进行Hash得到另外一份信息摘要。最后把两份信息摘要进行对比，如果一样，则证明这个人是服务器，否则就不是。</p><p>整个的流程如下：</p><ul><li>客户端向服务器发起HTTPS请求，连接到服务器的443端口。</li><li>服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</li><li>服务器将自己的公钥发送给客户端。</li><li>客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</li><li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</li><li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</li><li>然后服务器将加密后的密文发送给客户端。</li><li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</li></ul><p>一共是两次非对称加密+一次对称加密。</p><h3 id="Session和cookie的区别。"><a href="#Session和cookie的区别。" class="headerlink" title="Session和cookie的区别。"></a>Session和cookie的区别。</h3><p>Session和cookie都是实现对话管理的方案。主要区别在于：</p><ul><li>Session在服务端，Cookie存储在客户端。</li><li>Session的运行依赖Session ID，而Session ID是存在Cookie中的，也就是说，如果浏览器禁用了Cookie，同时Session也会失效，但是，可以通过其他方式实现，比如在url参数中传递Session ID。</li><li>Tomcat中的Session是存在服务器内存中，不过也可以通过特殊的方式做持久化处理（memcache，redis），方便Session共享。另外，PHP中的Session是存在文件中的。</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</li></ul><h3 id="用户在浏览器输入一个URL并回车，这个过程涉及到哪些网络协议，请具体描述。"><a href="#用户在浏览器输入一个URL并回车，这个过程涉及到哪些网络协议，请具体描述。" class="headerlink" title="用户在浏览器输入一个URL并回车，这个过程涉及到哪些网络协议，请具体描述。"></a>用户在浏览器输入一个URL并回车，这个过程涉及到哪些网络协议，请具体描述。</h3><p>浏览器输入一个URL并回车：</p><ul><li>首先进行域名解析，浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表。若没有，则搜索操作系统的DNS缓存；若没有，则将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，本地的DNS服务器向根域名服务器发出查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</li><li>得到IP地址以后，浏览器就要与服务器建立一个HTTP连接，因此要用到HTTP协议。HTTP生成一个GET请求报文。</li><li>接下来到了传输层，选择传输协议，TCP或者UDP，TCP是可靠的传输控制协议，对HTTP请求进行封装，加入了端口号等信息。</li><li>然后到了网络层，通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址。</li><li>接下来到了数据链路层，把网络层交下来的IP数据报添加首部和尾部，封装为MAC帧，现在根据目的mac开始建立TCP连接，三次握手，接收端在收到物理层上交的比特流后，根据首尾的标记，识别帧的开始和结束，将中间的数据部分上交给网络层，然后层层向上传递到应用层。</li><li>服务器响应请求并请求客户端要的资源，传回给客户端。</li><li>断开TCP连接，浏览器对页面进行渲染呈现给客户端。</li></ul><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>七层网络模型</p><p>自上而下分别是：</p><ul><li>应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用。</li><li>表示层（数据）：主要解决用户信息的语法表示问题，如加密解密。在表示层进行代码/编码转换。</li><li>会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的。在会话层封装会话控制参数。</li><li>传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等。在传输层封装传输控制。</li><li>网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的传输。在网络层加上逻辑寻址地址。</li><li>数据链路层（帧）：将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正。在数据链路层封装基于MAC的信息。</li><li>物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等。在物理层连接到线缆系统进行实际传递。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/42.png" alt=""></p><h3 id="对于TCP连接，客户端不断进行请求链接会怎么样？-1"><a href="#对于TCP连接，客户端不断进行请求链接会怎么样？-1" class="headerlink" title="对于TCP连接，客户端不断进行请求链接会怎么样？"></a>对于TCP连接，客户端不断进行请求链接会怎么样？</h3><p>服务器端准备为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认后创建。如果此时客户端一直不确认，会造成 SYN 攻击，即：SYN 攻击，英文为 SYN Flood ，是一种典型的 DoS/DDoS 攻击。</p><ul><li>客户端向服务端发送请求连接数据包。</li><li>服务端向客户端发送确认数据包。</li><li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认。</li></ul><p>这时候服务器上有大量的半连接状态，特别是源IP地址是随机的，基本可以断定是一次SYN攻击。</p><p>对于SYN攻击，只能预防，没有彻底根治的办法，除非不使用 TCP 。方法主要如下：</p><ul><li>限制同时打开SYN半链接的数目。</li><li>缩短SYN半链接的超时时间。</li><li>关闭不必要的服务。</li><li>增加半链接数据。</li><li>过滤网关防护。</li></ul><h3 id="CP和UDP的区别。"><a href="#CP和UDP的区别。" class="headerlink" title="CP和UDP的区别。"></a>CP和UDP的区别。</h3><p>TCP和UDP都属于传输层协议，它们之间的区别在于：</p><ul><li>TCP 是面向连接的；UDP 是无连接的。</li><li>TCP 是可靠的；UDP 是不可靠的。</li><li>TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多的通信模式。</li><li>TCP 是面向字节流的；UDP 是面向报文的。</li><li>TCP 有拥塞控制机制；UDP 没有拥塞控制，适合媒体通信。</li><li>TCP 首部开销(20 个字节)，比 UDP 的首部开销(8 个字节)要大。</li></ul><h3 id="TCP中RST标志位的作用。-1"><a href="#TCP中RST标志位的作用。-1" class="headerlink" title="TCP中RST标志位的作用。"></a>TCP中RST标志位的作用。</h3><p>TCP报文中一共有6个标志位，分别为：URG/ACK/PSH/RST/SYN/FIN。</p><ul><li>SYN：TCP三次握手时，如果A是发起端，则A就对服务器发送一个SYN报文，表示想要建立连接。</li><li>ACK：收到数据或者请求后发送响应时发送ACK报文。</li><li>RST：关闭异常连接。</li><li>FIN：TCP四次挥手时，表示关闭连接。</li><li>PSH：发送端需要发送一段数据，这个数据需要接收端一收到就进行向上交付。而接收端在收到PSH标志位有效的数据时，迅速将数据交付给应用层，所以PSH又叫做急迫比特。</li><li>URG：紧急指针，意思为URG位有效的数据包，是一个紧急需要处理的数据包，需要接收端在接收到之后迅速处理。</li></ul><p>RST标志位应用场景如下。</p><p>TCP正常关闭连接的时候使用FIN，但是如果是关闭异常连接，则使用RST，发送RST包。与FIN包存在两点不同：</p><ul><li>RST不必等缓冲区的包都发出去，直接就丢弃缓冲区的包去发送RST包，而FIN需要先处理完缓冲区的包才行。</li><li>接收端收到RST包之后，不需要发送ACK包进行确认，而接收端接收到FIN包的时候需要ACK包应答。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器(centos7.7)上配置java，nginx，mysql，redis环境，并上传前端项目，运行java项目</title>
      <link href="/2020/06/24/a-li-yun-fu-wu-qi/"/>
      <url>/2020/06/24/a-li-yun-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这是我在阿里云服务器上面做环境配置时做的笔记</li></ul><h3 id="centos下安装mysql5-7"><a href="#centos下安装mysql5-7" class="headerlink" title="centos下安装mysql5.7"></a>centos下安装mysql5.7</h3><h4 id="安装mysql数据库"><a href="#安装mysql数据库" class="headerlink" title="安装mysql数据库"></a>安装mysql数据库</h4><ul><li>下载mysql源安装包:wget <a href="http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm" target="_blank" rel="noopener">http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</a></li><li>安装mysql源:yum localinstall mysql57-community-release-el7-8.noarch.rpm<br>若结尾出现complete!，则说明MySQL源安装完成</li><li>检测是否安装完成:yum repolist enabled | grep “mysql.<em>-community.</em>“</li></ul><pre><code>    //出现以下则已安装完成    mysql-connectors-community/x86_64 MySQL Connectors Community                 153    mysql-tools-community/x86_64      MySQL Tools Community                      110    mysql57-community/x86_64          MySQL 5.7 Community Server                 424</code></pre><ul><li>安装mysql:yum install mysql-community-server<br>   若结尾出现Complete!， 则MySQL安装完成</li><li>设置开启启动mysql服务:systemctl enable mysqld</li><li>查看安装的mysql版本:rpm -aq | grep -i mysql</li></ul><pre><code>    mysql57-community-release-el7-8.noarch    mysql-community-client-5.7.30-1.el7.x86_64    mysql-community-libs-5.7.30-1.el7.x86_64    mysql-community-libs-compat-5.7.30-1.el7.x86_64    mysql-community-server-5.7.30-1.el7.x86_64    mysql-community-common-5.7.30-1.el7.x86_64</code></pre><ul><li>启动MySQL服务：systemctl restart mysqld</li><li>查看mysql启动状态：service mysqld status</li><li>重启mysl：service mysqld restart</li><li>查看MySQL初始密码：grep ‘A temporary password’ /var/log/mysqld.log</li></ul><h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><ul><li>该方法先修改mysql配置文件使其可以无密码登录，让后修改密码，之后便复原配置文件</li><li>修改/etc/my.cnf ： vim /etc/my.cnf </li><li>配置文件添加skip-grant-tables</li></ul><pre><code>    [root@VM_0_8_centos ~]# vim /etc/my.cnf    # For advice on how to change settings please see    # http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html    [mysqld]    #    # Remove leading # and set to the amount of RAM for the most important data    # cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.    # innodb_buffer_pool_size = 128M    #    # Remove leading # to turn on a very important data integrity option: logging    # changes to the binary log between backups.    # log_bin    #    # Remove leading # to set options mainly useful for reporting servers.    # The server defaults are faster for transactions and fast SELECTs.    # Adjust sizes as needed, experiment to find the optimal values.    # join_buffer_size = 128M    # sort_buffer_size = 2M    # read_rnd_buffer_size = 2M    datadir=/var/lib/mysql    socket=/var/lib/mysql/mysql.sock    skip-grant-tables                       此处！！！！！！    # Disabling symbolic-links is recommended to prevent assorted security risks    symbolic-links=0</code></pre><ul><li>重启mysql ： service mysqld restart</li><li>即可免密登录，命令行输入mysql直接登录</li></ul><pre><code>    mysql</code></pre><ul><li>选择mysql数据库</li></ul><pre><code>    USE mysql;</code></pre><ul><li>然后输入下列命令重置密码，设置密码为980508 </li></ul><pre><code>    update mysql.user set authentication_string=password(&#39;980508&#39;) where user=&#39;root&#39; and Host =&#39;localhost&#39;;</code></pre><ul><li>然后修改/etc/my.cnf ： vim /etc/my.cnf 去掉加的那一行代码</li></ul><h3 id="设置远程连接"><a href="#设置远程连接" class="headerlink" title="设置远程连接"></a>设置远程连接</h3><ul><li>两种步骤选其一，优先一</li><li>方式一</li></ul><pre><code>    登录到mysql执行如下：     --创建用户（用于远程连接的用户）    GRANT ALL PRIVILEGES ON *.* TO &#39;username&#39;@&#39;%&#39; IDENTIFIED BY &#39;username&#39; WITH GRANT OPTION;    -- 刷新权限表    flush privileges;    查看mysql数据库用户：    SELECT DISTINCT CONCAT(&#39;User: &#39;&#39;&#39;,user,&#39;&#39;&#39;@&#39;&#39;&#39;,host,&#39;&#39;&#39;;&#39;) AS query FROM mysql.user;</code></pre><ul><li>方式二：修改root用户的host 为%</li></ul><pre><code>    1 .登录MySQL 后 执行  use mysql;    然后查看root用户的host   selcet user,host from user;  如果user的host 不是 % ，需要执行update user set host=&#39;%&#39; where user=&#39;root&#39;; 修改     2、修改完成后执行 flush privileges;    3、退出mysql 重启mysql服务     exit;      sercice  mysqld restart </code></pre><h3 id="各种报错解决"><a href="#各种报错解决" class="headerlink" title="各种报错解决"></a>各种报错解决</h3><ul><li>The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement解决方法</li></ul><pre><code>    错误描述：但我们设置远程连接服务时    mysql&gt; grant all on cactidb.* to dbuser@&#39;localhost&#39; identified by &#39;123&#39;;    ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement    解决方法：    先刷新一下权限表。    mysql&gt; flush privileges;    Query OK, 0 rows affected (0.01 sec)    mysql&gt; grant all on cactidb.* to dbuser@&#39;localhost&#39; identified by &#39;123&#39;;    Query OK, 0 rows affected (0.00 sec)</code></pre><ul><li>登录进去后MySQL 输入任何语句都提示You must reset your password using ALTER USER 解决方法</li></ul><pre><code>    SET PASSWORD = PASSWORD(&#39;新密码&#39;);    ALTER USER &#39;root&#39;@&#39;localhost&#39; PASSWORD EXPIRE NEVER;    FLUSH PRIVILEGES;</code></pre><ul><li>Your password does not satisfy the current policy requirements 修改mysql密码出现的错误</li></ul><pre><code>    set global validate_password_policy=0;    set global validate_password_length=1;</code></pre><ul><li>MySQL5.7更改密码时出现ERROR 1054 (42S22): Unknown column ‘password’ in ‘field list’</li></ul><pre><code>    新安装的MySQL5.7，登录时提示密码错误，安装的时候并没有更改密码，后来通过免密码登录的方式更改密码，输入update mysql.user  set password=password(&#39;root&#39;) where user=&#39;root&#39;时提示ERROR 1054 (42S22): Unknown column &#39;password&#39; in &#39;field list&#39;，原来是mysql数据库下已经没有password这个字段了，password字段改成了    authentication_string    所以更改语句替换为update mysql.user set authentication_string=password(&#39;root&#39;) where user=&#39;root&#39; ;即可</code></pre><ul><li>【mysql】ERROR 1054 (42S22): Unknown column ‘‘root‘’ in ‘where clause’</li></ul><pre><code>    今天在安装mysql的时候，前面的步骤都没有太大的问题，但是到了想要重置密码的时候出现了问题，ERROR 1054 (42S22): Unknown column &#39;‘root‘&#39; in &#39;where clause&#39;，不管如何用sql语句进行重置，它都会出现这样的提示语句，我用的语句如下：    update user set password=password(‘123456‘) where user=‘root‘;            但是死活就是报如题中的错误，然后找到了解决的方案，原来是我们在代码和sql工具中写sql语句的时候，字符串用‘’就可以被引用，但是在Xshell环境下，并没有这样的环境，Linux的命令中，似乎“”才是引用字符串的王道，所以只需要把我们想要添加的文字替换成用“”包括就可以了。    update user set password=password(&quot;123456&quot;) where user=&quot;root&quot;;    然后就可以正常登陆</code></pre><h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><ul><li>centos7.7记得搜索安装方法要搜centos7.7安装方法</li><li>下载压缩包</li></ul><p>wget <a href="https://imcfile.oss-cn-beijing.aliyuncs.com/shizhan/file/liaoshixiong/nginx-1.16.1.tar.gz" target="_blank" rel="noopener">https://imcfile.oss-cn-beijing.aliyuncs.com/shizhan/file/liaoshixiong/nginx-1.16.1.tar.gz</a></p><ul><li>查看所有下载的包文件和大小</li></ul><pre><code>    ls -alh</code></pre><ul><li>解压文件</li></ul><pre><code>    tar -zxvf nginx-1.16.1.tar.gz</code></pre><h4 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h4><ul><li>进入nginx目录</li></ul><pre><code>    cd nginx-1.16.1</code></pre><ul><li>配置一些文件</li></ul><pre><code>    //设置安装目录    ./configure --prefix=/usr/local/nginx</code></pre><ul><li>这时可能会报一个错</li></ul><pre><code>    ./configure: error: C compiler cc is not found</code></pre><ul><li>原因是缺少gcc-c++的包，下载</li></ul><pre><code>    yum -y install gcc-c++</code></pre><ul><li>此时又会报错，原因还是缺少一些包</li></ul><pre><code>    ./configure: error: the HTTP rewrite module requires the PCRE library.    You can either disable the module by using --without-http_rewrite_module    option, or install the PCRE library into the system, or build the PCRE library    statically from the source with nginx by using --with-pcre=&lt;path&gt; option.</code></pre><ul><li>我们先更新一下</li></ul><pre><code>    yum update</code></pre><ul><li>然后安装一些组件</li></ul><pre><code>    yum install -y zlib-devel openssl openssl-devel</code></pre><ul><li>此时执行将不会报错</li></ul><pre><code>    ./configure --prefix=/usr/local/nginx</code></pre><ul><li>刚刚是配置，现在输入make，make是编译</li></ul><pre><code>    make</code></pre><ul><li>make不是安装make install才是安装</li></ul><pre><code>    make install</code></pre><ul><li>此时执行nginx，然后会找不到命令，因为我们没有进到安装nginx目录</li><li>查看nginx安装目录</li></ul><pre><code>    ls /usr/local/nginx/sbin/    然后会显示nginx</code></pre><ul><li>执行</li></ul><pre><code>    /usr/local/nginx/sbin/nginx</code></pre><ul><li>但是每次这样启动太麻烦了，我们可以设置一个环境变量，让它在任何目录都可以启动</li></ul><pre><code>    //先cd到根目录    cd    //编辑.bash_profile文件    vim .bash_profile    PATH=$PATH:$HOME/bin    PATH=$PATH:/usr/local/nginx/sbin        此处加上安装的目录！！！！！    //让配置生效    source .bash_profile</code></pre><ul><li>此时直接执行nginx发现可以运行了，但是会报一个错，这是因为我们已经启动了nginx</li></ul><pre><code>    nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)    nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)    nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)    nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)    nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)    nginx: [emerg] still could not bind()</code></pre><ul><li>我们查看运行的nginx进程</li></ul><pre><code>    ps -ef |grep nginx</code></pre><ul><li>如果已经启动起来了，我们浏览器访问服务器公网ip，如果成功你将会看到</li></ul><pre><code>    Welcome to nginx!    If you see this page, the nginx web server is successfully installed and working. Further configuration is required.    For online documentation and support please refer to nginx.org.    Commercial support is available at nginx.com.    Thank you for using nginx.</code></pre><ul><li>但是失败会有两种情况，一是被阿里云服务器防火墙拦截掉了，不允许外网访问，二是nginx服务器压根就没启动，如何区别呢</li></ul><pre><code>    //这是一个测试的方法,可以用来测试nginx有没有启动，阿里云服务器防火墙虽然可以做限制，但是还是无法阻止本地服务访问，所以我们可以以此来判断    curl http://127.0.0.1    //以后调试java应用也可以用此方法调试接口</code></pre><h3 id="部署前端项目代码"><a href="#部署前端项目代码" class="headerlink" title="部署前端项目代码"></a>部署前端项目代码</h3><ul><li>前端项目文件放在/home/www/dist/目录下面</li><li>我们很多nginx服务器配置都在这个目录下面</li></ul><pre><code>    /usr/local/nginx</code></pre><ul><li>然后我们进入到/usr/local/nginx/conf目录</li><li>修改nginx.conf文件，这是我修改后的文件</li></ul><pre><code>    #user  nobody;    worker_processes  1;    #error_log  logs/error.log;    #error_log  logs/error.log  notice;    #error_log  logs/error.log  info;    #pid        logs/nginx.pid;    events {        worker_connections  1024;    }    http {        include       mime.types;        default_type  application/octet-stream;        #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;        #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;        #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;        #access_log  logs/access.log  main;        sendfile        on;        #tcp_nopush     on;        #keepalive_timeout  0;        keepalive_timeout  65;        #gzip  on;        server {            listen       80;               server_name  mi.lhz520.top;            index index.html index.htm login.html;            location ^~/api/ {              proxy_pass http://mall-pre.springboot.cn/;            }          location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$          {            root /home/www/dist/;          }          location ~ .*\.(js|html|css)?$          {            root /home/www/dist/;            expires 30d;          }            #charset koi8-r;            #access_log  logs/host.access.log  main;            location / {                root   /home/www/dist/;                index  index.html index.htm login.html;            }            #error_page  404              /404.html;            # redirect server error pages to the static page /50x.html            #            error_page   500 502 503 504  /50x.html;            location = /50x.html {                root   html;            }            # proxy the PHP scripts to Apache listening on 127.0.0.1:80            #            #location ~ \.php$ {            #    proxy_pass   http://127.0.0.1;            #}            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000            #            #location ~ \.php$ {            #    root           html;            #    fastcgi_pass   127.0.0.1:9000;            #    fastcgi_index  index.php;            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;            #    include        fastcgi_params;            #}            # deny access to .htaccess files, if Apache&#39;s document root            # concurs with nginx&#39;s one            #            #location ~ /\.ht {            #    deny  all;            #}        }        # another virtual host using mix of IP-, name-, and port-based configuration        #        #server {        #    listen       8000;        #    listen       somename:8080;        #    server_name  somename  alias  another.alias;        #    location / {        #        root   html;        #        index  index.html index.htm;        #    }        #}        # HTTPS server        #        #server {        #    listen       443 ssl;        #    server_name  localhost;        #    ssl_certificate      cert.pem;        #    ssl_certificate_key  cert.key;        #    ssl_session_cache    shared:SSL:1m;        #    ssl_session_timeout  5m;        #    ssl_ciphers  HIGH:!aNULL:!MD5;        #    ssl_prefer_server_ciphers  on;        #    location / {        #        root   html;        #        index  index.html index.htm;        #    }        #}    }</code></pre><ul><li>配置完后重启nginx</li></ul><pre><code>    nginx -s reload  ：修改配置后重新加载生效</code></pre><h3 id="部署java项目"><a href="#部署java项目" class="headerlink" title="部署java项目"></a>部署java项目</h3><ul><li>下载jdk</li></ul><pre><code>    wget https://imcfile.oss-cn-beijing.aliyuncs.com/shizhan/file/liaoshixiong/jdk-8u231-linux-x64.tar.gz</code></pre><ul><li>解压</li></ul><pre><code>    tar zxvf jdk-8u231-linux-x64.tar.gz</code></pre><ul><li>然后把解压的文件移动到/usr/local下</li></ul><pre><code>    mv jdk1.8.0_231 /usr/local/</code></pre><ul><li>cd到根目录</li></ul><pre><code>    cd</code></pre><ul><li>配置环境变量vim .bash_profile，往下加两行代码</li></ul><pre><code>    # .bash_profile    # Get the aliases and functions    if [ -f ~/.bashrc ]; then            . ~/.bashrc    fi    # User specific environment and startup programs    PATH=$PATH:$HOME/bin    PATH=$PATH:/usr/local/nginx/sbin    JAVA_HOME=/usr/local/jdk1.8.0_231       此处！！！    PATH=$PATH:$JAVA_HOME/bin               和此处！！！    export PATH</code></pre><ul><li>让配置文件生效</li></ul><pre><code>    source .bash_profile</code></pre><ul><li>查看有没有安装好，输入这些命令就可以知道有没有装好</li></ul><pre><code>    java    java -version</code></pre><ul><li>然后打包java项目</li></ul><pre><code>    mvn clean package -Dmaven.test.skip=true</code></pre><ul><li>打包完以后发现文件名很长，可以改成自己想要的名字，在pom文件中改</li></ul><pre><code>    &lt;build&gt;        &lt;finalName&gt;mall&lt;/finalName&gt;    &lt;build/&gt;</code></pre><ul><li>然后上传到服务器的/root文件夹下面</li><li>运行java程序，一定要设置好开发环境和生产环境，特别是数据库的配置</li></ul><pre><code>    //不能这样，因为这样是使用开发环境，使用的不是服务器上的数据库    java -jar mall.jar    //应该指定环境    java -jar -Dspring.profiles.avtice=prod mall.jar</code></pre><ul><li>如何后台启动java项目呢</li></ul><pre><code>    //创建配置文件，启动脚本    vim /etc/systemd/system/mall.service    //配置文件    [Unit]    Description=mall    After=syslog.target    [Service]    User=root    ExecStart=/usr/local/jdk1.8.0_231/bin/java -jar -Dspring.profiles.active=prod /root/mall.jar    [Install]    WantedBy=multi-user.target</code></pre><ul><li>然后运行</li></ul><pre><code>    systemctl start mall</code></pre><ul><li>查看有没有启动</li></ul><pre><code>    ps -ef |grep java</code></pre><ul><li>这样就已经后台启动好了，我们给它加个日志功能，修改启动脚本</li></ul><pre><code>    vim /etc/systemd/system/mall.service    [Unit]    Description=mall    After=syslog.target    [Service]    User=root    ExecStart=/usr/local/jdk1.8.0_231/bin/java -jar -Dspring.profiles.active=prod -Dlogging.path=/root/logs/ /root/mall.jar    [Install]    WantedBy=multi-user.target</code></pre><ul><li>创建文件夹，日志文件存放在里面</li></ul><pre><code>    mkdir logs</code></pre><ul><li>重启服务</li></ul><pre><code>    systemctl stop mall    systemctl start mall</code></pre><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><ul><li>下载包</li></ul><pre><code>    wget wget http://download.redis.io/releases/redis-5.0.8.tar.gz</code></pre><ul><li>解压到指定路径</li></ul><pre><code>    tar -zxvf redis-5.0.8.tar.gz -C /usr/local</code></pre><ul><li>编译</li></ul><pre><code>    cd /usr/local/redis-5.0.8    make</code></pre><ul><li>编译成功将会出现</li></ul><pre><code>    Hint: It&#39;s a good idea to run &#39;make test&#39; 😉    make[1]: Leaving directory `/usr/local/redis-5.0.8/src&#39;</code></pre><ul><li>然后执行下面命令</li></ul><pre><code>    cd /usr/local/redis-5.0.8/src    make install</code></pre><ul><li>成功</li></ul><pre><code>    Hint: It&#39;s a good idea to run &#39;make test&#39; 😉    INSTALL install    INSTALL install    INSTALL install    INSTALL install    INSTALL install</code></pre><ul><li>修改配置文件</li></ul><pre><code>    vim /usr/local/redis-5.0.8/redis.conf    protected-mode no # 关闭保护模式    daemonize yes     # 守护进程模式开启    bind 127.0.0.1  注释掉，不然远程连接不上</code></pre><ul><li>千万记住修改完配置文件后要重启，不然不会生效！！！踩了好大的坑</li></ul><pre><code>    //以下命令一起输入    /usr/local/redis-5.0.8/src/redis-server &amp;    /usr/local/redis-5.0.8/redis.conf    //或者    cd /usr/local/redis-5.0.8    ./src/redis-server  redis.conf</code></pre><ul><li>启动服务端和客户端</li></ul><pre><code>    /usr/local/redis-5.0.8/src/redis-server    /usr/local/redis-5.0.8/src/redis-cli</code></pre><ul><li>后台启动服务端</li></ul><pre><code>    /usr/local/redis-5.0.8/src/redis-server &amp;</code></pre><ul><li>查看redis进程</li></ul><pre><code>    ps -ef | grep redis</code></pre><ul><li>密码登录客户端</li></ul><pre><code>    cd /usr/local/redis-5.0.8/src    ./redis-cli -h 127.0.0.1 -p 6379 -a 980508</code></pre>]]></content>
      
      
      <categories>
          
          <category> 服务器(centos7.7) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> redis </tag>
            
            <tag> mysql </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex</title>
      <link href="/2020/06/13/vuex/"/>
      <url>/2020/06/13/vuex/</url>
      
        <content type="html"><![CDATA[<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><ul><li>VueX是适用于在Vue项目开发时使用的状态管理工具。试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步data中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。为此，Vue为这些被多个组件频繁使用的值提供了一个统一管理的工具——VueX。在具有VueX的Vue项目中，我们只需要把这些值定义在VueX中，即可在整个Vue项目的组件中使用。</li><li>通俗的来说，组件可以调用自己的data数据，但是组件与组件之间无法跨组件调用，这时vuex就显示他的作用了，vuex就像一个前端数据库，把数据存储进去，从而使所有的组件的能够使用</li></ul><h4 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h4><ul><li>npm i vuex -s</li></ul><h4 id="VueX中的核心内容"><a href="#VueX中的核心内容" class="headerlink" title="VueX中的核心内容"></a>VueX中的核心内容</h4><ul><li>state 存放状态<ul><li>state就相当与数据库的数据</li></ul></li><li>mutations state成员操作<ul><li>mutations就相当于增删改查操作</li></ul></li><li>getters 加工state成员给外界</li><li>actions 异步操作<ul><li>异步操作，提交mutations操作</li></ul></li><li>modules 模块化状态管理</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul><li>初始化store下index.js中的内容</li></ul><pre><code>    import Vue from &#39;vue&#39;;    import Vuex from &#39;vuex&#39;;    import actions from &#39;./actions&#39;    import mutations from &#39;./mutations&#39;    Vue.use(Vuex);    const state = {        username:&#39;&#39;,    //用户名        cartcount: 0    //购物车数量    }    export default new Vuex.Store({        state,        actions,        mutations    })</code></pre><ul><li>mutations</li></ul><pre><code>    //商城Vuex-mutation    export default{        saveUserName(state,username){        //改变数据            state.username = username        },        saveCartCount(state,cartcount){            state.cartcount = cartcount        }    }</code></pre><ul><li>actions</li></ul><pre><code>    //商城Vuex-action    export default{        saveUserName(context,username){        //提交            context.commit(&#39;saveUserName&#39;,username)        },        saveCartCount(context,cartcount){            context.commit(&#39;saveCartCount&#39;,cartcount)        }    }</code></pre><h5 id="将store挂载到当前项目的Vue实例当中去"><a href="#将store挂载到当前项目的Vue实例当中去" class="headerlink" title="将store挂载到当前项目的Vue实例当中去"></a>将store挂载到当前项目的Vue实例当中去</h5><ul><li>main.js,这样就可以全局调用了</li></ul><pre><code>    import store from &#39;./store/index&#39;    new Vue({      store,      router: router,      render: h =&gt; h(App),    }).$mount(&#39;#app&#39;)</code></pre><h5 id="dispatch分配actions任务"><a href="#dispatch分配actions任务" class="headerlink" title="dispatch分配actions任务"></a>dispatch分配actions任务</h5><ul><li>可以在App.vue里使用，这样全局都可以使用这个值了</li></ul><pre><code>      this.$store.dispatch(&#39;saveUserName&#39;,res.username)</code></pre><h5 id="渲染延迟"><a href="#渲染延迟" class="headerlink" title="渲染延迟"></a>渲染延迟</h5><ul><li>当我们拉取数据来渲染页面时会有延迟效果，可能渲染不出来获取的值，我们可以用computed来解决</li></ul><pre><code>    computed: {        username() {          return this.$store.state.username;        },        cartcount() {          return this.$store.state.cartcount;        }      },</code></pre><h5 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h5><ul><li>mapState辅助函数可以帮助我们引用state，与上面的效果是一样的</li></ul><pre><code> import { mapState } from &#39;vuex&#39;; computed: {      ...mapState([&#39;username&#39;, &#39;cartcount&#39;])    },</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios</title>
      <link href="/2020/06/13/axios/"/>
      <url>/2020/06/13/axios/</url>
      
        <content type="html"><![CDATA[<h2 id="axios-简介"><a href="#axios-简介" class="headerlink" title="axios 简介"></a>axios 简介</h2><ul><li><p>axios是网络请求封装的框架，axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p><ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API（本身就是一个promise结构）</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防止 CSRF/XSRF</li></ul></li><li><p>引入方式</p></li></ul><pre><code>    npm install axios</code></pre><ul><li>导入使用</li></ul><pre><code>    import axios from &#39;axios&#39;    import VueAxios from &#39;vue-axios&#39;    //VueAxios的作用是将axios框架挂载到vue实例上，这样我们在其他vue文件中使用axios就不用importer了，直接用this.axios    Vue.use(VueAxios,axios)</code></pre><h3 id="设置全局默认值"><a href="#设置全局默认值" class="headerlink" title="设置全局默认值"></a>设置全局默认值</h3><pre><code>    //根据前端跨域进行调整，`baseURL` 将自动加在 `url` 前面    axios.defaults.baseURL = &#39;/api&#39;    // axios.defaults.baseURL = env.baseURL    //设置超时时间    axios.defaults.timeout = 8000</code></pre><h3 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h3><ul><li>可以通过向 axios 传递相关配置来创建请求</li><li>axios(config)最常用的就是这个可以发送各种请求post，get都行</li></ul><pre><code>    // 发送 POST 请求    axios({      method: &#39;post&#39;,      url: &#39;/user/12345&#39;,      data: {        firstName: &#39;Fred&#39;,        lastName: &#39;Flintstone&#39;      }    });    // 发送 GET 请求（默认的方法）    axios(&#39;/user/12345&#39;);</code></pre><ul><li>为方便起见，为所有支持的请求方法提供了别名</li></ul><pre><code>    axios.request(config)    axios.get(url[, config])    axios.delete(url[, config])    axios.head(url[, config])    axios.post(url[, data[, config]])    axios.put(url[, data[, config]])    axios.patch(url[, data[, config]])</code></pre><ul><li>处理并发请求的助手函数</li></ul><pre><code>    axios.all(iterable)    axios.spread(callback)</code></pre><h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><ul><li>不带参</li></ul><pre><code>    this.axios.get(&quot;/carts&quot;).then(res =&gt; {    this.renderData(res);  });</code></pre><ul><li>带参，参数是加在尾部的如：products?pageNum=2&amp;pageSize=1&amp;categoryId=100002</li></ul><pre><code>    this.axios    .get(&quot;/products&quot;, {      params: {        categoryId: &quot;100012&quot;,        pageSize: 14      }    })    .then(res =&gt; {      res.list = res.list.slice(6, 14);      this.phoneList = [res.list.slice(0, 4), res.list.slice(4, 8)];    });</code></pre><h4 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h4><ul><li>带参数</li></ul><pre><code>    let { username, password, email } = this;  this.axios.post(&quot;/user/register&quot;, {    username,    password,    email  }).then(()=&gt;{    this.$message.success(&#39;注册成功&#39;)  });</code></pre><ul><li>不带参    </li></ul><pre><code>    //退出登陆时把名字和购物车数量设为空，弹出退出信息，userid失效    this.axios.post(&quot;/user/logout&quot;).then(() =&gt; {      this.$message.success(&#39;退出成功&#39;);      this.$cookie.set(&#39;userId&#39;, &#39;&#39;, { expires: &#39;-1&#39; });  //关闭的窗口的时候userid失效      this.$store.dispatch(&#39;saveUserName&#39;, &#39;&#39;);      this.$store.dispatch(&#39;saveCartCount&#39;, &#39;0&#39;);    })</code></pre><h4 id="put请求"><a href="#put请求" class="headerlink" title="put请求"></a>put请求</h4><ul><li>不带参</li></ul><pre><code>    let url = this.allChecked ? &quot;/carts/unSelectAll&quot; : &quot;/carts/selectAll&quot;;  this.axios.put(url).then(res =&gt; {    this.renderData(res);  });</code></pre><ul><li>带参</li></ul><pre><code>    this.axios    .put(`/carts/${item.productId}`, {      quantity,      selected    })    .then(res =&gt; {      this.renderData(res);    });</code></pre><h4 id="delete请求"><a href="#delete请求" class="headerlink" title="delete请求"></a>delete请求</h4><pre><code>this.axios.delete(`/carts/${item.productId}`).then(res =&gt; {        this.renderData(res);      })</code></pre><h3 id="自定义创建实例"><a href="#自定义创建实例" class="headerlink" title="自定义创建实例"></a>自定义创建实例</h3><pre><code>    // 使用由库提供的配置的默认值来创建实例    // 此时超时配置的默认值是 `0`    var instance = axios.create();    // 覆写库的超时默认值    // 现在，在超时前，所有请求都会等待 2.5 秒    instance.defaults.timeout = 2500;    // 为已知需要花费很长时间的请求覆写超时设置    instance.get(&#39;/longRequest&#39;, {      timeout: 5000    });</code></pre><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><ul><li>在请求或响应被 then 或 catch 处理前拦截它们。</li></ul><pre><code>    // 添加请求拦截器    axios.interceptors.request.use(function (config) {        // 在发送请求之前做些什么        return config;      }, function (error) {        // 对请求错误做些什么        return Promise.reject(error);      });    // 添加响应拦截器    axios.interceptors.response.use(function (response) {        // 对响应数据做点什么        return response;      }, function (error) {        // 对响应错误做点什么        return Promise.reject(error);      });</code></pre><ul><li>响应结构</li></ul><pre><code>    {      // `data` 由服务器提供的响应      data: {},      // `status` 来自服务器响应的 HTTP 状态码      status: 200,      // `statusText` 来自服务器响应的 HTTP 状态信息      statusText: &#39;OK&#39;,      // `headers` 服务器响应的头      headers: {},      // `config` 是为请求提供的配置信息      config: {}    }    使用 then 时，你将接收下面这样的响应：    axios.get(&#39;/user/12345&#39;)      .then(function(response) {        console.log(response.data);        console.log(response.status);        console.log(response.statusText);        console.log(response.headers);        console.log(response.config);      });</code></pre><h4 id="接口响应拦截"><a href="#接口响应拦截" class="headerlink" title="接口响应拦截"></a>接口响应拦截</h4><pre><code>    //接口错误拦截    axios.interceptors.response.use(function(response){   //拦截页面返回数据状态码      let res = response.data   //返回的数据为response.data，包括status和data      if(res.status == 0){      //状态码为0代表登陆成功        return res.data      }else if(res.status == 10){    //状态码为10代表未登陆，跳转到登陆页面        if(location.hash!=&quot;#/index&quot;){     //如果没有登录则只能访问首页          window.location.href = &quot;/#/login&quot;   //跳转到登陆页面        }        return Promise.reject()   //发生错误，promise返回拒绝值      }else{        Message.error(res.msg)        return Promise.reject()   //发生错误，promise返回拒绝值      }    },(error)=&gt;{    //拦截http请求状态码（请求发送失败）      let res = error.response      Message.error(res.data.message)      return Promise.reject()   //发生错误，promise返回拒绝值    })</code></pre><h4 id="错误拦截"><a href="#错误拦截" class="headerlink" title="错误拦截"></a>错误拦截</h4><ul><li>记住以后的交互请求功能，res最好加上一个默认值，防止请求不到数据时报错，还有记得在main.js的错误拦截处，发生错误时</li></ul><pre><code>    return Promise.reject()   //发生错误，promise返回拒绝值</code></pre><h3 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h3><ul><li>这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。</li></ul><pre><code>    {      // `url` 是用于请求的服务器 URL      url: &#39;/user&#39;,      // `method` 是创建请求时使用的方法      method: &#39;get&#39;, // 默认是 get      // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。      // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL      baseURL: &#39;https://some-domain.com/api/&#39;,      // `transformRequest` 允许在向服务器发送前，修改请求数据      // 只能用在 &#39;PUT&#39;, &#39;POST&#39; 和 &#39;PATCH&#39; 这几个请求方法      // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream      transformRequest: [function (data) {        // 对 data 进行任意转换处理        return data;      }],      // `transformResponse` 在传递给 then/catch 前，允许修改响应数据      transformResponse: [function (data) {        // 对 data 进行任意转换处理        return data;      }],      // `headers` 是即将被发送的自定义请求头      headers: {&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;},      // `params` 是即将与请求一起发送的 URL 参数      // 必须是一个无格式对象(plain object)或 URLSearchParams 对象      params: {        ID: 12345      },      // `paramsSerializer` 是一个负责 `params` 序列化的函数      // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)      paramsSerializer: function(params) {        return Qs.stringify(params, {arrayFormat: &#39;brackets&#39;})      },      // `data` 是作为请求主体被发送的数据      // 只适用于这些请求方法 &#39;PUT&#39;, &#39;POST&#39;, 和 &#39;PATCH&#39;      // 在没有设置 `transformRequest` 时，必须是以下类型之一：      // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams      // - 浏览器专属：FormData, File, Blob      // - Node 专属： Stream      data: {        firstName: &#39;Fred&#39;      },      // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)      // 如果请求超过 `timeout` 的时间，请求将被中断      timeout: 1000,      // `withCredentials` 表示跨域请求时是否需要使用凭证      withCredentials: false, // 默认的      // `adapter` 允许自定义处理请求，以使测试更轻松      // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).      adapter: function (config) {        /* ... */      },      // `auth` 表示应该使用 HTTP 基础验证，并提供凭据      // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头      auth: {        username: &#39;janedoe&#39;,        password: &#39;s00pers3cret&#39;      },      // `responseType` 表示服务器响应的数据类型，可以是 &#39;arraybuffer&#39;, &#39;blob&#39;, &#39;document&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39;      responseType: &#39;json&#39;, // 默认的      // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称      xsrfCookieName: &#39;XSRF-TOKEN&#39;, // default      // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称      xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;, // 默认的      // `onUploadProgress` 允许为上传处理进度事件      onUploadProgress: function (progressEvent) {        // 对原生进度事件的处理      },      // `onDownloadProgress` 允许为下载处理进度事件      onDownloadProgress: function (progressEvent) {        // 对原生进度事件的处理      },      // `maxContentLength` 定义允许的响应内容的最大尺寸      maxContentLength: 2000,      // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte      validateStatus: function (status) {        return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的      },      // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目      // 如果设置为0，将不会 follow 任何重定向      maxRedirects: 5, // 默认的      // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：      // `keepAlive` 默认没有启用      httpAgent: new http.Agent({ keepAlive: true }),      httpsAgent: new https.Agent({ keepAlive: true }),      // &#39;proxy&#39; 定义代理服务器的主机名称和端口      // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据      // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。      proxy: {        host: &#39;127.0.0.1&#39;,        port: 9000,        auth: : {          username: &#39;mikeymike&#39;,          password: &#39;rapunz3l&#39;        }      },      // `cancelToken` 指定用于取消请求的 cancel token      // （查看后面的 Cancellation 这节了解更多）      cancelToken: new CancelToken(function (cancel) {      })    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的引入和具体使用方法，还有服务器部署</title>
      <link href="/2020/06/12/redis/"/>
      <url>/2020/06/12/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这些都是redis的具体使用方法</li></ul><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ul><li>我们使用购物车的时候需要用到redis</li><li>这里我们用的是redis5</li></ul><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre><code>    &lt;!--        redis--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code>    spring:        redis:            host: localhost            port: 6379</code></pre><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>在方法里注入StringRedisTemplate</li></ul><pre><code>    @Autowired    private StringRedisTemplate stringRedisTemplate;</code></pre><ul><li>操作</li></ul><pre><code>    redisTemplate.opsForValue();　　//操作字符串    redisTemplate.opsForHash();　　 //操作hash    redisTemplate.opsForList();　　 //操作list    redisTemplate.opsForSet();　　  //操作set    redisTemplate.opsForZSet();　 　//操作有序set</code></pre><h3 id="StringRedisTemplate与RedisTemplate的区别"><a href="#StringRedisTemplate与RedisTemplate的区别" class="headerlink" title="StringRedisTemplate与RedisTemplate的区别"></a>StringRedisTemplate与RedisTemplate的区别</h3><ul><li>两者的关系是StringRedisTemplate继承RedisTemplate。</li><li>两者的数据是不共通的；也就是说StringRedisTemplate只能管理StringRedisTemplate里面的数据</li><li>RedisTemplate只能管RedisTemplate中的数据。</li><li>SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。</li><li>StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。</li><li>RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。</li></ul><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><ul><li>这里暂时只用到了opsForHash(操作hashmap)，更多操作方法在下面</li></ul><pre><code>    //获取对象，注意这里设置全是String类型的    HashOperations&lt;String, String, String&gt; opsForHash = stringRedisTemplate.opsForHash();    //遍历redis    private List&lt;Cart&gt; listForCart(Integer uid) {            HashOperations&lt;String, String, String&gt; opsForHash = stringRedisTemplate.opsForHash();            //redisKey            String redisKey = String.format(CART_REDIS_KEY_TEMPLATE, uid);            //获取所有键值对            Map&lt;String, String&gt; entries = opsForHash.entries(redisKey);            List&lt;Cart&gt; cartList = new ArrayList&lt;&gt;();            //遍历            for (Map.Entry&lt;String, String&gt; entry : entries.entrySet()) {                //获取值                String value = entry.getValue();                //返回的value是json格式的String类型，需要用Gson转换成Cart对象类型                cartList.add(gson.fromJson(value, Cart.class));            }            return cartList;        }    //put设置或者修改值，注意要数据类型全部转换为String类型    opsForHash.put(redisKey, String.valueOf(cart.getProductId()), gson.toJson(cart));    //delete删除值    opsForHash.delete(redisKey, hashKey);    //获取值        //获取一条值        String value = opsForHash.get(redisKey, hashKey);        //获取所有键值对        Map&lt;String, String&gt; entries = opsForHash.entries(redisKey);</code></pre><h4 id="opsForValue-操作字符串"><a href="#opsForValue-操作字符串" class="headerlink" title="opsForValue(操作字符串)"></a>opsForValue(操作字符串)</h4><pre><code>/** * @author lhz **/public class RedisString {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 新增一个字符串类型的值,key是键，value是值。 * * set(K key, V value) */public void set() {    // 存入永久数据    stringRedisTemplate.opsForValue().set(&quot;test2&quot;, &quot;1&quot;);    // 也可以向redis里存入数据和设置缓存时间    stringRedisTemplate.opsForValue().set(&quot;test1&quot;, &quot;hello redis&quot;, 1000, TimeUnit.SECONDS);}/** * 批量插入，key值存在会覆盖原值 * * multiSet(Map&lt;? extends K,? extends V&gt; map) */public void multiSet() {    Map&lt;String,String&gt; map = new HashMap&lt;&gt;(16);    map.put(&quot;testMultiSet1&quot;, &quot;value0&quot;);    map.put(&quot;testMultiSet2&quot;, &quot;value2&quot;);    stringRedisTemplate.opsForValue().multiSet(map);}/** *  批量插入，如果里面的所有key都不存在，则全部插入，返回true，如果其中一个在redis中已存在，全不插入，返回false * *  multiSetIfAbsent(Map&lt;? extends K,? extends V&gt; map) */public void multiSetIfAbsent() {    Map&lt;String,String&gt; map = new HashMap&lt;&gt;(16);    map.put(&quot;testMultiSet4&quot;, &quot;value1&quot;);    map.put(&quot;testMultiSet3&quot;, &quot;value3&quot;);    Boolean absent = stringRedisTemplate.opsForValue().multiSetIfAbsent(map);    System.out.println(absent);}/** * 如果不存在则插入，返回true为插入成功,false失败 * * setIfAbsent(K key, V value) */public void setIfAbsent() {    Boolean absent = stringRedisTemplate.opsForValue().setIfAbsent(&quot;test&quot;, &quot;hello redis&quot;);    System.out.println(absent);}/** * 获取值,key不存在返回null * * get(Object key) */public void get() {    System.out.println(stringRedisTemplate.opsForValue().get(&quot;testMultiSet1&quot;));}/** * 批量获取，key不存在返回null * * multiGet(Collection&lt;K&gt; keys) */public void multiGet() {    List&lt;String&gt; list = stringRedisTemplate.opsForValue().multiGet(Arrays.asList(&quot;test&quot;, &quot;test2&quot;));    assert list != null;    System.out.println(list.toString());}/** * 获取指定字符串的长度。 * * size(K key) */public void getLength() {    Long size = stringRedisTemplate.opsForValue().size(&quot;test&quot;);    System.out.println(size);}/** * 在原有的值基础上新增字符串到末尾。 * * append(K key, String value) */public void append() {    Integer append = stringRedisTemplate.opsForValue().append(&quot;test3&quot;, &quot;database&quot;);    System.out.println(append);}/** * 获取原来key键对应的值并重新赋新值 * * getAndSet(K key, V value) */public void getAndSet() {    String set = stringRedisTemplate.opsForValue().getAndSet(&quot;test&quot;, &quot;set test&quot;);    System.out.println(set);}/** * 获取指定key的值进行减1，如果value不是integer类型，会抛异常，如果key不存在会创建一个，默认value为0 * * decrement(k key) */public void decrement() {    stringRedisTemplate.opsForValue().decrement(&quot;test2&quot;);    stringRedisTemplate.opsForValue().decrement(&quot;test1&quot;);}/** * 获取指定key的值进行加1，如果value不是integer类型，会抛异常，如果key不存在会创建一个，默认value为0 *  * increment(k key) */public void increment() {    stringRedisTemplate.opsForValue().increment(&quot;test2&quot;);    stringRedisTemplate.opsForValue().increment(&quot;test1&quot;);}/** * 删除指定key,成功返回true，否则false *  * delete(k key) */public void delete() {    Boolean delete = stringRedisTemplate.opsForValue().getOperations().delete(&quot;test1&quot;);    System.out.println(delete);}/** * 删除多个key，返回删除key的个数 *  * delete(k ...keys) */public void deleteMulti() {    Long delete = stringRedisTemplate.opsForValue().getOperations().delete(Arrays.asList(&quot;test1&quot;, &quot;test2&quot;));    System.out.println(delete);}}</code></pre><h4 id="opsForList-操作集合"><a href="#opsForList-操作集合" class="headerlink" title="opsForList(操作集合)"></a>opsForList(操作集合)</h4><pre><code>public class RedisList {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 在变量左边添加元素值。如果key不存在会新建，添加成功返回添加后的总个数 *  * leftPush(K key, V value) */public void leftPush() {    Long aLong = stringRedisTemplate.opsForList().leftPush(&quot;list&quot;, &quot;a&quot;);    System.out.println(aLong);}/** * 向左边批量添加参数元素，如果key不存在会新建，添加成功返回添加后的总个数 *  * leftPushAll(K key, V... values) */public void leftPushAll() {    Long pushAll = stringRedisTemplate.opsForList().leftPushAll(&quot;list&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);    System.out.println(pushAll);}/** * 向集合最右边添加元素。如果key不存在会新建，添加成功返回添加后的总个数 *  * rightPush(K key, V value) */public void rightPush() {    Long aLong = stringRedisTemplate.opsForList().rightPush(&quot;list2&quot;, &quot;a&quot;);    System.out.println(aLong);}/** * 如果存在集合则添加元素。 *  * leftPushIfPresent(K key, V value) */public void leftPushIfPresent() {    Long aLong = stringRedisTemplate.opsForList().leftPushIfPresent(&quot;list&quot;, &quot;h&quot;);    System.out.println(aLong);}/** * 向右边批量添加元素。返回当前集合元素总个数 *  * rightPushAll(K key, V... values) */public void rightPushAll() {    Long aLong = stringRedisTemplate.opsForList().rightPushAll(&quot;list2&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);    System.out.println(aLong);}/** * 向已存在的集合中添加元素。返回集合总元素个数 *  * rightPushIfPresent(K key, V value) */public void rightPushIfPresent() {    Long aLong = stringRedisTemplate.opsForList().rightPushIfPresent(&quot;list&quot;, &quot;e&quot;);    System.out.println(aLong);}/** * 获取集合长度 *  * size(K key) */public void size() {    Long size = stringRedisTemplate.opsForList().size(&quot;list2&quot;);    System.out.println(size);}/** * 移除集合中的左边第一个元素。返回删除的元素，如果元素为空，该集合会自动删除 *  * leftPop(K key) */public void leftPop() {    String pop = stringRedisTemplate.opsForList().leftPop(&quot;list2&quot;);    System.out.println(pop);}/** * 移除集合中左边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。 *  * leftPop(K key, long timeout, TimeUnit unit) */public void leftPopWait() {    String pop = stringRedisTemplate.opsForList().leftPop(&quot;list2&quot;, 10, TimeUnit.SECONDS);    System.out.println(pop);}/** * 移除集合中右边的元素。返回删除的元素，如果元素为空，该集合会自动删除 *  * rightPop(K key) */public void rightPop() {    String pop = stringRedisTemplate.opsForList().rightPop(&quot;list2&quot;);    System.out.println(pop);}/** * 移除集合中右边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。 *  * rightPop(K key, long timeout, TimeUnit unit) */public void rightPopWait() {    String pop = stringRedisTemplate.opsForList().rightPop(&quot;list2&quot;, 10, TimeUnit.SECONDS);    System.out.println(pop);}/** * 移除第一个集合右边的一个元素，插入第二个集合左边插入这个元素 *  * rightPopAndLeftPush(K sourceKey, K destinationKey) */public void rightPopAndLeftPush() {    String s = stringRedisTemplate.opsForList().rightPopAndLeftPush(&quot;list2&quot;, &quot;list3&quot;);    System.out.println(s);}/** * 在集合的指定位置插入元素,如果指定位置已有元素，则覆盖，没有则新增，超过集合下标+n则会报错。 *  * set(K key, long index, V value) */public void set() {    stringRedisTemplate.opsForList().set(&quot;list2&quot;, 2, &quot;w&quot;);}/** * 从存储在键中的列表中删除等于值的元素的第一个计数事件。count&gt; 0：删除等于从左到右移动的值的第一个元素； * count&lt; 0：删除等于从右到左移动的值的第一个元素；count = 0：删除等于value的所有元素 *  * remove(K key, long count, Object value) */public void remove() {    Long remove = stringRedisTemplate.opsForList().remove(&quot;list2&quot;, 2, &quot;w&quot;);    System.out.println(remove);}/** * 截取集合元素长度，保留长度内的数据。 *  * trim(K key, long start, long end) */public void trim() {    stringRedisTemplate.opsForList().trim(&quot;list2&quot;, 0, 3);}/** * 获取集合指定位置的值。 *  * index(K key, long index) */public void index() {    Object listValue = stringRedisTemplate.opsForList().index(&quot;list2&quot;, 3);    System.out.println(listValue);}/** * 获取指定区间的值。 *  * range(K key, long start, long end) */public void range() {    List&lt;String&gt; list = stringRedisTemplate.opsForList().range(&quot;list&quot;, 0, -1);    System.out.println(list);}/** * 删除指定集合,返回true删除成功 *  * delete(K key) */public void delete() {    Boolean delete = stringRedisTemplate.opsForList().getOperations().delete(&quot;list2&quot;);    System.out.println(delete);}}</code></pre><h4 id="opsForHash-操作hashMap"><a href="#opsForHash-操作hashMap" class="headerlink" title="opsForHash(操作hashMap)"></a>opsForHash(操作hashMap)</h4><pre><code>public class RedisHash {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 新增hashMap值 *  * put(H key, HK hashKey, HV value) */public void put() {    stringRedisTemplate.opsForHash().put(&quot;hash&quot;,&quot;hash-key&quot;,&quot;hash-value&quot;);    stringRedisTemplate.opsForHash().put(&quot;hash&quot;,&quot;hash-key2&quot;,&quot;hash-value2&quot;);}/** * 以map集合的形式添加键值对 *  * putAll(H key, Map&lt;? extends HK,? extends HV&gt; m) */public void putAll() {    Map&lt;String, String&gt; map = new HashMap&lt;&gt;(16);    map.put(&quot;hash-key3&quot;, &quot;value3&quot;);    map.put(&quot;hash-key4&quot;, &quot;value4&quot;);    stringRedisTemplate.opsForHash().putAll(&quot;hash&quot;, map);}/** * 如果变量值存在，在变量中可以添加不存在的的键值对，如果变量不存在，则新增一个变量，同时将键值对添加到该变量。添加成功返回true否则返回false *  * putIfAbsent(H key, HK hashKey, HV value) */public void putIfAbsent() {    Boolean absent = stringRedisTemplate.opsForHash().putIfAbsent(&quot;hash&quot;, &quot;hash-key&quot;, &quot;value1&quot;);    Boolean absent2 = stringRedisTemplate.opsForHash().putIfAbsent(&quot;hash&quot;, &quot;hash-key5&quot;, &quot;value5&quot;);    System.out.println(absent);    System.out.println(absent2);}/** * 获取指定变量中的hashMap值。 *  * values(H Key) */public void values() {    List&lt;Object&gt; values = stringRedisTemplate.opsForHash().values(&quot;hash2&quot;);    System.out.println(values.toString());}/** * 获取变量中的键值对。 *  * entries(H key) */public void entries() {    Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(&quot;hash&quot;);    System.out.println(entries.toString());}/** * 获取变量中的指定map键是否有值,如果存在该map键则获取值，没有则返回null。 *  * get(H key, Object hashKey) */public void get() {    Object value = stringRedisTemplate.opsForHash().get(&quot;hash&quot;, &quot;hash-key&quot;);    System.out.println(value);}/** * 获取变量中的键。 *  * keys(H key) */public void keys() {    Set&lt;Object&gt; keys = stringRedisTemplate.opsForHash().keys(&quot;hash&quot;);    System.out.println(keys.toString());}/** *  获取变量的长度 *   *  size(H key) */public void size() {    Long size = stringRedisTemplate.opsForHash().size(&quot;hash&quot;);    System.out.println(size);}/** * 使变量中的键以long值的大小进行自增长。值必须为Integer类型,否则异常 *  * increment(H key, HK hashKey, long data) */public void increment() {    Long increment = stringRedisTemplate.opsForHash().increment(&quot;hash&quot;, &quot;hash-key2&quot;, 1);    System.out.println(increment);}/** * 以集合的方式获取变量中的值。 *  * multiGet(H key, Collection&lt;HK&gt; hashKeys) */public void multiGet() {    List&lt;Object&gt; values = stringRedisTemplate.opsForHash().multiGet(&quot;hash&quot;, Arrays.asList(&quot;hash-key&quot;, &quot;hash-key2&quot;));    System.out.println(values.toString());}/** * 匹配获取键值对，ScanOptions.NONE为获取全部键对，ScanOptions.scanOptions().match(&quot;hash-key2&quot;).build()匹配获取键位map1的键值对,不能模糊匹配。 *  * scan(H key, ScanOptions options) */public void scan() {    Cursor&lt;Map.Entry&lt;Object, Object&gt;&gt; scan = stringRedisTemplate.opsForHash().scan(&quot;hash&quot;, ScanOptions.NONE);    while (scan.hasNext()) {        Map.Entry&lt;Object, Object&gt; next = scan.next();        System.out.println(next.getKey() + &quot;----&gt;&quot; + next.getValue());    }}/** * 删除变量中的键值对，可以传入多个参数，删除多个键值对。返回删除成功数量 *  * delete(H key, Object... hashKeys) */public void delete() {    Long delete = stringRedisTemplate.opsForHash().delete(&quot;hash&quot;, &quot;hash-key&quot;, &quot;hash-key1&quot;);    System.out.println(delete);}}</code></pre><h4 id="opsForSet-操作有序set集合"><a href="#opsForSet-操作有序set集合" class="headerlink" title="opsForSet(操作有序set集合)"></a>opsForSet(操作有序set集合)</h4><pre><code>public class RedisSet {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 向变量中批量添加值。返回添加的数量 * * add(K key, V... values) */public void add() {    Long add = stringRedisTemplate.opsForSet().add(&quot;set&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);    System.out.println(add);}/** * 获取变量的值 * * members(K key) */public void members() {    Set&lt;String&gt; set = stringRedisTemplate.opsForSet().members(&quot;set&quot;);    System.out.println(set);}/** * 获取变量中值得长度 * * size(k key) */public void size() {    Long size = stringRedisTemplate.opsForSet().size(&quot;set&quot;);    System.out.println(size);}/** * 随机获取变量中的某个元素 * * randomMember(k key) */public void randomMember() {    String member = stringRedisTemplate.opsForSet().randomMember(&quot;set&quot;);    System.out.println(member);}/** * 随机获取变量中指定个数的元素 * * randomMembers(k key, long count) */public void randomMembers() {    List&lt;String&gt; members = stringRedisTemplate.opsForSet().randomMembers(&quot;set&quot;, 2);    System.out.println(members);}/** * 检查给定的元素是否在变量中,true为存在 * * isMember(k key, object value) */public void isMember() {    Boolean member = stringRedisTemplate.opsForSet().isMember(&quot;set&quot;, &quot;b&quot;);    System.out.println(member);}/** * 转义变量的元素值到另一个变量中 * * move(k key, v value, k targetKey) */public void move() {    Boolean move = stringRedisTemplate.opsForSet().move(&quot;set&quot;, &quot;b&quot;, &quot;set2&quot;);    System.out.println(move);}/** * 弹出变量中的元素。当元素全部弹完,变量也会删除 * * pop(k key) */public void pop() {    String pop = stringRedisTemplate.opsForSet().pop(&quot;set&quot;);    System.out.println(pop);}/** * 批量删除变量中的元素,返回删除的数量 * * remove(k key, v ...values) */public void remove() {    Long remove = stringRedisTemplate.opsForSet().remove(&quot;set2&quot;, &quot;b&quot;);    System.out.println(remove);}/** * 匹配获取键值对，ScanOptions.NONE为获取全部键值对；ScanOptions.scanOptions().match(&quot;C&quot;).build()匹配获取键位map1的键值对,不能模糊匹配。 * * scan(K key, ScanOptions options) */public void scan() {    Cursor&lt;String&gt; set = stringRedisTemplate.opsForSet().scan(&quot;set&quot;, ScanOptions.NONE);    while (set.hasNext()) {        String next = set.next();        System.out.println(next);    }}/** * 通过集合求差值。 * * difference(k key, k otherKey) */public void difference() {    Set&lt;String&gt; difference = stringRedisTemplate.opsForSet().difference(&quot;set&quot;, &quot;set2&quot;);    System.out.println(difference);}/** * 将求出来的差值元素保存 * * differenceAndStore(K key, K otherKey, K targetKey) */public void differenceAndStore() {    Long aLong = stringRedisTemplate.opsForSet().differenceAndStore(&quot;set&quot;, &quot;set2&quot;, &quot;set3&quot;);    System.out.println(aLong);}/** * 获取去重的随机元素 * * distinctRandomMembers(K key, long count) */public void distinctRandomMembers() {    Set&lt;String&gt; set = stringRedisTemplate.opsForSet().distinctRandomMembers(&quot;set&quot;, 2);    System.out.println(set);}/** * 获取两个变量中的交集 * * intersect(K key, K otherKey) */public void intersect() {    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(&quot;set&quot;, &quot;set2&quot;);    System.out.println(intersect);}/** * 获取2个变量交集后保存到最后一个变量上。 * * intersectAndStore(K key, K otherKey, K targetKey) */public void intersectAndStore() {    Long aLong = stringRedisTemplate.opsForSet().intersectAndStore(&quot;set&quot;, &quot;set2&quot;, &quot;set3&quot;);    System.out.println(aLong);}/** * 获取两个变量的合集 * * union(K key, K otherKey) */public void union() {    Set&lt;String&gt; union = stringRedisTemplate.opsForSet().union(&quot;set&quot;, &quot;set2&quot;);    System.out.println(union);}/** * 获取两个变量合集后保存到另一个变量中 * * unionAndStore(K key, K otherKey, K targetKey) */public void unionAndStore() {    Long aLong = stringRedisTemplate.opsForSet().unionAndStore(&quot;set&quot;, &quot;set2&quot;, &quot;set3&quot;);    System.out.println(aLong);}}</code></pre><h4 id="opsForZset（操作有序set集合）"><a href="#opsForZset（操作有序set集合）" class="headerlink" title="opsForZset（操作有序set集合）"></a>opsForZset（操作有序set集合）</h4><pre><code>public class RedisZSet {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 添加元素到变量中同时指定元素的分值。 * * add(K key, V value, double score) */public void add() {    Boolean add = stringRedisTemplate.opsForZSet().add(&quot;zset&quot;, &quot;a&quot;, 1);    System.out.println(add);}/** * 通过TypedTuple方式新增数据。 * * add(K key, Set&lt;ZSetOperations.TypedTuple&lt;V&gt;&gt; tuples) */public void addByTypedTuple() {    ZSetOperations.TypedTuple&lt;String&gt; typedTuple1 = new DefaultTypedTuple&lt;&gt;(&quot;E&quot;, 2.0);    ZSetOperations.TypedTuple&lt;String&gt; typedTuple2 = new DefaultTypedTuple&lt;&gt;(&quot;F&quot;, 3.0);    ZSetOperations.TypedTuple&lt;String&gt; typedTuple3 = new DefaultTypedTuple&lt;&gt;(&quot;G&quot;, 5.0);    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTupleSet = new HashSet&lt;&gt;();    typedTupleSet.add(typedTuple1);    typedTupleSet.add(typedTuple2);    typedTupleSet.add(typedTuple3);    Long zset = stringRedisTemplate.opsForZSet().add(&quot;zset&quot;, typedTupleSet);    System.out.println(zset);}/** * 获取指定区间的元素 * * range(k key, long start, long end) */public void range() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().range(&quot;zset&quot;, 0, -1);    System.out.println(zset);}/** * 用于获取满足非score的排序取值。这个排序只有在有相同分数的情况下才能使用，如果有不同的分数则返回值不确定。 * * rangeByLex(K key, RedisZSetCommands.Range range) */public void rangeByLex() {    Set&lt;String&gt; rangeByLex = stringRedisTemplate.opsForZSet().rangeByLex(&quot;zset&quot;, RedisZSetCommands.Range.range().lt(&quot;E&quot;));    System.out.println(rangeByLex);}/** * 用于获取满足非score的设置下标开始的长度排序取值。 * * rangeByLex(k key, range range, limit limit) */public void rangeByLexAndLimit() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().rangeByLex(&quot;zset&quot;, RedisZSetCommands.Range.range().lt(&quot;E&quot;),            RedisZSetCommands.Limit.limit().offset(1).count(2));    System.out.println(zset);}/** * 根据设置的score获取区间值。 * * rangeByScore(K key, double min, double max) */public void rangeByScore() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().rangeByScore(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 获取RedisZSetCommands.Tuples的区间值。 * * rangeWithScores(K key, long start, long end) */public void rangeWithScores() {    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zset = stringRedisTemplate.opsForZSet().rangeWithScores(&quot;zset&quot;, 1, 3);    assert zset != null;    for (ZSetOperations.TypedTuple&lt;String&gt; next : zset) {        String value = next.getValue();        Double score = next.getScore();        System.out.println(value + &quot;--&gt;&quot; + score);    }}/** * 获取区间值的个数。 * * count(k key, double min, double max) */public void count() {    Long zset = stringRedisTemplate.opsForZSet().count(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 获取变量中指定元素的索引,下标开始为0 * * rank(k key, object o) */public void rank() {    Long rank = stringRedisTemplate.opsForZSet().rank(&quot;zset&quot;, &quot;a&quot;);    System.out.println(rank);}/** * 匹配获取键值对，ScanOptions.NONE为获取全部键值对；ScanOptions.scanOptions().match(&quot;C&quot;).build()匹配获取键位map1的键值对,不能模糊匹配。 * * scan(K key, ScanOptions options) */public void scan() {    Cursor&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zset = stringRedisTemplate.opsForZSet().scan(&quot;zset&quot;, ScanOptions.NONE);    while (zset.hasNext()) {        ZSetOperations.TypedTuple&lt;String&gt; next = zset.next();        System.out.println(next.getValue() + &quot;--&gt;&quot; + next.getScore());    }}/** * 获取指定元素的分值 * * score(k key, object o) */public void score() {    Double score = stringRedisTemplate.opsForZSet().score(&quot;zset&quot;, &quot;a&quot;);    System.out.println(score);}/** * 获取变量中元素的个数 * * zCard(k key) */public void zCard() {    Long zset = stringRedisTemplate.opsForZSet().zCard(&quot;zset&quot;);    System.out.println(zset);}/** * 修改变量中元素的分值 * * incrementScore(K key, V value, double delta) */public void incrementScore() {    Double score = stringRedisTemplate.opsForZSet().incrementScore(&quot;zset&quot;, &quot;a&quot;, 2);    System.out.println(score);}/** * 索引倒序排列指定区间的元素 * * reverseRange(K key, long start, long end) */public void reverseRange() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().reverseRange(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 倒序排列指定分值区间的元素 * * reverseRangeByScore(K key, double min, double max) */public void reverseRangeByScore() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().reverseRangeByScore(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 倒序排序获取RedisZSetCommands.Tuples的分值区间值 * * reverseRangeByScore(K key, double min, double max, long offset, long count) */public void reverseRangeByScoreLength() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().reverseRangeByScore(&quot;zset&quot;, 1, 3, 1, 2);    System.out.println(zset);}/** * 倒序排序获取RedisZSetCommands.Tuples的分值区间值。 * * reverseRangeByScoreWithScores(K key, double min, double max) */public void reverseRangeByScoreWithScores() {    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zset = stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(&quot;zset&quot;, 1, 5);    assert zset != null;    zset.iterator().forEachRemaining(e-&gt; System.out.println(e.getValue() + &quot;---&gt;&quot; + e.getScore()));}/** * 获取倒序排列的索引值 * * reverseRank(k key, object o) */public void reverseRank() {    Long aLong = stringRedisTemplate.opsForZSet().reverseRank(&quot;zset&quot;, &quot;a&quot;);    System.out.println(aLong);}/** * 获取2个变量的交集存放到第3个变量里面。 * * intersectAndStore(K key, K otherKey, K destKey) */public void intersectAndStore() {    Long aLong = stringRedisTemplate.opsForZSet().intersectAndStore(&quot;zset&quot;, &quot;zset2&quot;, &quot;zset3&quot;);    System.out.println(aLong);}/** * 获取2个变量的合集存放到第3个变量里面。 返回操作的数量 * * unionAndStore(K key, K otherKey, K destKey) */public void unionAndStore() {    Long aLong = stringRedisTemplate.opsForZSet().unionAndStore(&quot;zset&quot;, &quot;zset2&quot;, &quot;zset3&quot;);    System.out.println(aLong);}/** * 批量移除元素根据元素值。返回删除的元素数量 * * remove(K key, Object... values) */public void remove() {    Long remove = stringRedisTemplate.opsForZSet().remove(&quot;zset&quot;, &quot;a&quot;, &quot;b&quot;);    System.out.println(remove);}/** * 根据分值移除区间元素。返回删除的数量 * * removeRangeByScore(k key, double min, double max) */public void removeRangeByScore() {    Long zset = stringRedisTemplate.opsForZSet().removeRangeByScore(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 根据索引值移除区间元素。返回移除的元素集合 * * removeRange(K key, long start, long end) */public void removeRange() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().reverseRange(&quot;zset&quot;, 0, 4);    System.out.println(zset);}}</code></pre><h3 id="阿里云服务器上部署redis-centos7-7"><a href="#阿里云服务器上部署redis-centos7-7" class="headerlink" title="阿里云服务器上部署redis(centos7.7)"></a>阿里云服务器上部署redis(centos7.7)</h3><ul><li>下载包</li></ul><pre><code>    wget wget http://download.redis.io/releases/redis-5.0.8.tar.gz</code></pre><ul><li>解压到指定路径</li></ul><pre><code>    tar -zxvf redis-5.0.8.tar.gz -C /usr/local</code></pre><ul><li>编译</li></ul><pre><code>    cd /usr/local/redis-5.0.8    make</code></pre><ul><li>编译成功将会出现</li></ul><pre><code>    Hint: It&#39;s a good idea to run &#39;make test&#39; 😉    make[1]: Leaving directory `/usr/local/redis-5.0.8/src&#39;</code></pre><ul><li>然后执行下面命令</li></ul><pre><code>    cd /usr/local/redis-5.0.8/src    make install</code></pre><ul><li>成功</li></ul><pre><code>    Hint: It&#39;s a good idea to run &#39;make test&#39; 😉    INSTALL install    INSTALL install    INSTALL install    INSTALL install    INSTALL install</code></pre><ul><li>修改配置文件</li></ul><pre><code>    vim /usr/local/redis-5.0.8/redis.conf    protected-mode no # 关闭保护模式    daemonize yes     # 守护进程模式开启    bind 127.0.0.1  注释掉，不然远程连接不上</code></pre><ul><li>千万记住修改完配置文件后要重启，不然不会生效！！！踩了好大的坑</li></ul><pre><code>    //以下命令一起输入    /usr/local/redis-5.0.8/src/redis-server &amp;    /usr/local/redis-5.0.8/redis.conf</code></pre><ul><li>启动服务端和客户端</li></ul><pre><code>    /usr/local/redis-5.0.8/src/redis-server    /usr/local/redis-5.0.8/src/redis-cli</code></pre><ul><li>后台启动服务端</li></ul><pre><code>    /usr/local/redis-5.0.8/src/redis-server &amp;</code></pre><ul><li>查看redis进程</li></ul><pre><code>    ps -ef | grep redis</code></pre><ul><li>密码登录客户端</li></ul><pre><code>    cd /usr/local/redis-5.0.8/src    ./redis-cli -h 127.0.0.1 -p 6379 -a 980508</code></pre><ul><li>然后就用redis可视化工具测试远程连接，记住要用密码连接</li></ul>]]></content>
      
      
      <categories>
          
          <category> nosql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router路由</title>
      <link href="/2020/06/05/vue-router/"/>
      <url>/2020/06/05/vue-router/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌，对于一个vue开发的spa单页面而言，路由的重要性不言而喻</p><h2 id="vue-router是什么"><a href="#vue-router是什么" class="headerlink" title="vue-router是什么"></a>vue-router是什么</h2><ul><li>这里的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。再通俗的说，vue-router就是WebApp的链接路径管理系统。<br>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。</li><li>至于我们为啥不能用a标签，这是因为用Vue做的都是单页应用（当你的项目准备打包时，运行npm run build时，就会生成dist文件夹，这里面只有静态资源和一个index.html页面），所以你写的<a></a>标签是不起作用的，你必须使用vue-router来进行管理。</li></ul><h2 id="vue-router使用方式"><a href="#vue-router使用方式" class="headerlink" title="vue-router使用方式"></a>vue-router使用方式</h2><ul><li>下载 </li></ul><pre><code>    npm i vue-router --save</code></pre><ul><li>创建router.js文件</li></ul><pre><code>import Router from &#39;vue-router&#39; //导入插件Vue.use(Router);    //安装插件</code></pre><ul><li>创建路由对象并配置路由规则 let router = new VueRouter({routes:[{path:’/home’,component:Home}]});</li></ul><pre><code>    export default new Router({        routes: [    //配置路由，这里是个数组            {       //每一个链接都是一个对象                path: &#39;/&#39;,  //链接路径                name: &#39;home&#39;,   //路由名称                redirect: &#39;/index&#39;,     //重定向                component: Home,    //对应的组件模板                children: [        //子路由                {                    path: &#39;product/:id&#39;,    // /:id表示动态路由 动态传id                    name: &#39;product&#39;,                    component: Product,                },                ]            },        ]    })</code></pre><ul><li>动态路由的取值：this.$route.params.id</li><li>在main.js中引入 router.js</li><li>将其路由对象传递给main.js中Vue的实例，options中加入 router:router</li><li>在app.vue中留坑 <router-view></router-view></li></ul><pre><code>    //app.vue中    &lt;template&gt;        &lt;div&gt;            &lt;!-- 留坑，非常重要 --&gt;            &lt;router-view&gt;&lt;/router-view&gt;        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default {            data(){                return {}            }        }    &lt;/script&gt;</code></pre><h2 id="使用路由模块来实现页面跳转的方式"><a href="#使用路由模块来实现页面跳转的方式" class="headerlink" title="使用路由模块来实现页面跳转的方式"></a>使用路由模块来实现页面跳转的方式</h2><ul><li>1：直接修改地址栏</li><li>2：this.$router.push(‘路由地址’)</li><li>3：<router-link to="路由地址"></router-link></li></ul><h3 id="路由携带参数跳转页面"><a href="#路由携带参数跳转页面" class="headerlink" title="路由携带参数跳转页面"></a>路由携带参数跳转页面</h3><h4 id="使用Query实现路由传参（url中显示参数）"><a href="#使用Query实现路由传参（url中显示参数）" class="headerlink" title="使用Query实现路由传参（url中显示参数）"></a>使用Query实现路由传参（url中显示参数）</h4><pre><code>    //携带参数跳转到订单支付页面    this.$router.push({      path:&#39;/order/pay&#39;,    //路由路径      query:{        orderNo : res.orderNo   //携带参数      }    })</code></pre><ul><li>跳转过去url是携带参数的</li></ul><pre><code>    http://localhost:8080/#/order/pay?orderNo=1589864016971</code></pre><ul><li>获取参数</li></ul><pre><code>    this.$route.query.orderNo</code></pre><h3 id="params传参（url中不显示参数）"><a href="#params传参（url中不显示参数）" class="headerlink" title="params传参（url中不显示参数）"></a>params传参（url中不显示参数）</h3><ul><li>注意：上述这种利用params不显示url传参的方式会导致在刷新页面的时候，传递的值会丢失,这个可以用来判断是从哪个页面跳转过来</li></ul><pre><code>    this.$router.push({        name: &#39;index&#39;,        params:{          from: &#39;login&#39;        }      });</code></pre><ul><li>获取参数</li></ul><pre><code>    this.$route.params.from</code></pre><ul><li>判断</li></ul><pre><code>    //只有从登陆页面跳转过来的时候才会获取购物车数量    if (this.$route.params.from &amp;&amp; this.$route.params.from == &#39;login&#39;) {        this.getCartCount();    }</code></pre><h2 id="路由懒加载vue-router"><a href="#路由懒加载vue-router" class="headerlink" title="路由懒加载vue-router"></a>路由懒加载vue-router</h2><h3 id="什么是懒加载？"><a href="#什么是懒加载？" class="headerlink" title="什么是懒加载？"></a>什么是懒加载？</h3><ul><li>懒加载也就是延迟加载或者按需加载，即在需要的时候进行加载。</li></ul><h3 id="为什么在Vue路由中使用懒加载？"><a href="#为什么在Vue路由中使用懒加载？" class="headerlink" title="为什么在Vue路由中使用懒加载？"></a>为什么在Vue路由中使用懒加载？</h3><ul><li>像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，时间过长，会出啊先长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时；</li><li>简单的说就是：进入首页不用一次加载过多资源造成用时过长；</li></ul><h3 id="如何实现懒加载"><a href="#如何实现懒加载" class="headerlink" title="如何实现懒加载"></a>如何实现懒加载</h3><ul><li>方案一： 在路由文件中使用 reslove=&gt;require([“./pages/HelloWorld.vue”],reslove) 来引入页面模板；</li></ul><pre><code>    export default new Router({        routes: [    //配置路由，这里是个数组            {       //每一个链接都是一个对象                path: &#39;/&#39;,  //链接路径                name: &#39;home&#39;,   //路由名称                redirect: &#39;/index&#39;,     //重定向                component: Home,    //对应的组件模板                children: [        //子路由                    {                        path: &#39;product/:id&#39;,        //动态路由 /:表示动态传id                        name: &#39;product&#39;,                        component: resolve =&gt; require([&#39;./pages/product.vue&#39;], resolve),                    },                    {                        path: &#39;detail/:id&#39;,                        name: &#39;detail&#39;,                        component: resolve =&gt; require([&#39;./pages/detail.vue&#39;], resolve),                    }                ]            ]        })</code></pre><ul><li>方案二：在路由文件中使用  ()=&gt;import(“../components/HelloWorld.vue”) 来引入组件模版；</li><li>但是这个方案用的是es7的语法，可能需要下载一个插件</li></ul><pre><code>    npm install @babel/plugin-syntax-dynamic-import    export default new Router({        routes: [    //配置路由，这里是个数组            {       //每一个链接都是一个对象                path: &#39;/&#39;,  //链接路径                name: &#39;home&#39;,   //路由名称                redirect: &#39;/index&#39;,     //重定向                component: Home,    //对应的组件模板                children: [        //子路由                    {                        path: &#39;product/:id&#39;,        //动态路由 /:表示动态传id                        name: &#39;product&#39;,                        component: () =&gt; import(&#39;./pages/product.vue&#39;)                    },                    {                        path: &#39;detail/:id&#39;,                        name: &#39;detail&#39;,                        component: () =&gt; import(&#39;./pages/detail.vue&#39;)                    }                ]            ]        })</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis三剑客</title>
      <link href="/2020/05/23/mybatis-san-jian-ke/"/>
      <url>/2020/05/23/mybatis-san-jian-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>mybatis用起来非常方便，但是每次都要写实体类，接口，mapping映射文件又显得有些麻烦，那么有没有帮我们生成这些生成这些文件的东西呢，当然有，那就是mybatis三剑客的其中之一mybatis-generator，当然还有两个可以帮助我们是使用mybatis的插件就在后面慢慢介绍</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>Mabatis三剑客分别是：mybatis-generator、mybatis-plugin、mybatis-pagehelper</li></ul><h2 id="一-mybatis-generator"><a href="#一-mybatis-generator" class="headerlink" title="一. mybatis-generator"></a>一. mybatis-generator</h2><ul><li>根据我们的数据库自动生成pojo、dao和xml文件<br>pojo里面放的是跟数据库字段一一对应的对象、dao层是接口，供service使用，xml是这个dao层接口的实现，sql语句都写在xml里</li><li>原理就是连接数据库，获取表机构，生成文件</li><li>如图生成这三个文件<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/39.png" alt=""></li></ul><ul><li>首先引入配置文件，这里用的是1.3.7版本</li></ul><pre><code>    &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.7&lt;/version&gt;            &lt;!--                如果存在文件就不会在生成，只会覆盖--&gt;            &lt;configuration&gt;                &lt;overwrite&gt;true&lt;/overwrite&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;</code></pre><ul><li>然后在main包的resource文件夹下添加文件generatorConfig.xml,如图</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/38.png" alt=""></p><h3 id="generatorConfig-xml详解"><a href="#generatorConfig-xml详解" class="headerlink" title="generatorConfig.xml详解"></a>generatorConfig.xml详解</h3><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;!DOCTYPE generatorConfiguration      PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;    &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;    &lt;!-- 配置生成器 --&gt;    &lt;generatorConfiguration&gt;    &lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用${propertyKey}的方式来引用配置项        resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties                url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.        注意，两个属性只能选址一个;        另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用    &lt;properties resource=&quot;&quot; url=&quot;&quot; /&gt;     --&gt;     &lt;!-- 在MBG工作的时候，需要额外加载的依赖包         location属性指明加载jar/zip包的全路径    &lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&gt;      --&gt;    &lt;!--         context:生成一组对象的环境         id:必选，上下文id，用于在生成错误时提示        defaultModelType:指定生成对象的样式            1，conditional：类似hierarchical；            2，flat：所有内容（主键，blob）等全部生成在一个对象中；            3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)        targetRuntime:            1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；            2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；        introspectedColumnImpl：类全限定名，用于扩展MBG    --&gt;    &lt;context id=&quot;mysql&quot; defaultModelType=&quot;hierarchical&quot; targetRuntime=&quot;MyBatis3Simple&quot; &gt;        &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；            一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖         --&gt;        &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;false&quot;/&gt;        &lt;!-- 生成的Java文件的编码 --&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;!-- 格式化java代码 --&gt;        &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;        &lt;!-- 格式化XML代码 --&gt;        &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;        &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;!-- 必须要有的，使用这个配置链接数据库            @TODO:是否可以扩展         --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:///pss&quot; userId=&quot;root&quot; password=&quot;admin&quot;&gt;            &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;        &lt;/jdbcConnection&gt;        &lt;!-- java类型处理器             用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；            注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型；         --&gt;        &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt;            &lt;!--                 true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型                false：默认,                    scale&gt;0;length&gt;18：使用BigDecimal;                    scale=0;length[10,18]：使用Long；                    scale=0;length[5,9]：使用Integer；                    scale=0;length&lt;5：使用Short；             --&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- java模型创建器，是必须要的元素            负责：1，key类（见context的defaultModelType）；2，java类；3，查询类            targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；            targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录         --&gt;        &lt;javaModelGenerator targetPackage=&quot;com._520it.mybatis.domain&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;!--  for MyBatis3/MyBatis3Simple                自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；             --&gt;            &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;!-- for MyBatis3 / MyBatis3Simple                是否创建一个不可变的类，如果为true，                那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类             --&gt;            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;            &lt;!-- 设置一个根对象，                如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项                注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：                    1，属性名相同，类型相同，有相同的getter/setter方法；             --&gt;            &lt;property name=&quot;rootClass&quot; value=&quot;com._520it.mybatis.domain.BaseDomain&quot;/&gt;            &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- 生成SQL map的XML文件生成器，            注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），                或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置            targetPackage/targetProject:同javaModelGenerator         --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口             targetPackage/targetProject:同javaModelGenerator            type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：                1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；                2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；                3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；            注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER        --&gt;        &lt;javaClientGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; type=&quot;ANNOTATEDMAPPER&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查            &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;             --&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素            选择的table会生成一下文件：            1，SQL map文件            2，生成一个主键类；            3，除了BLOB和主键的其他字段的类；            4，包含BLOB的类；            5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；            6，Mapper接口（可选）            tableName（必要）：要生成对象的表名；            注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会                根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：                1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；                2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；                3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；                4，否则，使用指定的大小写格式查询；            另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；            这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式；            可选：            1，schema：数据库的schema；            2，catalog：数据库的catalog；            3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName            4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；            5，enableInsert（默认true）：指定是否生成insert语句；            6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；            7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；            8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；            9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；            10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；            11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；            12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；            13，modelType：参考context元素的defaultModelType，相当于覆盖；            14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）            15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性            注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；         --&gt;        &lt;table tableName=&quot;userinfo&quot; &gt;            &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;            &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;            &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt;            &lt;property name=&quot;ignoreQualifiersAtRuntime&quot; value=&quot;false&quot;/&gt;            &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;            &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;            &lt;property name=&quot;modelOnly&quot; value=&quot;false&quot;/&gt;            &lt;!-- 参考 javaModelGenerator 的 rootClass 属性             &lt;property name=&quot;rootClass&quot; value=&quot;&quot;/&gt;             --&gt;            &lt;!-- 参考javaClientGenerator 的  rootInterface 属性            &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;            --&gt;            &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog             &lt;property name=&quot;runtimeCatalog&quot; value=&quot;&quot;/&gt;            --&gt;            &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema             &lt;property name=&quot;runtimeSchema&quot; value=&quot;&quot;/&gt;            --&gt;            &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename             &lt;property name=&quot;runtimeTableName&quot; value=&quot;&quot;/&gt;            --&gt;            &lt;!-- 注意，该属性只针对MyBatis3Simple有用；                如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；             --&gt;            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;age desc,username asc&quot;/&gt;            &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;            &lt;!-- generatedKey用于生成生成主键的方法，                如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选                column:主键的列名；                sqlStatement：要生成的selectKey语句，有以下可选项：                    Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()                    DB2       :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()                    DB2_MF    :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1                    Derby      :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()                    HSQLDB      :相当于selectKey的SQL为：CALL IDENTITY()                    Informix  :相当于selectKey的SQL为：select dbinfo(&#39;sqlca.sqlerrd1&#39;) from systables where tabid=1                    MySql      :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()                    SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()                    SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY                    JDBC      :相当于在生成的insert元素上添加useGeneratedKeys=&quot;true&quot;和keyProperty属性            &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot;/&gt;             --&gt;            &lt;!--                 该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，                比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；                那么就可以设置searchString为&quot;^CUST_&quot;，并使用空白替换，那么生成的Customer对象中的属性名称就不是                custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；                注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，                如果使用了columnOverride元素，该属性无效；            &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt;             --&gt;             &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；                 column:要重新设置的列名；                 注意，一个table元素中可以有多个columnOverride元素哈~              --&gt;             &lt;columnOverride column=&quot;username&quot;&gt;                 &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;                 &lt;property name=&quot;property&quot; value=&quot;userName&quot;/&gt;                 &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名                 &lt;property name=&quot;javaType&quot; value=&quot;&quot;/&gt;                  --&gt;                 &lt;!-- jdbcType用于指定该列的JDBC类型                  &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;                  --&gt;                 &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名                     注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler                     只会生成类似：where id = #{id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler}的参数描述                 &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;                 --&gt;                 &lt;!-- 参考table元素的delimitAllColumns配置，默认为false                 &lt;property name=&quot;delimitedColumnName&quot; value=&quot;&quot;/&gt;                  --&gt;             &lt;/columnOverride&gt;             &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现                  column:指定要忽略的列的名字；                 delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false                 注意，一个table元素中可以有多个ignoreColumn元素             &lt;ignoreColumn column=&quot;deptId&quot; delimitedColumnName=&quot;&quot;/&gt;             --&gt;        &lt;/table&gt;    &lt;/context&gt;    &lt;/generatorConfiguration&gt;</code></pre><h3 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h3><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;!DOCTYPE generatorConfiguration            PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;            &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;    &lt;generatorConfiguration&gt;        &lt;!--    windows下路径, 如D:/downloads/xxx.jar--&gt;        &lt;classPathEntry location=&quot;D:/downloads/mybatis/mysql-connector-java-5.1.6.jar&quot; /&gt;        &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;            &lt;!--        不再追加xml内容--&gt;            &lt;plugin type=&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot; /&gt;            &lt;commentGenerator&gt;                &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;            &lt;/commentGenerator&gt;            &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                            connectionURL=&quot;jdbc:mysql://192.168.206.131:3307/mimall?characterEncoding=utf-8&quot;                            userId=&quot;root&quot;                            password=&quot;123456&quot;&gt;            &lt;/jdbcConnection&gt;            &lt;javaTypeResolver &gt;                &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;            &lt;/javaTypeResolver&gt;            &lt;javaModelGenerator targetPackage=&quot;com.imooc.mimall.pojo&quot; targetProject=&quot;src/main/java&quot;&gt;                &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;                &lt;!--            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;--&gt;            &lt;/javaModelGenerator&gt;            &lt;sqlMapGenerator targetPackage=&quot;mappers&quot;  targetProject=&quot;src/main/resources&quot;&gt;                &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;            &lt;/sqlMapGenerator&gt;            &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.imooc.mimall.dao&quot;  targetProject=&quot;src/main/java&quot;&gt;                &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;            &lt;/javaClientGenerator&gt;            &lt;table tableName=&quot;mall_order&quot; domainObjectName=&quot;Order&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;/&gt;            &lt;table tableName=&quot;mall_order_item&quot; domainObjectName=&quot;OrderItem&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;/&gt;            &lt;table tableName=&quot;mall_user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;/&gt;        &lt;/context&gt;    &lt;/generatorConfiguration&gt;</code></pre><h3 id="运行代码生成文件"><a href="#运行代码生成文件" class="headerlink" title="运行代码生成文件"></a>运行代码生成文件</h3><ul><li>配置完成后只需打开终端运行此命令就能生成文件</li></ul><pre><code>    mvn mybatis-generator:generate</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>generatorConfig.xml默认配置中是生成Example类的相关内容，如果不需要Example类，只需要将enableCountByExample、enableCountByExample、enableDeleteByExample、enableSelectByExample设置为true或者去掉这些配置。</li></ul><h2 id="二、Mybatis-plugin插件"><a href="#二、Mybatis-plugin插件" class="headerlink" title="二、Mybatis-plugin插件"></a>二、Mybatis-plugin插件</h2><ul><li>提供Mapper接口与配置文件中对应SQL的导航</li><li>编辑XML文件时自动补全</li><li>自动检查Mapper XML文件中ID冲突</li><li>自动检查Mapper XML文件中错误的属性值</li><li>等等</li></ul><h3 id="Free-Mybatis-plugin插件"><a href="#Free-Mybatis-plugin插件" class="headerlink" title="Free-Mybatis-plugin插件"></a>Free-Mybatis-plugin插件</h3><ul><li>因为Mybatis-plugin插件现在收费了，我们找到一个免费的替代版本</li><li>只需下载插件就行</li><li>我们暂时用到的功能是追踪dao接口和mapper文件里xml的一个插件</li><li>效果：点击dao可以追踪到xml，，同理点击xml的sql右边小箭头，可以追踪到dao方法</li></ul><h2 id="三、Mybatis-pageHelper"><a href="#三、Mybatis-pageHelper" class="headerlink" title="三、Mybatis-pageHelper"></a>三、Mybatis-pageHelper</h2><ul><li>Mybatis-pageHelper是使数据实现分页效果的插件</li></ul><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>    &lt;!--        mybatis分页器--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;        &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.2.13&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>在方法中使用</li></ul><pre><code>    //使用mybatis分页器，pageNum表示第几页，pageSize表示每页的条数    PageHelper.startPage(pageNum,pageSize);    //返回值赋值成productVo类型    List&lt;Product&gt; productList = productMapper.selectByCategoryIdSet(categoryIdSet);    List&lt;ProductVo&gt; productVoList = productList.stream()            .map(e -&gt; {                ProductVo productVo = new ProductVo();                BeanUtils.copyProperties(e, productVo);                return productVo;            })            .collect(Collectors.toList());    PageInfo pageInfo = new PageInfo&lt;&gt;(productList);    //所有查到的数据    pageInfo.setList(productVoList);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis的使用</title>
      <link href="/2020/05/22/mybatis/"/>
      <url>/2020/05/22/mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这是我学习Mybatis做的一些笔记，包括XML和注解两种方法,注解方法只需了解会用就行，XML要熟悉使用</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>Mybatis是一个基于Java的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录</li></ul><h2 id="导入依赖和配置"><a href="#导入依赖和配置" class="headerlink" title="导入依赖和配置"></a>导入依赖和配置</h2><ul><li>依赖，这里我们用的是2.1.0版本</li></ul><pre><code>    &lt;!--        Mybatis--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;2.1.0&lt;/version&gt;            &lt;/dependency&gt;    &lt;!--        数据库--&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                &lt;scope&gt;runtime&lt;/scope&gt;            &lt;/dependency&gt;</code></pre><ul><li>配置</li></ul><pre><code>    spring:      datasource:        password: 123456        username: root        url: jdbc:mysql://192.168.206.131:3307/mimall?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8        driver-class-name: com.mysql.cj.jdbc.Driver    mybatis:      configuration:        map-underscore-to-camel-case: true    #驼峰命名法</code></pre><h2 id="使用Mybatis"><a href="#使用Mybatis" class="headerlink" title="使用Mybatis"></a>使用Mybatis</h2><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><ul><li>新建两个文件如图</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/36.png" alt=""></p><ul><li>Category是对应数据库表设置的实体类</li><li>这里可以使用一个插件免于生成get set toString方法</li><li>导入依赖和下载插件lombok（记住要去下载插件）</li></ul><pre><code>    &lt;!--        lombok插件，自动生成get set方法和toStringFangfa--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;/dependency&gt;</code></pre><ul><li>Category</li></ul><pre><code>    @Data       //自动生成get set toString方法    public class Category {        private Integer id;        private Integer parentId;        private String name;        private Integer status;        private Integer sortOrder;        private Date createTime;        private Date updateTime;    }</code></pre><ul><li>CategoryMapper是对数据库进行增删改查的接口</li><li>需要在接口前写上@Mapper注解</li></ul><pre><code>    @Mapper    public interface CategoryMapper {        @Select(&quot;select * from mall_category where id = #{id}&quot;)        Category findById(@Param(&quot;id&quot;) Integer id);    }</code></pre><ul><li>但是每个注解前都写@Mapper注解就太麻烦了，可以在主类前写上@MapperScan(basePackages = “com.imooc.mimall.dao”)</li></ul><pre><code>    @MapperScan(basePackages = &quot;com.imooc.mimall.dao&quot;)    @SpringBootApplication    public class MimallApplication {        public static void main(String[] args) {            SpringApplication.run(MimallApplication.class, args);        }    }</code></pre><ul><li>测试</li></ul><pre><code>    @Autowired    private CategoryMapper categoryMapper;    @Test    public void findById() {        Category category = categoryMapper.findById(100001);        System.out.println(category.toString());    }</code></pre><h3 id="XML方式"><a href="#XML方式" class="headerlink" title="XML方式"></a>XML方式</h3><ul><li>生成xml文件如图</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/37.png" alt=""></p><ul><li>namespace：增删改查接口所在包</li><li>sql中id是对数据库操作时公共的字段，可以提取出来</li><li>select中id是接口的名字，resultType是对应数据库的类的所在包</li></ul><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;    &lt;!DOCTYPE mapper            PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;            &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;    &lt;mapper namespace=&quot;com.imooc.mimall.dao.CategoryMapper&quot;&gt;    &lt;!--    公共的字段--&gt;        &lt;sql id=&quot;Base_Column_List&quot;&gt;            id, parent_id, name, status, sort_order, create_time, update_time        &lt;/sql&gt;        &lt;select id=&quot;queryById&quot; resultType=&quot;com.imooc.mimall.pojo.Category&quot;&gt;            select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from mall_category where id = #{id}        &lt;/select&gt;    &lt;/mapper&gt;</code></pre><ul><li>CategoryMapper中加入接口，注意不要写sql语句了，xml中写了，对比注解</li></ul><pre><code>    //@Mapper    public interface CategoryMapper {        @Select(&quot;select * from mall_category where id = #{id}&quot;)        Category findById(@Param(&quot;id&quot;) Integer id);        Category queryById(Integer id);    }</code></pre><ul><li>这样就可以用了吗，还是会报错，因为我们yml中没配置mappers中xml所在包，所以无法使用</li></ul><pre><code>    mybatis:      configuration:        map-underscore-to-camel-case: true    #驼峰命名法      mapper-locations: classpath:mappers/*.xml  #使用xml时导入mappers包</code></pre><ul><li>测试和注解方式一摸一样</li></ul><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><ul><li>foreach元素的属性主要有item，index，collection，open，separator，close。<ul><li>item：集合中元素迭代时的别名，该参数为必选。</li><li>index：在list和数组中,index是元素的序号，在map中，index是元素的key，该参数可选</li><li>open：foreach代码的开始符号，一般是(和close=”)”合用。常用在in(),values()时。该参数可选</li><li>separator：元素之间的分隔符，例如在in()的时候，separator=”,”会自动在元素中间用“,“隔开，避免手动输入逗号导致sql错误，如in(1,2,)这样。该参数可选。</li><li>close: foreach代码的关闭符号，一般是)和open=”(“合用。常用在in(),values()时。该参数可选。</li><li>collection: 要做foreach的对象，作为入参时，List对象默认用”list”代替作为键，数组对象有”array”代替作为键，Map对象没有默认的键。当然在作为入参时可以使用@Param(“keyName”)来设置键，设置keyName后，list,array将会失效。 除了入参这种情况外，还有一种作为参数对象的某个字段的时候。举个例子：如果User有属性List ids。入参是User对象，那么这个collection = “ids”.如果User有属性Ids ids;其中Ids是个对象，Ids有个属性List id;入参是User对象，那么collection = “ids.id”</li></ul></li><li>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况： <ul><li>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list .</li><li>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array .</li><li>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key.</li></ul></li></ul><h5 id="mapper接口"><a href="#mapper接口" class="headerlink" title="mapper接口"></a>mapper接口</h5><ul><li>建立增删改查操作时当传入参数为一个集合或者列表时，例如，注意要加上注解@Param</li></ul><pre><code>    List&lt;Product&gt; selectByCategoryIdSet(@Param(&quot;categoryIdSet&quot;) Set&lt;Integer&gt; categoryIdSet);</code></pre><h5 id="xml文件"><a href="#xml文件" class="headerlink" title="xml文件"></a>xml文件</h5><ul><li>这是查询category_id是否在集合内，是就返回</li></ul><pre><code>    &lt;select id=&quot;selectByCategoryIdSet&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select        &lt;include refid=&quot;Base_Column_List&quot;/&gt;        from mall_product        where status = 1        &lt;if test=&quot;categoryIdSet.size() &gt; 0&quot;&gt;            and category_id in            &lt;foreach collection=&quot;categoryIdSet&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;                #{item}            &lt;/foreach&gt;        &lt;/if&gt;    &lt;/select&gt;</code></pre><h4 id="Param注解"><a href="#Param注解" class="headerlink" title="@Param注解"></a>@Param注解</h4><h5 id="使用场景一"><a href="#使用场景一" class="headerlink" title="使用场景一"></a>使用场景一</h5><ul><li>注解单一属性，当传入参数不止一个时使用</li><li>dao层示例</li></ul><pre><code>    int deleteByIdAndUid(@Param(&quot;shippingId&quot;) Integer shippingId,@Param(&quot;userId&quot;) Integer userId);</code></pre><ul><li>xml映射对应示例</li></ul><pre><code>    &lt;delete id=&quot;deleteByIdAndUid&quot; parameterType=&quot;map&quot;&gt;        delete from mall_shipping        where id = #{shippingId,jdbcType=INTEGER}        and user_id = #{userId,jdbcType=INTEGER}      &lt;/delete&gt;</code></pre><p>注意：采用#{}的方式把@Param注解括号内的参数进行引用（括号内参数对应的是形参如 userId对应的是userId）；</p><h5 id="使用场景二"><a href="#使用场景二" class="headerlink" title="使用场景二"></a>使用场景二</h5><ul><li>@Param注解JavaBean对象，当传入参数为一个对象时使用</li><li>dao层示例</li></ul><pre><code>    List&lt;Shipping&gt; selectByIdSet(@Param(&quot;idSet&quot;) Set&lt;Integer&gt; idSet);</code></pre><ul><li>xml映射对应示例</li></ul><pre><code>    &lt;select id=&quot;selectByIdSet&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select        &lt;include refid=&quot;Base_Column_List&quot;/&gt;        from mall_shipping        &lt;where&gt;            &lt;if test=&quot;idSet.size() &gt; 0&quot;&gt;                id in                &lt;foreach collection=&quot;idSet&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;                    #{item}                &lt;/foreach&gt;            &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><h3 id="插入数据获取不到自动生成主键问题"><a href="#插入数据获取不到自动生成主键问题" class="headerlink" title="插入数据获取不到自动生成主键问题"></a>插入数据获取不到自动生成主键问题</h3><ul><li>Springboot中 Mybatis 配置文件 Mapper参数</li><li>useGeneratedKeys=“true” keyProperty=“id”</li><li>useGeneratedKeys设置为 true 时，表示如果插入的表id以自增列为主键，则允许 JDBC 支持自动生成主键，并可将自动生成的主键id返回。</li><li>useGeneratedKeys参数只针对 insert 语句生效，默认为 false；</li><li>dao层示例</li></ul><pre><code>    int insertSelective(Shipping record);</code></pre><ul><li>xml映射文件</li></ul><pre><code>    &lt;!--    允许生成的主键返回--&gt;    &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.imooc.mimall.pojo.Shipping&quot; useGeneratedKeys=&quot;true&quot;                keyProperty=&quot;id&quot;&gt;            insert into mall_shipping            &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;                &lt;if test=&quot;id != null&quot;&gt;                    id,                &lt;/if&gt;                &lt;if test=&quot;userId != null&quot;&gt;                    user_id,                &lt;/if&gt;                &lt;if test=&quot;receiverName != null&quot;&gt;                    receiver_name,                &lt;/if&gt;                &lt;if test=&quot;receiverPhone != null&quot;&gt;                    receiver_phone,                &lt;/if&gt;                &lt;if test=&quot;receiverMobile != null&quot;&gt;                    receiver_mobile,                &lt;/if&gt;                &lt;if test=&quot;receiverProvince != null&quot;&gt;                    receiver_province,                &lt;/if&gt;                &lt;if test=&quot;receiverCity != null&quot;&gt;                    receiver_city,                &lt;/if&gt;                &lt;if test=&quot;receiverDistrict != null&quot;&gt;                    receiver_district,                &lt;/if&gt;                &lt;if test=&quot;receiverAddress != null&quot;&gt;                    receiver_address,                &lt;/if&gt;                &lt;if test=&quot;receiverZip != null&quot;&gt;                    receiver_zip,                &lt;/if&gt;                &lt;if test=&quot;createTime != null&quot;&gt;                    create_time,                &lt;/if&gt;                &lt;if test=&quot;updateTime != null&quot;&gt;                    update_time,                &lt;/if&gt;            &lt;/trim&gt;            &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;                &lt;if test=&quot;id != null&quot;&gt;                    #{id,jdbcType=INTEGER},                &lt;/if&gt;                &lt;if test=&quot;userId != null&quot;&gt;                    #{userId,jdbcType=INTEGER},                &lt;/if&gt;                &lt;if test=&quot;receiverName != null&quot;&gt;                    #{receiverName,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverPhone != null&quot;&gt;                    #{receiverPhone,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverMobile != null&quot;&gt;                    #{receiverMobile,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverProvince != null&quot;&gt;                    #{receiverProvince,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverCity != null&quot;&gt;                    #{receiverCity,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverDistrict != null&quot;&gt;                    #{receiverDistrict,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverAddress != null&quot;&gt;                    #{receiverAddress,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverZip != null&quot;&gt;                    #{receiverZip,jdbcType=VARCHAR},                &lt;/if&gt;            &lt;/trim&gt;        &lt;/insert&gt;</code></pre><h3 id="dao层传入参数为List时"><a href="#dao层传入参数为List时" class="headerlink" title="dao层传入参数为List时"></a>dao层传入参数为List时</h3><ul><li>List中的数据而且还是对象</li><li>dao层示例</li></ul><pre><code>    int batchInsert(@Param(&quot;orderItemList&quot;) List&lt;OrderItem&gt; orderItemList);</code></pre><ul><li>xml映射文件对应示例，因为List中是对象，要一个个获取属性要用#{item.xxx},注意外面的大括号不能丢</li></ul><pre><code>    &lt;insert id=&quot;batchInsert&quot; parameterType=&quot;list&quot;&gt;        insert into mall_order_item (user_id, order_no,        product_id, product_name, product_image,        current_unit_price, quantity, total_price)        values        &lt;foreach collection=&quot;orderItemList&quot; index=&quot;index&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt;            (            #{item.userId},            #{item.orderNo},            #{item.productId},            #{item.productName},            #{item.productImage},            #{item.currentUnitPrice},            #{item.quantity},            #{item.totalPrice}            )        &lt;/foreach&gt;    &lt;/insert&gt;</code></pre><h3 id="dao层传入参数为Set时"><a href="#dao层传入参数为Set时" class="headerlink" title="dao层传入参数为Set时"></a>dao层传入参数为Set时</h3><ul><li>dao层示例</li></ul><pre><code>    List&lt;OrderItem&gt; selectByOrderNoSet(@Param(&quot;orderNoSet&quot;) Set&lt;Long&gt; orderNoSet);</code></pre><ul><li>xml映射文件对应示例，因为set里面不是对象，所以直接获取item就好了，这里用到了open和close</li></ul><pre><code>    &lt;select id=&quot;selectByOrderNoSet&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select        &lt;include refid=&quot;Base_Column_List&quot;/&gt;        from mall_order_item        &lt;where&gt;            &lt;if test=&quot;orderNoSet.size() &gt; 0&quot;&gt;                order_no in                &lt;foreach collection=&quot;orderNoSet&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;                    #{item}                &lt;/foreach&gt;            &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><h3 id="List转Map"><a href="#List转Map" class="headerlink" title="List转Map"></a>List转Map</h3><ul><li>Map value值为对象</li></ul><pre><code>    //获取所有商品    List&lt;Product&gt; products = productMapper.selectByProductIdSet(productIdSet);    //把商品转换成一个map，这样就可以不经数据库查到数据，用到Collectors.toMap()方法    Map&lt;Integer, Product&gt; map = products.stream()            .collect(Collectors.toMap(Product::getId, product -&gt; product));</code></pre><ul><li>Map value为List,List中也是对象</li></ul><pre><code>    List&lt;OrderItem&gt; orderItemList = orderItemMapper.selectByOrderNoSet(orderNoSet);    //list转map，这里因为value是一个List，所以要用到groupingBy    Map&lt;Long, List&lt;OrderItem&gt;&gt; orderItemMap = orderItemList.stream()            .collect(Collectors.groupingBy(OrderItem::getOrderNo));</code></pre><h3 id="List转Set"><a href="#List转Set" class="headerlink" title="List转Set"></a>List转Set</h3><pre><code>    List&lt;Order&gt; orderList = orderMapper.selectByUid(uid);    Set&lt;Integer&gt; shippingIdSet = orderList.stream()            .map(Order::getShippingId)            .collect(Collectors.toSet());</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分页加载，点击按钮加载更多和滚动加载</title>
      <link href="/2020/05/18/fen-ye/"/>
      <url>/2020/05/18/fen-ye/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>如果返回的数据比较少，那么我们放在一个页面没什么问题，但是请求回来的数据比较多，放在一个页面就会用户体验比较差，我们需要把他分开</li><li>这里有三种方法，分页，点击按钮加载更多，和滚动加载更多</li><li>前两种方法是用element-ui的组件，滚动加载则是用一个插件vue-infinite-scroll</li></ul><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><pre><code>    getOrderList() {          this.loading = true       //加载loading          this.axios            .get(&quot;/orders&quot;,{              params:{                pageSize: 5,        //每页跳蛛                pageNum:this.pageNum    //当前页数              }            })            .then(res =&gt; {              this.loading = false;              this.list = res.list;     //当前页面数据              this.total = res.total;   //总条数            })            .catch(() =&gt; {              this.loading = false;            });</code></pre><h3 id="Pagination组件"><a href="#Pagination组件" class="headerlink" title="Pagination组件"></a>Pagination组件</h3><ul><li>做一个应用不可能一个页面都能把所有数据加载完，所以我们要实现分页效果，一页只实现少量的数据，可以分很多页</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>注意，这是一个组件，要在components中引入，这里的语法可能不太好理解，Pagination.name就相当于<el-pagination></el-pagination>，这个是在html中引入的组件</p><pre><code>  import { Pagination } from &quot;element-ui&quot;;  components: {      [Pagination.name]: Pagination    }</code></pre></li></ul><pre><code>     &lt;el-pagination class=&quot;pagination&quot; :pageSize=&quot;pageSize&quot; background layout=&quot;prev, pager, next&quot; :total=&quot;total&quot; @current-change=&quot;handelchange&quot;&gt;&lt;/el-pagination&gt;</code></pre><ul><li><p>这里面的组件包含很多属性，pageSize就是页面的大小可以包含几条数据，total表示总数据，注意属性的调用可能有驼峰命名法，比如文档中调用属性page-size会出错，你要改成pageSize</p></li><li><p>current-change是事件名称，page页改变的时候会触发，回调参数是当前页数</p><pre><code>   //点击触发事件，会有一个回调参数，这个回调参数就是当前的页数      handelchange(pageNum){        this.pageNum = pageNum        this.getOrderList()      }</code></pre></li></ul><h2 id="加载更多"><a href="#加载更多" class="headerlink" title="加载更多"></a>加载更多</h2><h3 id="Button组件"><a href="#Button组件" class="headerlink" title="Button组件"></a>Button组件</h3><ul><li>点击Button组件会加载更多数据</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li><p>组件的loading属性是显示加载loading的，需要动态绑定，在加载时显示，加载完成后关闭，绑定到getOrderList</p><pre><code>  import { Button } from &quot;element-ui&quot;;  components: {      [Button.name]: Button,    }  &lt;el-button type=&quot;primary&quot; :loading=&quot;loading&quot; @click=&quot;loadMore&quot;&gt;加载更多&lt;/el-button&gt;</code></pre></li><li><p>loadMore事件是加载更多</p><pre><code>  loadMore(){        this.pageNum++    //每点击一次页数加1        this.getOrderList()      }</code></pre></li><li><p>我们发现返回的数据没有拼接，只有请求的到数据，我们要把它拼接</p><pre><code>  this.list = this.list.concat(res.list);   //把返回的数据拼接到一起</code></pre></li></ul><h2 id="滚动加载"><a href="#滚动加载" class="headerlink" title="滚动加载"></a>滚动加载</h2><ul><li>开发中总会遇到这种下拉加载的设计方案，Vue实现下拉加载最佳方案自然是使用vue-infinite-scroll来实现。接下来我们一起看下它的配置及使用方式。</li></ul><h3 id="首先我们先了解下他的配置参数："><a href="#首先我们先了解下他的配置参数：" class="headerlink" title="首先我们先了解下他的配置参数："></a>首先我们先了解下他的配置参数：</h3><ul><li>v-infinite-scroll=”loadMore”表示回调函数是loadMore</li><li>infinite-scroll-disabled=”busy”表示由变量busy决定是否执行loadMore，false则执行loadMore，true则不执行，注意，busy表示繁忙，繁忙的时候是不执行的。</li><li>infinite-scroll-distance=”10”这里10决定了页面滚动到离页尾多少像素的时候触发回调函数，10是像素值。一般情况下会在页尾做一个几十像素高的“正在加载中…”，这样的话，可以把这个div的高度设为infinite-scroll-distance的值即可。</li><li>infinite-scroll-immediate-check 默认值为true，该指令表示，应该在绑定后立即检查busy的值和是否滚动到底。假如你的初始内容高度不够，不足以填满可滚动的容器的话，你应设为true，这样会立即执行一次loadMore，会帮你填充一些初始内容。</li><li>infinite-scroll-listen-for-event 当事件在Vue实例中发出时，无限滚动将再次检查。</li><li>infinite-scroll-throttle-delay 检查busy的值的时间间隔，默认值是200，因为vue-infinite-scroll的基础原理是，vue-infinite-scroll会循环检查busy的值，以及是否滚动到底，只有当：busy为false且滚动到底，回调函数才会执行</li></ul><h3 id="安装vue-infinite-scroll"><a href="#安装vue-infinite-scroll" class="headerlink" title="安装vue-infinite-scroll"></a>安装vue-infinite-scroll</h3><pre><code>    npm install vue-infinite-scroll --save</code></pre><h3 id="引入-vue-infinite-scroll"><a href="#引入-vue-infinite-scroll" class="headerlink" title="引入 vue-infinite-scroll"></a>引入 vue-infinite-scroll</h3><ul><li><p>全局引入</p><pre><code>  // register globally（全局引入，在main.js中引入）  import infiniteScroll from &#39;vue-infinite-scroll&#39;  Vue.use(infiniteScroll)</code></pre></li><li><p>局部引入</p><pre><code>  // or for a single instance  import infiniteScroll from &#39;vue-infinite-scroll&#39;  new Vue({    directives: {infiniteScroll}  })</code></pre></li></ul><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><ul><li><p>首先需要引用插件，上面步骤，然后使用，img是加载动画，需要绑定一个loading动态加载</p><pre><code>      &lt;div              v-show=&quot;loading&quot;              v-infinite-scroll=&quot;loadMore&quot;              infinite-scroll-disabled=&quot;busy&quot;              infinite-scroll-distance=&quot;410&quot;            &gt;            &lt;img src=&quot;/imgs/loading-svg/loading-spinning-bubbles.svg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;          &lt;/div&gt;</code></pre></li></ul><ul><li><p>触发事件，下拉都一定程度就会触发</p><pre><code>          loadMore(){        this.busy = true      //触发事件后busy繁忙        setTimeout(()=&gt;{      //防止频繁触发事件，设置0.5秒延迟          this.pageNum++          this.getList()        },500)      },      getList() {        this.loading = true        this.axios          .get(&quot;/orders&quot;, {            params: {              pageSize: 5,              pageNum: this.pageNum            }          })          .then(res =&gt; {            this.list = this.list.concat(res.list);   //拼接            if(res.hasNextPage){                  this.busy = false            }else{              this.busy = true  //如果没有下一页，就禁止掉，下拉将没用，动画也不再显示              this.loading = false            }          })      },</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> element-ui，vue-infinite-scroll </category>
          
      </categories>
      
      
        <tags>
            
            <tag> element-ui </tag>
            
            <tag> vue </tag>
            
            <tag> vue-infinite-scroll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商支付（微信支付和支付宝支付）前端</title>
      <link href="/2020/05/17/dian-shang-zhi-fu/"/>
      <url>/2020/05/17/dian-shang-zhi-fu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>做一个电商平台，那么最必不可少的步骤就是支付了，我们这里只介绍两种最主流的支付方法，微信支付和支付宝支付，众所周知考虑到支付安全等因素，支付要做的大部分事情都是后端承担的，前端只需要做少部分事情与后端对接就可以了，这里我们暂时只讲前端与后端对接的支付功能</li></ul><h2 id="订单页面"><a href="#订单页面" class="headerlink" title="订单页面"></a>订单页面</h2><ul><li>这个页面前期已开发好，暂时只讲支付功能，这个页面的开发就没写出来了。点击微信支付则弹出微信支付框，点击支付宝则跳转到支付宝支付页面（这个相对更安全）</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/31.png" alt=""></p><h2 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h2><ul><li>点击触发事件，携带支付订单号跳转到支付宝页面</li></ul><pre><code>    paySubmit(payment) {          //payment等于1就是支付宝支付，2就是微信支付          if (payment == 1) {            this.payment = 1;            window.open(&quot;/#/order/alipay?orderId=&quot; + this.orderNo, &quot;_blank&quot;); //携带订单号跳转到支付宝支付页面（新页面）          }        }</code></pre><ul><li>alipay页面，调用接口，返回一堆html源码</li><li>我们需要用v-html把他渲染出来，它是一个form表单，我们还需要提交他document.forms[0].submit()，然后就会跳转到支付宝支付页面</li></ul><pre><code>    &lt;template&gt;        &lt;div class=&quot;ali-pay&quot;&gt;            &lt;order-header title=&quot;订单支付&quot;&gt;                &lt;template v-slot:tips&gt;                    &lt;span&gt;请谨防钓鱼链接或诈骗电话，了解更多&lt;/span&gt;                &lt;/template&gt;            &lt;/order-header&gt;            &lt;loading v-if=&quot;loading&quot;&gt;&lt;/loading&gt;            &lt;div class=&quot;form&quot; v-html=&quot;content&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        import OrderHeader from &#39;./../components/OrderHeader&#39;;        import Loading from &#39;./../components/Loading&#39;;        export default {            name: &#39;alipay&#39;,            data() {                return {                    orderId: this.$route.query.orderId,      //订单号                    content: &#39;&#39;,     //支付宝页面html源码                    loading: true   //是否展示loading                }            },            components: {                OrderHeader,                Loading            },            mounted() {                //调用支付宝接口                this.submitPay()            },            methods: {                submitPay() {                    this.axios.post(&#39;/pay&#39;, {                        orderId: this.orderId,                        orderName: &#39;Vue小米高仿商城&#39;,                        amount: 0.01,                        payType: 1,                    }).then((res) =&gt; {                        this.content = res.content                        setTimeout(()=&gt;{                            document.forms[0].submit();     //提交第一个表单数据，跳转到支付宝页面                        },100)                    })                }            },        }    &lt;/script&gt;</code></pre><h3 id="中转页面"><a href="#中转页面" class="headerlink" title="中转页面"></a>中转页面</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/32.png" alt=""></p><h3 id="支付页面"><a href="#支付页面" class="headerlink" title="支付页面"></a>支付页面</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/33.png" alt=""></p><h2 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h2><ul><li>微信支付和支付宝支付调用的接口差不多，只不过微信返回的之一串二维码生成的代码，我们需要解析它</li></ul><h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><ul><li>qrcode是一个可以把代码生成二维码的插件，可以用来生成微信支付二维码</li></ul><pre><code>    cnpm install qrcode --save</code></pre><h3 id="插件的基本使用方法"><a href="#插件的基本使用方法" class="headerlink" title="插件的基本使用方法"></a>插件的基本使用方法</h3><pre><code>    import QRCode from &quot;qrcode&quot;;    QRCode.toDataURL(content)                  .then(url =&gt; {                    console.log(url)    //成功生成二维码                  })                  .catch((err) =&gt; {                    console.log(err)    //失败                  });</code></pre><h3 id="调用接口生成二维码"><a href="#调用接口生成二维码" class="headerlink" title="调用接口生成二维码"></a>调用接口生成二维码</h3><pre><code>    paySubmit(payment) {    if (payment == 2) {            this.payment = 2;            this.axios              .post(&quot;/pay&quot;, {                orderId: this.orderNo,                orderName: &quot;Vue高仿小米商城&quot;,                amount: 0.01,                payType: 2              })              .then(res =&gt; {                  //通过插件生成微信支付二维码                QRCode.toDataURL(res.content)                  .then(url =&gt; {                    this.showPay = true;                    this.payImg = url;                    this.loopOrderState()                  })                  .catch(() =&gt; {                    this.$message.error(&#39;二维码生成失败，请稍后重试&#39;)                  });              });          }        }</code></pre><h3 id="微信支付弹框"><a href="#微信支付弹框" class="headerlink" title="微信支付弹框"></a>微信支付弹框</h3><ul><li>是先做好，点击微信支付则弹出</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/34.png" alt=""></p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><ul><li>我们这里要做的功能是用户扫码之后就会跳转到订单列表，我们要怎么才能知道用户是否已经支付了呢，这里我们一秒轮询一次支付状态，直到用户已经支付，则关闭轮询，跳转到订单列表页面</li></ul><pre><code>    //轮询当前支付状态        loopOrderState(){          //setInterval和setTimeout不一样，这个只要不关闭会一直轮询，setTimeout则只会执行一次          this.T = setInterval(()=&gt;{            this.axios.get(`/orders/${this.orderNo}`).then((res)=&gt;{            if(res.status == 20){              clearInterval(this.T)   //关闭轮询              this.gotoOrderList()            }          })          },1000)        }</code></pre><ul><li>点击关闭微信支付页面，为了更好的用户体验，会弹出一个弹框，让用户自己选择有没有支付（怕网络延迟，支付成功不跳转），当然这里也要关闭轮询</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/35.png" alt=""></p><h3 id="支付完成"><a href="#支付完成" class="headerlink" title="支付完成"></a>支付完成</h3><ul><li>支付完成之后我们还要干嘛呢，就是再次点击微信支付，因为订单已经没有了，就会报一个错，这里我们要提醒用户已经支付，到main.js中去配置,这里的错误是http请求状态码错误，跟返回数据状态码错误不一样</li><li>这里是接口调用失败，http状态码为500，没有返回response数据，所以需要在error里处理</li></ul><pre><code>    //接口错误拦截    axios.interceptors.response.use(function(response){   //拦截页面返回数据状态码      let res = response.data      if(res.status == 0){      //状态码为0代表登陆成功        return res.data      }else if(response.status == 10){    //状态码为10代表未登陆，跳转到登陆页面        if(location.hash!=&#39;#/index&#39;){     //如果没有登录则只能访问首页          window.location.href = &#39;/#/login&#39;   //跳转到登陆页面        }        return Promise.reject()   //发生错误，promise返回拒绝值      }else{        Message.error(res.msg)        return Promise.reject()   //发生错误，promise返回拒绝值      }    },(error)=&gt;{    //拦截http请求状态码（请求发送失败）      let res = error.response      Message.error(res.data.message)      return Promise.reject()   //发生错误，promise返回拒绝值    })</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-cli脚手架</title>
      <link href="/2020/05/13/vue-cli/"/>
      <url>/2020/05/13/vue-cli/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这是我学习vue一段时间后，上手脚手架，做的一些笔记</li></ul><h2 id="什么是脚手架"><a href="#什么是脚手架" class="headerlink" title="什么是脚手架"></a>什么是脚手架</h2><ul><li>vue-cli4.0安装及应用生成，vue-cli4.0是一个脚手架，作用是创建一个初始化的Vue项目，一个很方便的东西，很多东西都封装好了，我们只需要用就行了，约定大于配置</li></ul><h2 id="安装和环境搭建"><a href="#安装和环境搭建" class="headerlink" title="安装和环境搭建"></a>安装和环境搭建</h2><ul><li>安装vue-cli：cnpm i -g @vue/cli（一般会下载最新版本）</li><li>创建项目：vue create + 项目名</li><li>默认babel，eslint自动安装</li></ul><h2 id="vue-cli的使用"><a href="#vue-cli的使用" class="headerlink" title="vue-cli的使用"></a>vue-cli的使用</h2><ul><li>进入文件，启动：cnpm run serve</li><li>使用脚手架的界面ui功能：vue ui，这是脚手架内置的一套可视化的系统，（vue项目管理器，需要导入项目，或者创建项目）</li><li>安装一些依赖插件：axios，vue-router，vuex（这些插件的使用后面会说到）</li></ul><h2 id="脚手架目录结构解析"><a href="#脚手架目录结构解析" class="headerlink" title="脚手架目录结构解析"></a>脚手架目录结构解析</h2><pre><code>    public --- 存放一些公共资源，比如大图片等    resource --- 一些打包的资源，供我们使用    .gitignore --- git忽略配置文件    package-lock.json --- 项目包管控文件    package.json --- 项目配置    README.md --- 项目说明书    dist --- 打包后的项目    src --- 源码目录        |- api --- 承载整个项目的api请求        |- assets --- 存放web中引用的图片 媒体资源        |- components --- 存放可复用组件，你可以在任意页面中复用这些组件        |- util --- 一些公共的方法        |- store --- vuex        |- App.vue --- 是项目入口文件        |- main.js --- 根逻辑，页面加载首先会加载这份js文件。        |- router.js --- 路由文件        |- pages --- 页面</code></pre><h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><h3 id="Vue文件解析"><a href="#Vue文件解析" class="headerlink" title="Vue文件解析"></a>Vue文件解析</h3><ul><li>vue文件初始化一般是template模板包裹一层div来写骨架，然后就是script写逻辑，style写样式</li></ul><pre><code>    &lt;template&gt;        &lt;div&gt;            orderList        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default{            name: &#39;order-list&#39;,        }    &lt;/script&gt;    &lt;style&gt;    &lt;/style&gt;</code></pre><h3 id="watch-和-computed的-简析"><a href="#watch-和-computed的-简析" class="headerlink" title="watch 和 computed的 简析"></a>watch 和 computed的 简析</h3><ul><li>vue提供了2个动态监测data的函数，一个是watch，一个是computed。</li><li>watch： 主要监测已经存在的data，处理data变化后的钩子</li><li>computed： 处理一个已存在的data，返回一个data</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/26.png" alt=""></p><h3 id="vue中引入组件以及父子组件的数据交互"><a href="#vue中引入组件以及父子组件的数据交互" class="headerlink" title="vue中引入组件以及父子组件的数据交互"></a>vue中引入组件以及父子组件的数据交互</h3><ul><li>关于组件，任意vue文件你都可以看做一个组件。在项目中我们一般使用的应该都是单文件组件，单文件组件与页面结构无异，是具有完整功能的一个模块。比如一个评论框，你就可以剥离成一个组件，在任意页面文件中引入这个组件。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/27.png" alt=""></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/28.png" alt=""></p><h3 id="vue过滤器"><a href="#vue过滤器" class="headerlink" title="vue过滤器"></a>vue过滤器</h3><ul><li>在有一些业务场景需要对数据进行一些转换，比如后端图片地址的前缀匹配，这个时候filters就派上大用场了。看个例子感受一下。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/29.png" alt=""></p><h3 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h3><ul><li>路由对于spa应用的重要性不言而喻，整个应用的页面关系都是通过路由定义的。我们先来看看一个路由文件大致是什么样子</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/30.png" alt=""></p><h3 id="可监测的全局变量——vuex"><a href="#可监测的全局变量——vuex" class="headerlink" title="可监测的全局变量——vuex"></a>可监测的全局变量——vuex</h3><ul><li>项目开发中，往往我们会有一些全局变量，但是正常全局变量，vue是不能监测的，这个时候vuex就派上用场了。</li></ul><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><ul><li>VueX是适用于在Vue项目开发时使用的状态管理工具。试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步data中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。为此，Vue为这些被多个组件频繁使用的值提供了一个统一管理的工具——VueX。在具有VueX的Vue项目中，我们只需要把这些值定义在VueX中，即可在整个Vue项目的组件中使用。</li><li>通俗的来说，组件可以调用自己的data数据，但是组件与组件之间无法跨组件调用，这时vuex就显示他的作用了，vuex就像一个前端数据库，把数据存储进去，从而使所有的组件的能够使用</li></ul><h4 id="VueX中的核心内容"><a href="#VueX中的核心内容" class="headerlink" title="VueX中的核心内容"></a>VueX中的核心内容</h4><ul><li>state 存放状态<ul><li>state就相当与数据库的数据</li></ul></li><li>mutations state成员操作<ul><li>mutations就相当于增删改查操作</li></ul></li><li>getters 加工state成员给外界</li><li>actions 异步操作<ul><li>异步操作，提交mutations操作</li></ul></li><li>modules 模块化状态管理</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>    npm install vuex --save    安装好vuex后，我们先新建一个store文件夹，存放vuex相关文件</code></pre><h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><pre><code>    import Vue from &#39;vue&#39;;    import Vuex from &#39;vuex&#39;;    import actions from &#39;./actions&#39;    import mutations from &#39;./mutations&#39;    Vue.use(Vuex);    const state = {        username:&#39;&#39;,    //用户名        cartcount: 0    //购物车数量    }    export default new Vuex.Store({        state,        actions,        mutations    })  </code></pre><h4 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h4><pre><code>    //商城Vuex-mutation    export default{        saveUserName(state,username){        //改变数据            state.username = username        },        saveCartCount(state,cartcount){            state.cartcount = cartcount        }    }</code></pre><h4 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h4><pre><code>    //商城Vuex-action    export default{        saveUserName(context,username){        //提交            context.commit(&#39;saveUserName&#39;,username)        },        saveCartCount(context,cartcount){            context.commit(&#39;saveCartCount&#39;,cartcount)        }    }</code></pre><h4 id="将store挂载到当前项目的Vue实例当中去"><a href="#将store挂载到当前项目的Vue实例当中去" class="headerlink" title="将store挂载到当前项目的Vue实例当中去"></a>将store挂载到当前项目的Vue实例当中去</h4><ul><li>main.js,这样就可以全局调用了</li></ul><pre><code>    import store from &#39;./store/index&#39;    new Vue({      store,      router: router,      render: h =&gt; h(App),    }).$mount(&#39;#app&#39;)</code></pre><h4 id="dispatch分配actions任务"><a href="#dispatch分配actions任务" class="headerlink" title="dispatch分配actions任务"></a>dispatch分配actions任务</h4><ul><li>可以在App.vue里使用，这样全局都可以使用这个值了</li></ul><pre><code>      this.$store.dispatch(&#39;saveUserName&#39;,res.username)</code></pre><h4 id="渲染延迟"><a href="#渲染延迟" class="headerlink" title="渲染延迟"></a>渲染延迟</h4><ul><li>当我们拉取数据来渲染页面时会有延迟效果，可能渲染不出来获取的值，我们可以用computed来解决</li></ul><pre><code>    computed: {        username() {          return this.$store.state.username;        },        cartcount() {          return this.$store.state.cartcount;        }      },</code></pre><h4 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h4><ul><li>mapState辅助函数可以帮助我们引用state，与上面的效果是一样的</li></ul><pre><code> import { mapState } from &#39;vuex&#39;; computed: {      ...mapState([&#39;username&#39;, &#39;cartcount&#39;])    },</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习vue的时候，做的一些笔记</title>
      <link href="/2020/05/12/vue/"/>
      <url>/2020/05/12/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本文主要讲述学习vue时的一些指令</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是vue"><a href="#什么是vue" class="headerlink" title="什么是vue"></a>什么是vue</h3><ul><li>Vue (读音 /vjuː/，类似于 <strong>view) 是一套用于构建用户界面的渐进式框架</strong></li><li>vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合</li></ul><h3 id="安装和环境搭建"><a href="#安装和环境搭建" class="headerlink" title="安装和环境搭建"></a>安装和环境搭建</h3><ul><li>这里建议新手去看vue.js的官方文档，熟悉之后可以上手vue-cli脚手架</li></ul><h2 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h2><ul><li>MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel</li><li>m model<ul><li>数据层 Vue 中 数据层 都放在 data 里面</li></ul></li><li>v view 视图<ul><li>Vue 中 view 即 我们的HTML页面</li></ul></li><li>vm （view-model） 控制器 将数据和视图层建立联系<ul><li>vm 即 Vue 的实例 就是 vm</li></ul></li></ul><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul><li>本质就是自定义属性</li><li>Vue中指定都是以 v- 开头</li></ul><h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><ul><li>防止页面加载时出现闪烁问题</li></ul><pre><code>    &lt;html&gt;     &lt;style type=&quot;text/css&quot;&gt;      /*         1、通过属性选择器 选择到 带有属性 v-cloak的标签  让他隐藏     */      [v-cloak]{        /* 元素隐藏    */        display: none;      }      &lt;/style&gt;    &lt;body&gt;      &lt;div id=&quot;app&quot;&gt;        &lt;!-- 2、 让带有插值 语法的   添加 v-cloak 属性              在 数据渲染完场之后，v-cloak 属性会被自动去除，             v-cloak一旦移除也就是没有这个属性了  属性选择器就选择不到该标签             也就是对应的标签会变为可见        --&gt;        &lt;div  v-cloak  &gt;{{msg}}&lt;/div&gt;      &lt;/div&gt;      &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;      &lt;script type=&quot;text/javascript&quot;&gt;        var vm = new Vue({          //  el   指定元素 id 是 app 的元素            el: &#39;#app&#39;,          //  data  里面存储的是数据          data: {            msg: &#39;Hello Vue&#39;          }        });    &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><ul><li>v-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题</li><li>如果数据中有HTML标签会将html标签一并输出</li><li>注意：此处为单向绑定，数据对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值</li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;        &lt;!--              注意:在指令中不要写插值语法  直接写对应的变量名称             在 v-text 中 赋值的时候不要在写 插值语法            一般属性中不加 {{}}  直接写 对应 的数据名         --&gt;        &lt;p v-text=&quot;msg&quot;&gt;&lt;/p&gt;        &lt;p&gt;            &lt;!-- Vue  中只有在标签的 内容中 才用插值语法 --&gt;            {{msg}}        &lt;/p&gt;    &lt;/div&gt;    &lt;script&gt;        new Vue({            el: &#39;#app&#39;,            data: {                msg: &#39;Hello Vue.js&#39;            }        });    &lt;/script&gt;</code></pre><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><ul><li><p>用法和v-text 相似 但是他可以将HTML片段填充到标签中</p></li><li><p>可能有安全问题, 一般只在可信任内容上使用 v-html，永不用在用户提交的内容上</p></li><li><p>它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。</p></li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;    　　&lt;p v-html=&quot;html&quot;&gt;&lt;/p&gt; &lt;!-- 输出：html标签在渲染的时候被解析 --&gt;        &lt;p&gt;{{message}}&lt;/p&gt; &lt;!-- 输出：&lt;span&gt;通过双括号绑定&lt;/span&gt; --&gt;    　　&lt;p v-text=&quot;text&quot;&gt;&lt;/p&gt; &lt;!-- 输出：&lt;span&gt;html标签在渲染的时候被源码输出&lt;/span&gt; --&gt;    &lt;/div&gt;    &lt;script&gt;    　　let app = new Vue({    　　el: &quot;#app&quot;,    　　data: {    　　　　message: &quot;&lt;span&gt;通过双括号绑定&lt;/span&gt;&quot;,    　　　　html: &quot;&lt;span&gt;html标签在渲染的时候被解析&lt;/span&gt;&quot;,    　　　　text: &quot;&lt;span&gt;html标签在渲染的时候被源码输出&lt;/span&gt;&quot;,    　　}     });    &lt;/script&gt;</code></pre><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><ul><li>显示原始信息跳过编译过程</li><li>跳过这个元素和它的子元素的编译过程。</li><li>一些静态的内容不需要编译加这个指令可以加快渲染</li></ul><pre><code>    &lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;        &lt;!--  显示的是{{ this will not be compiled }}  --&gt;    &lt;span v-pre&gt;{{msg}}&lt;/span&gt;       &lt;!--   即使data里面定义了msg这里仍然是显示的{{msg}}  --&gt;    &lt;script&gt;        new Vue({            el: &#39;#app&#39;,            data: {                msg: &#39;Hello Vue.js&#39;            }        });    &lt;/script&gt;</code></pre><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><ul><li>执行一次性的插值【当数据改变时，插值处的内容不会继续更新】</li></ul><pre><code>      &lt;!-- 即使data里面定义了msg 后期我们修改了 仍然显示的是第一次data里面存储的数据即 Hello Vue.js  --&gt;         &lt;span v-once&gt;{{ msg}}&lt;/span&gt;        &lt;script&gt;        new Vue({            el: &#39;#app&#39;,            data: {                msg: &#39;Hello Vue.js&#39;            }        });    &lt;/script&gt;</code></pre><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul><li>v-model是一个指令，限制在input、select、textarea、components中使用</li><li>双向数据绑定：当数据发生变化的时候，视图也就发生变化<br>当视图发生变化的时候，数据也会跟着同步变化</li></ul><pre><code>     &lt;div id=&quot;app&quot;&gt;          &lt;div&gt;{{msg}}&lt;/div&gt;          &lt;div&gt;              当输入框中内容改变的时候，  页面上的msg  会自动更新            &lt;input type=&quot;text&quot; v-model=&#39;msg&#39;&gt;          &lt;/div&gt;      &lt;/div&gt;</code></pre><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul><li>用来绑定事件的</li><li>形式如：v-on:click 缩写为 @click;</li></ul><pre><code>        &lt;div id=&quot;app&quot;&gt;            &lt;div&gt;{{num}}&lt;/div&gt;            &lt;div&gt;                &lt;!-- 如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数 --&gt;                &lt;button v-on:click=&#39;handle1&#39;&gt;点击1&lt;/button&gt;                &lt;!-- 2、如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，                     并且事件对象的名称必须是$event                 --&gt;                &lt;button v-on:click=&#39;handle2(123, 456, $event)&#39;&gt;点击2&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var vm = new Vue({                el: &#39;#app&#39;,                data: {                    num: 0                },                methods: {                    handle1: function(event) {                        console.log(event.target.innerHTML)                    },                    handle2: function(p, p1, event) {                        console.log(p, p1)                        console.log(event.target.innerHTML)                        this.num++;                    }                }            });        &lt;/script&gt;</code></pre><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul><li>在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。</li><li>Vue 不推荐我们操作DOM 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符</li><li>修饰符是由点开头的指令后缀来表示的</li></ul><pre><code>    &lt;!-- 阻止单击事件继续传播 --&gt;    &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;    &lt;!-- 提交事件不再重载页面 --&gt;    &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;    &lt;!-- 修饰符可以串联   即阻止冒泡也阻止默认事件 --&gt;    &lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;    &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;    &lt;!-- 即事件不是从内部元素触发的 --&gt;    &lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;    使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</code></pre><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><ul><li>在做项目中有时会用到键盘事件，在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符</li></ul><pre><code>    &lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;    &lt;input v-on:keyup.13=&quot;submit&quot;&gt;    &lt;!-- -当点击enter 时调用 `vm.submit()` --&gt;    &lt;input v-on:keyup.enter=&quot;submit&quot;&gt;    &lt;!--当点击enter或者space时  时调用 `vm.alertMe()`   --&gt;    &lt;input type=&quot;text&quot; v-on:keyup.enter.space=&quot;alertMe&quot; &gt;    常用的按键修饰符    .enter =&gt;    enter键    .tab =&gt; tab键    .delete (捕获“删除”和“退格”按键) =&gt;  删除键    .esc =&gt; 取消键    .space =&gt;  空格键    .up =&gt;  上    .down =&gt;  下    .left =&gt;  左    .right =&gt;  右    &lt;script&gt;        var vm = new Vue({            el:&quot;#app&quot;,            methods: {                  submit:function(){},                  alertMe:function(){},            }        })    &lt;/script&gt;</code></pre><h3 id="自定义按键修饰符别名"><a href="#自定义按键修饰符别名" class="headerlink" title="自定义按键修饰符别名"></a>自定义按键修饰符别名</h3><ul><li>在Vue中可以通过config.keyCodes自定义按键修饰符别名</li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;        预先定义了keycode 116（即F5）的别名为f5，因此在文字输入框中按下F5，会触发prompt方法        &lt;input type=&quot;text&quot; v-on:keydown.f5=&quot;prompt()&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        Vue.config.keyCodes.f5 = 116;        let app = new Vue({            el: &#39;#app&#39;,            methods: {                prompt: function() {                    alert(&#39;我是 F5！&#39;);                }            }        });    &lt;/script&gt;</code></pre><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul><li>v-bind 指令被用来响应地更新 HTML 属性</li><li>v-bind:href 可以缩写为 :href;</li></ul><pre><code>    &lt;!-- 绑定一个属性 --&gt;    &lt;img v-bind:src=&quot;imageSrc&quot;&gt;    &lt;!-- 缩写 --&gt;    &lt;img :src=&quot;imageSrc&quot;&gt;</code></pre><h4 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h4><ul><li>我们可以给v-bind:class 一个对象，以动态地切换class。</li><li>注意：v-bind:class指令可以与普通的class特性共存</li></ul><pre><code>    1、 v-bind 中支持绑定一个对象         如果绑定的是一个对象 则 键为 对应的类名  值 为对应data中的数据     &lt;!--         HTML最终渲染为 &lt;ul class=&quot;box textColor textSize&quot;&gt;&lt;/ul&gt;        注意：            textColor，textSize  对应的渲染到页面上的CSS类名                isColor，isSize  对应vue data中的数据  如果为true 则对应的类名 渲染到页面上             当 isColor 和 isSize 变化时，class列表将相应的更新，            例如，将isSize改成false，            class列表将变为 &lt;ul class=&quot;box textColor&quot;&gt;&lt;/ul&gt;    --&gt;    &lt;ul class=&quot;box&quot; v-bind:class=&quot;{textColor:isColor, textSize:isSize}&quot;&gt;        &lt;li&gt;学习Vue&lt;/li&gt;        &lt;li&gt;学习Node&lt;/li&gt;        &lt;li&gt;学习React&lt;/li&gt;    &lt;/ul&gt;      &lt;div v-bind:style=&quot;{color:activeColor,fontSize:activeSize}&quot;&gt;对象语法&lt;/div&gt;    &lt;sript&gt;    var vm= new Vue({        el:&#39;.box&#39;,        data:{            isColor:true,            isSize:true，            activeColor:&quot;red&quot;,            activeSize:&quot;25px&quot;,        }    })    &lt;/sript&gt;    &lt;style&gt;        .box{            border:1px dashed #f0f;        }        .textColor{            color:#f00;            background-color:#eef;        }        .textSize{            font-size:30px;            font-weight:bold;        }    &lt;/style&gt;</code></pre><h4 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h4><pre><code>    2、  v-bind 中支持绑定一个数组    数组中classA和 classB 对应为data中的数据    这里的classA  对用data 中的  classA    这里的classB  对用data 中的  classB    &lt;ul class=&quot;box&quot; :class=&quot;[classA, classB]&quot;&gt;        &lt;li&gt;学习Vue&lt;/li&gt;        &lt;li&gt;学习Node&lt;/li&gt;        &lt;li&gt;学习React&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;    var vm= new Vue({        el:&#39;.box&#39;,        data:{            classA:‘textColor‘,            classB:‘textSize‘        }    })    &lt;/script&gt;    &lt;style&gt;        .box{            border:1px dashed #f0f;        }        .textColor{            color:#f00;            background-color:#eef;        }        .textSize{            font-size:30px;            font-weight:bold;        }    &lt;/style&gt;</code></pre><h4 id="绑定对象和绑定数组-的区别"><a href="#绑定对象和绑定数组-的区别" class="headerlink" title="绑定对象和绑定数组 的区别"></a>绑定对象和绑定数组 的区别</h4><ul><li>绑定对象的时候 对象的属性 即要渲染的类名 对象的属性值对应的是 data 中的数据</li><li>绑定数组的时候数组里面存的是data 中的数据</li></ul><h4 id="绑定style"><a href="#绑定style" class="headerlink" title="绑定style"></a>绑定style</h4><ul><li>不过一般很少这么用</li></ul><pre><code>     &lt;div v-bind:style=&quot;styleObject&quot;&gt;绑定样式对象&lt;/div&gt;&#39;    &lt;!-- CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来)    --&gt;     &lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize,background:&#39;red&#39; }&quot;&gt;内联样式&lt;/div&gt;    &lt;!--组语法可以将多个样式对象应用到同一个元素 --&gt;    &lt;div v-bind:style=&quot;[styleObj1, styleObj2]&quot;&gt;&lt;/div&gt;    &lt;script&gt;        new Vue({          el: &#39;#app&#39;,          data: {            styleObject: {              color: &#39;green&#39;,              fontSize: &#39;30px&#39;,              background:&#39;red&#39;            }，            activeColor: &#39;green&#39;,               fontSize: &quot;30px&quot;          },          styleObj1: {                 color: &#39;red&#39;           },           styleObj2: {                fontSize: &#39;30px&#39;           }    &lt;/script&gt;</code></pre><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="v-if-使用场景"><a href="#v-if-使用场景" class="headerlink" title="v-if 使用场景"></a>v-if 使用场景</h4><ul><li>1- 多个元素 通过条件判断展示或者隐藏某个元素。或者多个元素</li><li>2- 进行两个视图之间的切换</li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;            &lt;!--  判断是否加载，如果为真，就加载，否则不加载--&gt;            &lt;span v-if=&quot;flag&quot;&gt;               如果flag为true则显示,false不显示!            &lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;        var vm = new Vue({            el:&quot;#app&quot;,            data:{                flag:true            }        })    &lt;/script&gt;    ----------------------------------------------------------        &lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt;           A        &lt;/div&gt;      &lt;!-- v-else-if紧跟在v-if或v-else-if之后   表示v-if条件不成立时执行--&gt;        &lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt;           B        &lt;/div&gt;        &lt;div v-else-if=&quot;type === &#39;C&#39;&quot;&gt;           C        &lt;/div&gt;      &lt;!-- v-else紧跟在v-if或v-else-if之后--&gt;        &lt;div v-else&gt;           Not A/B/C        &lt;/div&gt;    &lt;script&gt;        new Vue({          el: &#39;#app&#39;,          data: {            type: &#39;C&#39;          }        })    &lt;/script&gt;</code></pre><h4 id="v-show-和-v-if的区别"><a href="#v-show-和-v-if的区别" class="headerlink" title="v-show 和 v-if的区别"></a>v-show 和 v-if的区别</h4><ul><li>v-show本质就是标签display设置为none，控制隐藏<ul><li>v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。</li></ul></li><li>v-if是动态的向DOM树内添加或者删除DOM元素<ul><li>v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件</li></ul></li><li>v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>相比之下， v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。</li></ul><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><ul><li>用于循环的数组里面的值可以是对象，也可以是普通元素</li></ul><pre><code>    &lt;ul id=&quot;example-1&quot;&gt;       &lt;!-- 循环结构-遍历数组          item 是我们自己定义的一个名字  代表数组里面的每一项          items对应的是 data中的数组--&gt;      &lt;li v-for=&quot;item in items&quot;&gt;        {{ item.message }}      &lt;/li&gt;     &lt;/ul&gt;    &lt;script&gt;     new Vue({      el: &#39;#example-1&#39;,      data: {        items: [          { message: &#39;Foo&#39; },          { message: &#39;Bar&#39; }        ]，      }    })    &lt;/script&gt;</code></pre><ul><li>不推荐同时使用 v-if 和 v-for</li><li>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。</li></ul><pre><code>       &lt;!--  循环结构-遍历对象            v 代表   对象的value            k  代表对象的 键             i  代表索引            ---&gt;          &lt;div v-if=&#39;v==13&#39; v-for=&#39;(v,k,i) in obj&#39;&gt;{{v + '---' + k + '---' + i}}&lt;/div&gt;    &lt;script&gt;     new Vue({      el: &#39;#example-1&#39;,      data: {        items: [          { message: &#39;Foo&#39; },          { message: &#39;Bar&#39; }        ]，        obj: {            uname: &#39;zhangsan&#39;,            age: 13,            gender: &#39;female&#39;        }      }    })    &lt;/script&gt;</code></pre><ul><li>key 的作用<ul><li>key来给每个节点做一个唯一标识</li><li>key的作用主要是为了高效的更新虚拟DOM</li></ul></li></ul><pre><code>    &lt;ul&gt;      &lt;li v-for=&quot;(item,index) in items&quot; :key=&quot;index&quot;&gt;...&lt;/li&gt;    &lt;/ul&gt;</code></pre><h3 id="案例选项卡"><a href="#案例选项卡" class="headerlink" title="案例选项卡"></a>案例选项卡</h3><h4 id="1、-HTML-结构"><a href="#1、-HTML-结构" class="headerlink" title="1、 HTML 结构"></a>1、 HTML 结构</h4><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;tab&quot;&gt;        &lt;!--  tab栏  --&gt;        &lt;ul&gt;            &lt;li class=&quot;active&quot;&gt;apple&lt;/li&gt;            &lt;li class=&quot;&quot;&gt;orange&lt;/li&gt;            &lt;li class=&quot;&quot;&gt;lemon&lt;/li&gt;        &lt;/ul&gt;          &lt;!--  对应显示的图片 --&gt;        &lt;div class=&quot;current&quot;&gt;&lt;img src=&quot;img/apple.png&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;&quot;&gt;&lt;img src=&quot;img/orange.png&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;&quot;&gt;&lt;img src=&quot;img/lemon.png&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h4 id="2、-提供的数据"><a href="#2、-提供的数据" class="headerlink" title="2、 提供的数据"></a>2、 提供的数据</h4><pre><code>     list: [{                id: 1,                title: &#39;apple&#39;,                path: &#39;img/apple.png&#39;            }, {                id: 2,                title: &#39;orange&#39;,                path: &#39;img/orange.png&#39;            }, {                id: 3,                title: &#39;lemon&#39;,                path: &#39;img/lemon.png&#39;            }]</code></pre><h4 id="3、-把数据渲染到页面"><a href="#3、-把数据渲染到页面" class="headerlink" title="3、 把数据渲染到页面"></a>3、 把数据渲染到页面</h4><ul><li>把tab栏 中的数替换到页面上<ul><li>把 data 中 title 利用 v-for 循环渲染到页面上</li><li>把 data 中 path利用 v-for 循环渲染到页面上</li></ul></li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;        &lt;div class=&quot;tab&quot;&gt;              &lt;ul&gt;                  &lt;!--                      1、绑定key的作用 提高Vue的性能                     2、 key 需要是唯一的标识 所以需要使用id， 也可以使用index ，                        index 也是唯一的                     3、 item 是 数组中对应的每一项                      4、 index 是 每一项的 索引                --&gt;                   &lt;li :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;&gt;{{item.title}}&lt;/li&gt;              &lt;/ul&gt;              &lt;div  :key=&#39;item.id&#39; v-for=&#39;(item, index) in list&#39;&gt;                    &lt;!-- :  是 v-bind 的简写   绑定属性使用 v-bind --&gt;                    &lt;img :src=&quot;item.path&quot;&gt;              &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        new  Vue({            //  指定 操作元素 是 id 为app 的             el: &#39;#app&#39;,                data: {                    list: [{                        id: 1,                        title: &#39;apple&#39;,                        path: &#39;img/apple.png&#39;                    }, {                        id: 2,                        title: &#39;orange&#39;,                        path: &#39;img/orange.png&#39;                    }, {                        id: 3,                        title: &#39;lemon&#39;,                        path: &#39;img/lemon.png&#39;                    }]                }        })    &lt;/script&gt;</code></pre><h4 id="4、-给每一个tab栏添加事件-并让选中的高亮"><a href="#4、-给每一个tab栏添加事件-并让选中的高亮" class="headerlink" title="4、 给每一个tab栏添加事件,并让选中的高亮"></a>4、 给每一个tab栏添加事件,并让选中的高亮</h4><ul><li>4.1 、让默认的第一项tab栏高亮<ul><li>tab栏高亮 通过添加类名active 来实现 （CSS active 的样式已经提前写好）<ul><li>在data 中定义一个 默认的 索引 currentIndex 为 0</li><li>给第一个li 添加 active 的类名<ul><li>通过动态绑定class 来实现 第一个li 的索引为 0 和 currentIndex 的值刚好相等</li><li>currentIndex === index 如果相等 则添加类名 active 否则 添加 空类名</li></ul></li></ul></li></ul></li></ul><ul><li>4.2 、让默认的第一项tab栏对应的div 显示<ul><li>实现思路 和 第一个 tab 实现思路一样 只不过 这里控制第一个div 显示的类名是 current</li></ul></li></ul><pre><code>      &lt;ul&gt;           &lt;!-- 动态绑定class   有 active   类名高亮  无 active   不高亮--&gt;           &lt;li  :class=&#39;currentIndex==index?&quot;active&quot;:&quot;&quot;&#39;               :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;               &gt;{{item.title}}&lt;/li&gt;      &lt;/ul&gt;        &lt;!-- 动态绑定class   有 current  类名显示  无 current  隐藏--&gt;      &lt;div :class=&#39;currentIndex==index?&quot;current&quot;:&quot;&quot;&#39;            :key=&#39;item.id&#39; v-for=&#39;(item, index) in list&#39;&gt;            &lt;!-- :  是 v-bind 的简写   绑定属性使用 v-bind --&gt;            &lt;img :src=&quot;item.path&quot;&gt;      &lt;/div&gt;    &lt;script&gt;        new  Vue({            el: &#39;#app&#39;,                data: {                    currentIndex: 0, // 选项卡当前的索引  默认为 0                      list: [{                        id: 1,                        title: &#39;apple&#39;,                        path: &#39;img/apple.png&#39;                    }, {                        id: 2,                        title: &#39;orange&#39;,                        path: &#39;img/orange.png&#39;                    }, {                        id: 3,                        title: &#39;lemon&#39;,                        path: &#39;img/lemon.png&#39;                    }]                }        })    &lt;/script&gt;</code></pre><ul><li>4.3 、点击每一个tab栏 当前的高亮 其他的取消高亮<ul><li>给每一个li添加点击事件</li><li>让当前的索引 index 和 当前 currentIndex 的 值 进项比较</li><li>如果相等 则当前li 添加active 类名 当前的 li 高亮 当前对应索引的 div 添加 current 当前div 显示 其他隐藏</li></ul></li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;        &lt;div class=&quot;tab&quot;&gt;            &lt;ul&gt;                &lt;!--  通过v-on 添加点击事件   需要把当前li 的索引传过去                 --&gt;                &lt;li v-on:click=&#39;change(index)&#39;                                                   :class=&#39;currentIndex==index?&quot;active&quot;:&quot;&quot;&#39;                                       :key=&#39;item.id&#39;                     v-for=&#39;(item,index) in list&#39;&gt;{{item.title}}&lt;/li&gt;            &lt;/ul&gt;            &lt;div :class=&#39;currentIndex==index?&quot;current&quot;:&quot;&quot;&#39;                  :key=&#39;item.id&#39; v-for=&#39;(item, index) in list&#39;&gt;                &lt;img :src=&quot;item.path&quot;&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        new  Vue({            el: &#39;#app&#39;,                data: {                    currentIndex: 0, // 选项卡当前的索引  默认为 0                      list: [{                        id: 1,                        title: &#39;apple&#39;,                        path: &#39;img/apple.png&#39;                    }, {                        id: 2,                        title: &#39;orange&#39;,                        path: &#39;img/orange.png&#39;                    }, {                        id: 3,                        title: &#39;lemon&#39;,                        path: &#39;img/lemon.png&#39;                    }]                },                methods: {                    change: function(index) {                        // 通过传入过来的索引来让当前的  currentIndex  和点击的index 值 相等                         //  从而实现 控制类名                            this.currentIndex = index;                    }                }        })    &lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element-ui的使用</title>
      <link href="/2020/05/12/element-ui/"/>
      <url>/2020/05/12/element-ui/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h3><ul><li>推荐使用 npm 的方式安装，它能更好地和 webpack 打包工具配合使用。</li></ul><pre><code>    npm i element-ui -S</code></pre><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ul><li>目前可以通过 unpkg.com/element-ui 获取到最新版本的资源，在页面上引入 js 和 css 文件即可开始使用。</li></ul><pre><code>    &lt;!-- 引入样式 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;    &lt;!-- 引入组件库 --&gt;    &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="引入Element"><a href="#引入Element" class="headerlink" title="引入Element"></a>引入Element</h3><ul><li>你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。</li></ul><h3 id="完整引入"><a href="#完整引入" class="headerlink" title="完整引入"></a>完整引入</h3><ul><li>你可以在main.js中加入以下内容</li></ul><pre><code>    import ElementUI from &#39;element-ui&#39;;    import &#39;element-ui/lib/theme-chalk/index.css&#39;;    Vue.use(ElementUI);</code></pre><ul><li>以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。</li><li>如果在需要用到大部分组件的时候可以完整引入，只是用到少部分软件建议按需引入，可以减少项目体积</li></ul><h3 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h3><ul><li><p>借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。</p></li><li><p>首先，安装 babel-plugin-component：</p></li></ul><pre><code>    npm install babel-plugin-component -D</code></pre><ul><li>这里官方文档里面是将 .babelrc 修改为：</li></ul><pre><code>    {      &quot;presets&quot;: [[&quot;es2015&quot;, { &quot;modules&quot;: false }]],      &quot;plugins&quot;: [        [          &quot;component&quot;,          {            &quot;libraryName&quot;: &quot;element-ui&quot;,            &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;          }        ]      ]    }</code></pre><ul><li>但是我们可能没有，只有一个babel.config.js,里面的内容比起上面只能解析es2015要强大很多，当然也包括上面的es2015</li></ul><p>“presets”: [<br>    ‘@vue/cli-plugin-babel/preset’<br>  ],</p><ul><li>所以我们只需把这个加入babel.config.js中</li></ul><pre><code>    &quot;plugins&quot;: [        [          &quot;component&quot;,          {            &quot;libraryName&quot;: &quot;element-ui&quot;,            &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;          }        ]      ]</code></pre><ul><li>接下来，如果你只希望引入部分组件，比如 Button 和 Select，那么需要在 main.js 中写入以下内容：</li></ul><pre><code>    import { Button, Select } from &#39;element-ui&#39;;    Vue.component(Button.name, Button);    Vue.component(Select.name, Select);    /* 或写为     * Vue.use(Button)     * Vue.use(Select)     */</code></pre><h3 id="Message组件"><a href="#Message组件" class="headerlink" title="Message组件"></a>Message组件</h3><h4 id="全局使用"><a href="#全局使用" class="headerlink" title="全局使用"></a>全局使用</h4><ul><li>如果每个文件都要import导入那就太麻烦了</li><li>我们用到了Message组件，就以Message组件为例,写入main.js中</li></ul><pre><code>    import { Message } from &#39;element-ui&#39;    Vue.prototype.$message = Message;</code></pre><ul><li>这样我们在全局要是哟个Message组件就可以这样</li></ul><pre><code>    this.$message.info(&#39;消息&#39;)    this.$message.warning(&#39;警告&#39;)    this.$message.success(&#39;成功&#39;)    this.$message.error(&#39;错误&#39;)</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><pre><code>    getOrderList() {          this.loading = true       //加载loading          this.axios            .get(&quot;/orders&quot;,{              params:{                pageSize: 5,        //每页跳蛛                pageNum:this.pageNum    //当前页数              }            })            .then(res =&gt; {              this.loading = false;              this.list = res.list;     //当前页面数据              this.total = res.total;   //总条数            })            .catch(() =&gt; {              this.loading = false;            });</code></pre><h3 id="Pagination组件"><a href="#Pagination组件" class="headerlink" title="Pagination组件"></a>Pagination组件</h3><ul><li>做一个应用不可能一个页面都能把所有数据加载完，所以我们要实现分页效果，一页只实现少量的数据，可以分很多页</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>注意，这是一个组件，要在components中引入，这里的语法可能不太好理解，Pagination.name就相当于<el-pagination></el-pagination>，这个是在html中引入的组件</li></ul><pre><code>    import { Pagination } from &quot;element-ui&quot;;    components: {        [Pagination.name]: Pagination      }     &lt;el-pagination class=&quot;pagination&quot; :pageSize=&quot;pageSize&quot; background layout=&quot;prev, pager, next&quot; :total=&quot;total&quot; @current-change=&quot;handelchange&quot;&gt;&lt;/el-pagination&gt;</code></pre><ul><li>这里面的组件包含很多属性，pageSize就是页面的大小可以包含几条数据，total表示总数据，注意属性的调用可能有驼峰命名法，比如文档中调用属性page-size会出错，你要改成pageSize</li><li>current-change是事件名称，page页改变的时候会触发，回调参数是当前页数</li></ul><pre><code>     //点击触发事件，会有一个回调参数，这个回调参数就是当前的页数        handelchange(pageNum){          this.pageNum = pageNum          this.getOrderList()        }</code></pre><h2 id="加载更多"><a href="#加载更多" class="headerlink" title="加载更多"></a>加载更多</h2><h3 id="Button组件"><a href="#Button组件" class="headerlink" title="Button组件"></a>Button组件</h3><ul><li>点击Button组件会加载更多数据</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li>组件的loading属性是显示加载loading的，需要动态绑定，在加载时显示，加载完成后关闭，绑定到getOrderList</li></ul><pre><code>    import { Button } from &quot;element-ui&quot;;    components: {        [Button.name]: Button,      }    &lt;el-button type=&quot;primary&quot; :loading=&quot;loading&quot; @click=&quot;loadMore&quot;&gt;加载更多&lt;/el-button&gt;</code></pre><ul><li>loadMore事件是加载更多</li></ul><pre><code>    loadMore(){          this.pageNum++    //每点击一次页数加1          this.getOrderList()        }</code></pre><ul><li>我们发现返回的数据没有拼接，只有请求的到数据，我们要把它拼接</li></ul><pre><code>    this.list = this.list.concat(res.list);   //把返回的数据拼接到一起</code></pre>]]></content>
      
      
      <categories>
          
          <category> element-ui </category>
          
      </categories>
      
      
        <tags>
            
            <tag> element-ui </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot安全（spring security）</title>
      <link href="/2020/02/14/springboot-yu-an-quan/"/>
      <url>/2020/02/14/springboot-yu-an-quan/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot与安全（spring-security）"><a href="#SpringBoot与安全（spring-security）" class="headerlink" title="SpringBoot与安全（spring security）"></a>SpringBoot与安全（spring security）</h1><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>比较常见的安全框架有：Apache的shiro、Spring Security等等，相信用shiro的用户群体更多，而security功能更多一些。<br>Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型。他可以实现强大的web安全控制。对于安全控制，我们仅需引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理。几个类：</p><ul><li>WebSecurityConfigurerAdapter：自定义Security策略</li><li>AuthenticationManagerBuilder：自定义认证策略</li><li>@EnableWebSecurity：开启WebSecurity模式</li></ul><ul><li>应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两个主要区域是Spring Security 的两个目标。</li></ul><ul><li>“认证”（Authentication），是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统）。</li></ul><ul><li><p>“授权”（Authorization）指确定一个主体是否允许在你的应用程序执行一个动作的过程。为了抵达需要授权的店，主体的身份已经有认证过程建立。</p></li><li><p>这个概念是通用的而不只在Spring Security中。</p></li></ul><h2 id="Web和安全"><a href="#Web和安全" class="headerlink" title="Web和安全"></a>Web和安全</h2><h3 id="登陆注销"><a href="#登陆注销" class="headerlink" title="登陆注销"></a>登陆注销</h3><ul><li>HttpSecurity配置登陆、注销功能</li></ul><ul><li>Thymeleaf提供的SpringSecurity标签支持<ul><li>需要引入thymeleaf-extras-springsecurity5</li><li><html xmlns:th="http://www.thymeleaf.org"xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurit></li><li>sec:authentication=“name”获得当前用户的用户名</li><li>sec:authorize=“hasRole(‘ADMIN’)”当前用户必须拥有ADMIN权限时才会显示标签内容</li><li>sec:authentication=”principal.authorities” 获取当前用户的权限级别</li><li>sec:authorize=”!isAuthenticated()” 用户没登陆才会显示的标签内容</li><li>sec:authorize=”isAuthenticated()” 用户登陆才会显示的标签内容</li></ul></li></ul><ul><li>remember me<ul><li>表单添加remember-me的checkbox</li><li>配置启用remember-me功能</li></ul></li></ul><ul><li>CSRF（Cross-site request forgery）跨站请求伪造<ul><li>HttpSecurity启用csrf功能，会为表单添加_csrf的值，提交携带来预防CSRF；</li></ul></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;thymeleaf.version&gt;3.0.11.RELEASE&lt;/thymeleaf.version&gt;        &lt;!--布局功能的支持程序  thymeleaf3的主程序  layout2版本以上--&gt;        &lt;thymeleaf-layout-dialect.version&gt;2.4.1&lt;/thymeleaf-layout-dialect.version&gt;        &lt;thymeleaf-extras-springsecurity.version&gt;3.0.4.RELEASE&lt;/thymeleaf-extras-springsecurity.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;        &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><h3 id="测试页面"><a href="#测试页面" class="headerlink" title="测试页面"></a>测试页面</h3><ul><li>welcome.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;h1 align=&quot;center&quot;&gt;欢迎光临武林秘籍管理系统&lt;/h1&gt;    &lt;h2 align=&quot;center&quot;&gt;游客您好，如果想查看武林秘籍 &lt;a th:href=&quot;@{/login}&quot;&gt;请登录&lt;/a&gt;&lt;/h2&gt;    &lt;hr&gt;    &lt;h3&gt;普通武功秘籍&lt;/h3&gt;    &lt;ul&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level1/1}&quot;&gt;罗汉拳&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level1/2}&quot;&gt;武当长拳&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level1/3}&quot;&gt;全真剑法&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;高级武功秘籍&lt;/h3&gt;    &lt;ul&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level2/1}&quot;&gt;太极拳&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level2/2}&quot;&gt;七伤拳&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level2/3}&quot;&gt;梯云纵&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;绝世武功秘籍&lt;/h3&gt;    &lt;ul&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level3/1}&quot;&gt;葵花宝典&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level3/2}&quot;&gt;龟派气功&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level3/3}&quot;&gt;独孤九剑&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><ul><li>login.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;h1 align=&quot;center&quot;&gt;欢迎登陆武林秘籍管理系统&lt;/h1&gt;    &lt;hr&gt;    &lt;div align=&quot;center&quot;&gt;    &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    用户名:&lt;input name=&quot;&quot;/&gt;&lt;br&gt;    密码:&lt;input name=&quot;&quot;&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;    &lt;/form&gt;    &lt;/div&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><h4 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h4><ul><li>1.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a th:href=&quot;@{/}&quot;&gt;返回&lt;/a&gt;        &lt;h1&gt;罗汉拳&lt;/h1&gt;        &lt;p&gt;罗汉拳站当央,打起来不要慌&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><ul><li>2.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a th:href=&quot;@{/}&quot;&gt;返回&lt;/a&gt;        &lt;h1&gt;罗汉拳&lt;/h1&gt;        &lt;p&gt;罗汉拳站当央,打起来不要慌&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><ul><li>3.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a th:href=&quot;@{/}&quot;&gt;返回&lt;/a&gt;        &lt;h1&gt;罗汉拳&lt;/h1&gt;        &lt;p&gt;罗汉拳站当央,打起来不要慌&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><ul><li>level2/3和level1基本一致，页面架构如下</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/18.png" alt=""></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>KungfuController.java</li></ul><pre><code>    package com.atguigu.security.controller;    import org.springframework.stereotype.Controller;    import org.springframework.web.bind.annotation.GetMapping;    import org.springframework.web.bind.annotation.PathVariable;    @Controller    public class KungfuController {        private final String PREFIX = &quot;pages/&quot;;        /**        * 欢迎页        * @return        */        @GetMapping(&quot;/&quot;)        public String index() {            return &quot;welcome&quot;;        }        /**        * 登陆页        * @return        */        @GetMapping(&quot;/userlogin&quot;)        public String loginPage() {            return PREFIX+&quot;login&quot;;        }        /**        * level1页面映射        * @param path        * @return        */        @GetMapping(&quot;/level1/{path}&quot;)        public String level1(@PathVariable(&quot;path&quot;)String path) {            return PREFIX+&quot;level1/&quot;+path;        }        /**        * level2页面映射        * @param path        * @return        */        @GetMapping(&quot;/level2/{path}&quot;)        public String level2(@PathVariable(&quot;path&quot;)String path) {            return PREFIX+&quot;level2/&quot;+path;        }        /**        * level3页面映射        * @param path        * @return        */        @GetMapping(&quot;/level3/{path}&quot;)        public String level3(@PathVariable(&quot;path&quot;)String path) {            return PREFIX+&quot;level3/&quot;+path;        }    }</code></pre><ul><li>访问:localhost:8080</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/19.png" alt=""></p><h3 id="配置授权"><a href="#配置授权" class="headerlink" title="配置授权"></a>配置授权</h3><ul><li>pom文件引入security模块</li></ul><pre><code>    &lt;dependency&gt;    　　&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    　　&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><ul><li>现在所有人都能访问武功秘籍，这时我们要设置一下权限</li></ul><pre><code>    @EnableWebSecurity    public class MySercurityConfig extends WebSecurityConfigurerAdapter {        public void configure(HttpSecurity http) throws Exception {    //定制请求的授权规则    http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()            .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;)            .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;)            .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;VIP3&quot;);    }</code></pre><p>我们现在访问罗汉拳，将会提示403，访问拒绝。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/21.png" alt=""></p><h3 id="开启登陆功能"><a href="#开启登陆功能" class="headerlink" title="开启登陆功能"></a>开启登陆功能</h3><p>这是因为我们还没有登陆访问，加入如下的这段代码，让它为我们自动配置，只要不符合等级规则，就跳转到/login的登录页</p><pre><code>    //开启自动配置的登陆功能，效果，如果没有登陆，没有权限将会来到登陆页面    http.formLogin();    //1./login来到登陆页    //2.重定向来到/login?error表示登陆失败    //3.更多的详细规定</code></pre><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/20.png" alt=""></p><ul><li>登陆成功，访问页面</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/22.png" alt=""></p><h3 id="定义认证功能"><a href="#定义认证功能" class="headerlink" title="定义认证功能"></a>定义认证功能</h3><ul><li>讲我们拥有的用户信息对应匹配规则，然后使用这些账户登录试一下~（这里为了简单说明，我用的是内存保存，当然，可以使用“auth.jdbc…..”来进行数据库的链接使用）</li></ul><pre><code>    //定义认证功能    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        //这里可以改进连数据库        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())                .withUser(&quot;zhangsan&quot;).password(passwordEncoder.encode(&quot;heihei&quot;)).roles(&quot;VIP1&quot;, &quot;VIP2&quot;)                .and()                .withUser(&quot;lisi&quot;).password(passwordEncoder.encode(&quot;123456&quot;)).roles(&quot;VIP2&quot;, &quot;VIP3&quot;)                .and()                .withUser(&quot;wangwu&quot;).password(passwordEncoder.encode(&quot;12456&quot;)).roles(&quot;VIP1&quot;, &quot;VIP3&quot;);</code></pre><h3 id="开启注销功能"><a href="#开启注销功能" class="headerlink" title="开启注销功能"></a>开启注销功能</h3><ul><li>welcome.html</li></ul><pre><code>    &lt;!-- 把这段代码放到你想要的位置，比如登录后边边 --&gt;    &lt;form th:action=&quot;@{/logout}&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;submit&quot; value=&quot;注销&quot;/&gt;    &lt;/form&gt;</code></pre><ul><li>开启自动配置的注销功能</li></ul><pre><code>    http.logout().logoutSuccessUrl(&quot;/&quot;);    //注销成功后去初始页面    //1.访问/logout 表示用户注销，清空session    //2.退出成功将来到/login?logout页面</code></pre><h3 id="优化页面"><a href="#优化页面" class="headerlink" title="优化页面"></a>优化页面</h3><ul><li>让不同用户看到首页展示不同，没有登录的呢，就看不到具体内容。</li><li>pom文件引入springsecurity5；</li></ul><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;        &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><ul><li>在html中改造一下，引入springsecurity5（加两个div做判断是否授权-sec:authorize），如果没有认证（!isAuthenticated()）就展示游客请登录，如果认证了就展示角色信息；读取角色信息（sec:authentication）；</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;          xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity4&quot;&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;        &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;h1 align=&quot;center&quot;&gt;欢迎光临武林秘籍管理系统&lt;/h1&gt;    &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt;        &lt;h2 align=&quot;center&quot;&gt;游客您好，如果想查看武林秘籍 &lt;a th:href=&quot;@{/login}&quot;&gt;请登录&lt;/a&gt;&lt;/h2&gt;    &lt;/div&gt;    &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;        &lt;h2&gt;&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt;，您好，您的角色有:            &lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;&lt;/h2&gt;        &lt;form th:action=&quot;@{/logout}&quot; method=&quot;post&quot;&gt;            &lt;input type=&quot;submit&quot; value=&quot;注销&quot;/&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;hr&gt;    &lt;div sec:authorize=&quot;hasRole(&#39;VIP1&#39;)&quot;&gt;        &lt;h3&gt;普通武功秘籍&lt;/h3&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level1/1}&quot;&gt;罗汉拳&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level1/2}&quot;&gt;武当长拳&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level1/3}&quot;&gt;全真剑法&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div sec:authorize=&quot;hasRole(&#39;VIP2&#39;)&quot;&gt;        &lt;h3&gt;高级武功秘籍&lt;/h3&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level2/1}&quot;&gt;太极拳&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level2/2}&quot;&gt;七伤拳&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level2/3}&quot;&gt;梯云纵&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div sec:authorize=&quot;hasRole(&#39;VIP3&#39;)&quot;&gt;        &lt;h3&gt;绝世武功秘籍&lt;/h3&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level3/1}&quot;&gt;葵花宝典&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level3/2}&quot;&gt;龟派气功&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level3/3}&quot;&gt;独孤九剑&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><p>再次启动就会发现差别</p><ul><li>没登陆状态，只会显示一个请登录页面</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/24.png" alt=""></p><ul><li>登陆状态，成功会显示注销，用户名字，权限等信息</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/23.png" alt=""></p><h3 id="完善页面"><a href="#完善页面" class="headerlink" title="完善页面"></a>完善页面</h3><ul><li>登陆的时候进入我们自己设计的页面，并用用户名和密码作关联<br>http.formLogin().usernameParameter(“user”).passwordParameter(“pwd”).loginPage(“/userlogin”);</li></ul><ul><li><p>welcome.html优化，将登录请求变成userlogin请求；</p></li><li><p>login.html</p></li></ul><pre><code>    &lt;div align=&quot;center&quot;&gt;        &lt;form th:action=&quot;@{/userlogin}&quot; method=&quot;post&quot;&gt;            用户名:&lt;input name=&quot;user&quot;/&gt;&lt;br&gt;            密码:&lt;input name=&quot;pwd&quot;&gt;&lt;br/&gt;            &lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt;记住我&lt;br/&gt;            &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;        &lt;/form&gt;    &lt;/div&gt;</code></pre><ul><li>remeberme优化<br>http.rememberMe().rememberMeParameter(“remember”);</li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot消息(JMS、AMQP、RabbitMQ)</title>
      <link href="/2020/02/11/sprintboot-yu-xiao-xi/"/>
      <url>/2020/02/11/sprintboot-yu-xiao-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot与消息-JMS、AMQP、RabbitMQ"><a href="#SpringBoot与消息-JMS、AMQP、RabbitMQ" class="headerlink" title="SpringBoot与消息(JMS、AMQP、RabbitMQ)"></a>SpringBoot与消息(JMS、AMQP、RabbitMQ)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>1.大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力</li></ul><ul><li><p>2.消息服务中两个重要概念：</p><ul><li>消息代理（message broker）和目的地（destination）<br>当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递指定目的地。</li></ul></li><li><p>3.消息队列主要有两种形式的目的地</p><p>  1.队列（queue）：点对点消息通信（point-to-point）</p><p>  2.主题（topic）：发布（publish）/订阅（subscribe）消息通信</p></li><li><p>4.点对点式：</p><ul><li><p>消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列</p></li><li><p>消息只有唯一的发送者和接受者，但并不是说只能有一个接收者</p></li></ul></li><li><p>5.发布订阅式：</p><ul><li>发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息</li></ul></li><li><p>6.JMS（Java Message Service）JAVA消息服务：</p><ul><li>基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现</li></ul></li><li><p>7.AMQP（Advanced Message Queuing Protocol）</p><ul><li>高级消息队列协议，也是一个消息代理的规范，兼容JMS<br>RabbitMQ是AMQP的实现</li></ul></li><li><p>8.Spring支持</p><ul><li>spring-jms提供了对JMS的支持</li><li>spring-rabbit提供了对AMQP的支持</li><li>需要ConnectionFactory的实现来连接消息代理</li><li>提供JmsTemplate、RabbitTemplate来发送消息</li><li>@JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息</li><li>@EnableJms、@EnableRabbit开启支持</li></ul></li><li><p>9.Spring Boot自动配置</p><ul><li>JmsAutoConfiguration</li><li>RabbitAutoConfiguration</li></ul></li></ul><h2 id="rabbitmq简介"><a href="#rabbitmq简介" class="headerlink" title="rabbitmq简介"></a>rabbitmq简介</h2><ul><li>RabbitMQ简介：</li></ul><p>RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>Message</li></ul><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、pririty（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持性存储）等。</p><ul><li>Publisher</li></ul><p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p><ul><li>Exchange</li></ul><p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。<br>Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别</p><ul><li>Queue</li></ul><p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><ul><li>Binding</li></ul><p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。<br>Exchange 和Queue的绑定可以是多对多的关系。</p><ul><li>Connection</li></ul><p>网络连接，比如一个TCP连接。</p><ul><li>Channel</li></ul><p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><ul><li>Consumer</li></ul><p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><ul><li>Virtual Host</li></ul><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><ul><li>Broker</li></ul><p>表示消息队列服务器实体</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/1.png" alt=""></p><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><ul><li>AMQP 中的消息路由</li></ul><p>AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/2.png" alt=""></p><h3 id="exchange类型"><a href="#exchange类型" class="headerlink" title="exchange类型"></a>exchange类型</h3><ul><li>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键， headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</li></ul><ul><li>Direct Exchange</li></ul><p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/3.png" alt=""></p><ul><li>Fanout Exchange</li></ul><p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/4.png" alt=""></p><ul><li>Topic Exchange</li></ul><p>topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“<em>”。#匹配0个或多个单词，</em>匹配一个单词。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/5.png" alt=""></p><h2 id="docker快速安装"><a href="#docker快速安装" class="headerlink" title="docker快速安装"></a>docker快速安装</h2><ul><li><p>1.拉取镜像</p><ul><li><p>指定版本，该版本包含了web控制页面</p><p>docker pull rabbitmq:3.8.2-management</p></li></ul></li><li><p>2.运行镜像</p><ul><li><p>方式一：默认guest 用户，密码也是 guest</p><p>docker run -d –hostname my-rabbit –name rabbit -p 15672:15672 -p 5672:5672 rabbitmq:3.8.2-management</p></li><li><p>方式二：设置用户名和密码</p><p>docker run -d –hostname my-rabbit –name rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:3.8.2-management</p></li></ul></li><li><p>3.访问url页面</p></li></ul><p><a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/6.jpg" alt=""></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>1.运行流程</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/8.jpg" alt=""></p><ul><li>2.添加交换器</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/7.jpg" alt=""></p><ul><li>3.添加绑定规则</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/9.jpg" alt=""></p><ul><li>4.发布消息</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/10.jpg" alt=""></p><ul><li>5.获取消息</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/11.jpg" alt=""></p><h2 id="整合rabbitmq"><a href="#整合rabbitmq" class="headerlink" title="整合rabbitmq"></a>整合rabbitmq</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>    &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;                &lt;scope&gt;test&lt;/scope&gt;                &lt;exclusions&gt;                    &lt;exclusion&gt;                        &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                        &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                    &lt;/exclusion&gt;                &lt;/exclusions&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;                &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;                &lt;scope&gt;test&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;</code></pre><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>application.properties</p><pre><code>    spring.rabbitmq.host=192.168.206.131    #linux主机地址    spring.rabbitmq.username=guest    spring.rabbitmq.password=guest    spring.rabbitmq.port=5672</code></pre><h3 id="测试rabbitmq"><a href="#测试rabbitmq" class="headerlink" title="测试rabbitmq"></a>测试rabbitmq</h3><ul><li>RabbitTemplate：消息发送处理组件</li></ul><h4 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h4><pre><code>    @Autowired    RabbitTemplate rabbitTemplate;    /**     * 1.单播（点对点）     */    @Test    void test01() {        //需要自己构造一个Message，定义消息体和消息头        //rabbitTemplate.send(exchange,routekey,message);        //object默认当成消息体，只需要传入要发送的对象，自动序列化发送给rabbitmq        //rabbitTemplate.convertAndSend(exchange,routekey,message);        Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,&quot;这是第一条消息&quot;);        map.put(&quot;data&quot;, Arrays.asList(&quot;helloworld&quot;,123,true));        //对象被默认序列化发送出去，是java的序列化规则，我们需要把它转换为json规则        //rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;atguigu.news&quot;,map);        rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;atguigu.news&quot;,map);    }    /**         * 广播（所有键全部发送）         */        @Test        public void test02(){            rabbitTemplate.convertAndSend(&quot;exchange.fanout&quot;,&quot;&quot;,new Book(&quot;上海堡垒&quot;,&quot;江南&quot;));        }</code></pre><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ul><li>对象被默认序列化发送出去，是java的序列化规则，我们需要把它转换为json规则</li></ul><p>MyAMQPConfig</p><pre><code>    //序列化配置    @Configuration    public class MyAMQPConfig {        @Bean        public MessageConverter messageConverter(){                return new Jackson2JsonMessageConverter();        }    }</code></pre><h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><pre><code>    //获取消息，获取完之后就从消息队列里删除        @Test        public void receive(){            Object o = rabbitTemplate.receiveAndConvert(&quot;atguigu.emps&quot;);            System.out.println(o.getClass());            System.out.println(o);        }</code></pre><h3 id="监听机制"><a href="#监听机制" class="headerlink" title="监听机制"></a>监听机制</h3><ul><li><p>@RabbitListener + @EnableRabbit(放于主程序前)    </p><p>  //开启基于注解的rabbitmq监听机制</p></li></ul><pre><code>    @Service    public class BookService {        @RabbitListener(queues = &quot;atguigu.news&quot;)    //参数类型是数组，可以监听多个消息队列        //只要这个消息队列中有消息进来，这个方法就会进行        public void receive(Object o){            System.out.println(&quot;收到消息&quot;+o);        }    }</code></pre><h3 id="amqpadmin"><a href="#amqpadmin" class="headerlink" title="amqpadmin"></a>amqpadmin</h3><ul><li>AmqpAdmin</li></ul><p>rabbitmq系统管理功能组件</p><ul><li>功能</li></ul><p>创建和删除Queue，Exchange，Binding</p><pre><code>    @Autowired    AmqpAdmin amqpAdmin;    /**     * declare是创建，delete是删除     * destination：目的地（哪个消息队列）     * Binding.DestinationType.QUEUE  绑定的类型是queue     * durable:是否持久化     * routingkey：路由键     */    @Test    public void create(){        //创建exchange        amqpAdmin.declareExchange(new DirectExchange(&quot;amqpadmin.exchange&quot;));        System.out.println(&quot;创建exchange成功&quot;);        //创建queue        amqpAdmin.declareQueue(new Queue(&quot;amqpadmin.queue&quot;,true));    //durable:是否持久化        //创建Binding        amqpAdmin.declareBinding(new Binding(&quot;amqpadmin.queue&quot;,Binding.DestinationType.QUEUE,&quot;amqpadmin.exchange&quot;,&quot;amqpadmin.haha&quot;,null));    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot消息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot高级缓存</title>
      <link href="/2020/02/10/springboot-gao-ji-huan-cun-cache/"/>
      <url>/2020/02/10/springboot-gao-ji-huan-cun-cache/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot高级-缓存cache并且整合redis"><a href="#springboot高级-缓存cache并且整合redis" class="headerlink" title="springboot高级,缓存cache并且整合redis"></a>springboot高级,缓存cache并且整合redis</h1><h1 id="springboot缓存"><a href="#springboot缓存" class="headerlink" title="springboot缓存"></a>springboot缓存</h1><p>缓存的场景</p><ul><li>临时性数据存储【校验码】</li><li>避免频繁因为相同的内容查询数据库【查询的信息】</li></ul><h2 id="jsr107缓存规范"><a href="#jsr107缓存规范" class="headerlink" title="jsr107缓存规范"></a>jsr107缓存规范</h2><blockquote><p>用的比较少</p></blockquote><p>Java Caching定义了5个核心接口</p><ul><li><p>CachingProvider</p><p>定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期间访问多个CachingProvider</p></li><li><p>CacheManager</p><p>定义了创建、配置、获取、管理和控制多个唯一命名的Cache,这些Cache存在于CacheManage的上下文中，一个CacheManage只被一个CachingProvider拥有</p></li><li><p>Cache</p><p>类似于Map的数据结构并临时储存以key为索引的值，一个Cache仅仅被一个CacheManage所拥有</p></li><li><p>Entry</p><p>存储在Cache中的key-value对</p></li><li><p>Expiry</p><p>存储在Cache的条目有一个定义的有效期，一旦超过这个时间，就会设置过期的状态，过期无法被访问，更新，删除。缓存的有效期可以通过ExpiryPolicy设置。</p></li></ul><h2 id="spring的缓存抽象"><a href="#spring的缓存抽象" class="headerlink" title="spring的缓存抽象"></a>spring的缓存抽象</h2><p>包括一些JSR107的注解</p><p>CahceManager</p><p>Cache</p><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><p><strong>重要的概念&amp;缓存注解</strong></p><table><thead><tr><th></th><th align="left">功能</th></tr></thead><tbody><tr><td>Cache</td><td align="left">缓存接口，定义缓存操作，实现有：RedisCache、EhCacheCache、ConcurrentMapCache等</td></tr><tr><td>CacheManager</td><td align="left">缓存管理器，管理各种缓存（Cache）组件</td></tr><tr><td>@Cacheable</td><td align="left">针对方法配置，根据方法的请求参数对其结果进行缓存</td></tr><tr><td>@CacheEvict</td><td align="left">清空缓存</td></tr><tr><td>@CachePut</td><td align="left">保证方法被调用，又希望结果被缓存 update，调用，将信息更新缓存</td></tr><tr><td>@EnableCaching</td><td align="left">开启基于注解的缓存</td></tr><tr><td>KeyGenerator</td><td align="left">缓存数据时key生成的策略</td></tr><tr><td>serialize</td><td align="left">缓存数据时value序列化策略</td></tr></tbody></table><h2 id="整合项目"><a href="#整合项目" class="headerlink" title="整合项目"></a>整合项目</h2><p>springboot 2.2.3+web+mysql+mybatis+cache</p><h3 id="导入相关配置"><a href="#导入相关配置" class="headerlink" title="导入相关配置"></a>导入相关配置</h3><pre><code>    &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;                &lt;scope&gt;test&lt;/scope&gt;                &lt;exclusions&gt;                    &lt;exclusion&gt;                        &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                        &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                    &lt;/exclusion&gt;                &lt;/exclusions&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;2.1.1&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                &lt;scope&gt;runtime&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;                &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;1.1.20&lt;/version&gt;            &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>application.yml</p><pre><code>spring:        datasource:          username: root          password: 980508          url: jdbc:mysql://localhost:3306/spring-cache?serverTimezone=UTC          driver-class-name: com.mysql.cj.jdbc.Driver          initialization-mode: always#开启驼峰命名法mybatis:  configuration:    map-underscore-to-camel-case: true</code></pre><p>application.properties</p><pre><code># 开启日志，打印sql语句logging.level.com.atguigu.mapper = debug# 打印配置报告debug=true</code></pre><h3 id="创建bean实例"><a href="#创建bean实例" class="headerlink" title="创建bean实例"></a>创建bean实例</h3><p>Department</p><pre><code>package com.atguigu.bean;public class Department {    private Integer id;    private String departmentName;    public Department() {        super();        // TODO Auto-generated constructor stub    }    public Department(Integer id, String departmentName) {        super();        this.id = id;        this.departmentName = departmentName;    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getDepartmentName() {        return departmentName;    }    public void setDepartmentName(String departmentName) {        this.departmentName = departmentName;    }    @Override    public String toString() {        return &quot;Department [id=&quot; + id + &quot;, departmentName=&quot; + departmentName + &quot;]&quot;;    }}</code></pre><p>Employee</p><pre><code>package com.atguigu.bean;public class Employee {    private Integer id;    private String lastName;    private String email;    private Integer gender; //性别 1男  0女    private Integer dId;    public Employee() {        super();    }    public Employee(Integer id, String lastName, String email, Integer gender, Integer dId) {        super();        this.id = id;        this.lastName = lastName;        this.email = email;        this.gender = gender;        this.dId = dId;    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getLastName() {        return lastName;    }    public void setLastName(String lastName) {        this.lastName = lastName;    }    public String getEmail() {        return email;    }    public void setEmail(String email) {        this.email = email;    }    public Integer getGender() {        return gender;    }    public void setGender(Integer gender) {        this.gender = gender;    }    public Integer getdId() {        return dId;    }    public void setdId(Integer dId) {        this.dId = dId;    }    @Override    public String toString() {        return &quot;Employee [id=&quot; + id + &quot;, lastName=&quot; + lastName + &quot;, email=&quot; + email + &quot;, gender=&quot; + gender + &quot;, dId=&quot;                + dId + &quot;]&quot;;    }}</code></pre><h3 id="创建mapper接口映射数据库"><a href="#创建mapper接口映射数据库" class="headerlink" title="创建mapper接口映射数据库"></a>创建mapper接口映射数据库</h3><p>DepartmentMapper</p><pre><code>package com.atguigu.mapper;import com.atguigu.bean.Department;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;public interface DepartmentMapper {    @Select(&quot;select * from department where id = #{id}&quot;)    public Department getDepById(Integer id);    @Update(&quot;update department set departmentName=#{departmentName} where id=#{id}&quot;)    public void updateDep(Department department);    @Delete(&quot;delete from department where id=#{id}&quot;)    public void deleteDepById(Integer id);    @Insert(&quot;insert into department (departmentName)values(#{departmentName})&quot;)    public void insertDep(Department department);}</code></pre><p>EmployeeMapper</p><pre><code>package com.atguigu.mapper;import com.atguigu.bean.Employee;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;public interface EmployeeMapper {    @Select(&quot;select * from Employee where id = #{id}&quot;)    public Employee getEmpById(Integer id);    @Update(&quot; update Employee set lastName=#{lastName},email=#{email},gender=#{gender},d_id=#{dId} where id=#{id}&quot;)    public void updateEmp(Employee employee);    @Delete(&quot;delete form Employee where id=#{id}&quot;)    public void deleteEmpById(Integer id);    @Insert(&quot;insert into Employee(lastName,email,gender,d_id)values(#{lastName},#{email},#{gender},#{dId})&quot;)    public void insertEmp(Employee employee);    @Select(&quot;select * from Employee where lastName = #{lastName}&quot;)    public Employee getEmpByLastName(String lastName);}</code></pre><h3 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h3><p>主程序添加注解MapperScan，并且使用@EnableCaching开启缓存</p><pre><code>@EnableCaching@MapperScan(&quot;com.atguigu.mapper&quot;)@SpringBootApplicationpublic class SpringBoot01CacheApplication {    public static void main(String[] args) {        SpringApplication.run(SpringBoot01CacheApplication.class, args);    }}</code></pre><h3 id="编写service来具体实现mapper中的方法"><a href="#编写service来具体实现mapper中的方法" class="headerlink" title="编写service来具体实现mapper中的方法"></a>编写service来具体实现mapper中的方法</h3><p>将方法的运行结果进行缓存，以后要是再有相同的数据，直接从缓存中获取，不用调用方法</p><p> CacheManager中管理多个Cache组件，对缓存的真正CRUD操作在Cache组件中，每个缓存组件都有自己的唯一名字；</p><p> 属性：</p><ul><li>CacheName/value:指定存储缓存组件的名字</li><li>key:缓存数据使用的key,可以使用它来指定。默认是使用方法参数的值，1-方法的返回值</li><li>编写Spel表达式：#id 参数id的值， #a0/#p0 #root.args[0]</li><li>keyGenerator:key的生成器，自己可以指定key的生成器的组件id</li><li>key/keyGendertor二选一使用</li><li>cacheManager指定Cache管理器，或者cacheReslover指定获取解析器</li><li>condition:指定符合条件的情况下，才缓存； ex:condition = “#id&gt;0”</li><li>unless：否定缓存，unless指定的条件为true，方法的返回值就不会被缓存，可以获取到结果进行判断  ;  ex:unless = “#result == null”</li><li>sync:是否使用异步模式，unless不支持</li></ul><h4 id="各种注解的使用"><a href="#各种注解的使用" class="headerlink" title="各种注解的使用"></a>各种注解的使用</h4><pre><code>@Servicepublic class EmployeeService {    @Autowired    EmployeeMapper employeeMapper;    /**     * cacheName：  指定缓存组件的名字，也可以用value来表示     * key: #id表示id的值作为key   还有另一种keyGenerator:key的生成器，自己可以指定key的生成器的组件id,自己了解，这里就不演示了     * condition： 符合条件下，才缓存，这里表示id&gt;1才缓存     * unless:  符合条件下，不缓存，这里表示id==0则不缓存     * @param id     * @return     */    @Cacheable(cacheNames = &quot;emp&quot;,key = &quot;#id&quot;,condition = &quot;#id&gt;1&quot;,unless = &quot;#id==0&quot;)    public Employee getEmp(Integer id){        System.out.println(&quot;查询&quot;+id+&quot;号员工&quot;);        Employee employee=employeeMapper.getEmpById(id);        return employee;    }     /**     *@CachePut：既调用方法，又更新缓存     * 修改了数据库的某个数据，同时又更新了缓存     * 运行时机：（与Cacheable相反）     *      1.先调用目标方法     *      2.将目标方法缓存起来     *     * 测试步骤     * 1.查询1号员工，查询到的结果会放到缓存中     *          key：1   value：lastName：zhangsan     * 2.以后查询的结果还是之前的结果     * 3.更新1号员工     * 4.查询1号员工，应该是更新后的员工，key应该这样写     *      key=&quot;#employee.id&quot;   使用传入参数的员工id     *      key=&quot;#result.id&quot;     使用返回后的员工id     *      注：@Cacheable中不能写#result.id     * @param employee     * @return     */    @CachePut(cacheNames = &quot;emp&quot;,key = &quot;#result.id&quot;)    public Employee updateEmp(Employee employee){        System.out.println(&quot;更新&quot;+employee.getId()+&quot;号员工&quot;);        employeeMapper.updateEmp(employee);        return employee;    }     /**     * @CacheEvict：清除缓存（常用于删除之类的）     * key：指定清除的数据     * allEntries=true：指定清除这个缓存中的所有数据，默认是false     * beforeInvocation = false : 缓存的清除是否在方法之前清除，默认是false     *      默认是在方法之后清除（如果出现异常错误则不清除）     * beforeInvocation = true ：缓存的清除在方法之前清除，不管是否出现异常都会清除     * @param id     */    @CacheEvict(cacheNames = &quot;emp&quot;,key = &quot;#id&quot;,beforeInvocation = true)    public void deleteEmp(Integer id){        System.out.println(&quot;清除&quot;+id+&quot;号员工缓存&quot;);        //employeeMapper.deleteEmpById(id);     //同时删除数据库中的数据        int i=10/0;    }    //@Caching 定义复杂的缓存规则    /**     * 这里通过查询lastName来测试     * 当查询lastName完之后，再通过id和email来查就不需要通过数据库了     * 但是通过lastName来查询还是需要通过数据库，因为CachePut注解的作用是先调用目标方法，方法必被执行     *     * 公共的配置可以通过@CacheConfig写在一起，标注在类前，比如配置cacheName     * @param lastName     * @return     */    @Caching(            cacheable = {                    @Cacheable(key = &quot;#lastName&quot;)            },            put = {                    @CachePut(key = &quot;#result.id&quot;),                    @CachePut(key = &quot;#result.email&quot;)            }    )    public Employee getEmpByLastName(String lastName){        System.out.println(&quot;查询&quot;+lastName);        Employee emp = employeeMapper.getEmpByLastName(lastName);        return emp;    }}</code></pre><h3 id="编写controller测试"><a href="#编写controller测试" class="headerlink" title="编写controller测试"></a>编写controller测试</h3><pre><code>@RestControllerpublic class EmployeeController {    @Autowired    EmployeeService employeeService;    @GetMapping(&quot;/emp/{id}&quot;)    public Employee getEmployee(@PathVariable(&quot;id&quot;) Integer id){        Employee emp = employeeService.getEmp(id);        return emp;    }    @GetMapping(&quot;/emp&quot;)    public Employee updateEmployee(Employee employee){        Employee emp = employeeService.updateEmp(employee);        return emp;    }    @GetMapping(&quot;/delemp/{id}&quot;)    public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id){        employeeService.deleteEmp(id);        return &quot;清除&quot;+id+&quot;号员工缓存成功&quot;;    }    @GetMapping(&quot;/emp/lastname/{lastName}&quot;)    public Employee getEmpByLastName(@PathVariable(&quot;lastName&quot;) String lastName){        Employee emp= employeeService.getEmpByLastName(lastName);        return emp;    }}</code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>第一次访问会查询数据库，继续访问缓存中取值</p><h2 id="整合redis"><a href="#整合redis" class="headerlink" title="整合redis"></a>整合redis</h2><ul><li>在上面的基础上加一部分东西</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>下载windows版本的压缩包 <a href="https://github.com/microsoftarchive/redis/releases" target="_blank" rel="noopener">链接</a></li><li>下载RedisDesktopManager（一个桌面化的redis工具）</li></ul><h3 id="导入相关依赖"><a href="#导入相关依赖" class="headerlink" title="导入相关依赖"></a>导入相关依赖</h3><pre><code>    &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>application.yml</p><pre><code>    # REDIS (RedisProperties)    # Redis数据库索引（默认为0）    spring.redis.database=0    # Redis服务器地址    spring.redis.host=localhost    # Redis服务器连接端口    spring.redis.port=6379    # Redis服务器连接密码（默认为空）    #spring.redis.password=980508    # 连接池最大连接数（使用负值表示没有限制）    spring.redis.jedis.pool.max-active=8    # 连接池最大阻塞等待时间（使用负值表示没有限制）    spring.redis.jedis.pool.max-wait=-1    # 连接池中的最大空闲连接    spring.redis.jedis.pool.max-idle=8    # 连接池中的最小空闲连接    spring.redis.jedis.pool.min-idle=0</code></pre><h3 id="测试redis"><a href="#测试redis" class="headerlink" title="测试redis"></a>测试redis</h3><ul><li><p>redis中常见的五大数据类型</p><ul><li>String（字符串），List（列表），Set（集合），Hash（散列），ZSet   有序集合）</li></ul></li><li><p>redis两个template</p><ul><li><p>StringRedisTemplate stringRedisTemplate;    //操作k-v都是字符串的</p></li><li><p>RedisTemplate redisTemplate;    //操作k-v都是对象的</p></li></ul></li><li><p>具体用法（redisTemplate是一样的）</p><ul><li>stringRedisTemplate.opsForValue()    [String（字符串）]</li><li>stringRedisTemplate.opsForList()    [List（列表）]</li><li>stringRedisTemplate.opsForSet()    [Set（集合）]</li><li>stringRedisTemplate.opsForHash()    [Hash（散列）]</li><li>stringRedisTemplate.opsForZSet()    [ZSet（有序集合）]</li></ul></li></ul><h4 id="test01"><a href="#test01" class="headerlink" title="test01"></a>test01</h4><pre><code>    //测试给redis中保存数据，操作k-v都是字符串的    @Autowired    StringRedisTemplate stringRedisTemplate;    //操作k-v都是字符串的    @Test    public void test01(){        //stringRedisTemplate.opsForValue().append(&quot;msg&quot;,&quot;lihua&quot;);        //字符串        //String msg=stringRedisTemplate.opsForValue().get(&quot;msg&quot;);        //System.out.println(msg);        stringRedisTemplate.opsForList().leftPush(&quot;mylist&quot;,&quot;1&quot;);        //列表        stringRedisTemplate.opsForList().leftPush(&quot;mylist&quot;,&quot;2&quot;);    }</code></pre><h4 id="test02"><a href="#test02" class="headerlink" title="test02"></a>test02</h4><pre><code>    //测试保存对象    @Autowired    RedisTemplate redisTemplate;    //操作k-v都是对象的    @Autowired    EmployeeMapper employeeMapper;    @Test    public void test02(){        Employee EmpById=employeeMapper.getEmpById(1);        //默认如果保存对象，使用jdk序列化机制，序列化的数据保存到redis中        redisTemplate.opsForValue().set(&quot;emp-01&quot;,EmpById);        redisTemplate.opsForValue().set(&quot;dept-01&quot;,departmentMapper.getDepById(1));    }</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul><li><p>保存对象存进redis中的数据不是json数据，我们需要把它转换成json数据，这样我们就需要使用序列话机制，改变redisTemplate默认的序列化规则</p></li><li><p>默认保存对象，是使用jdk序列化规则，我们需要改成json序列化规则</p></li></ul><p>Employee</p><pre><code>    //实现一个接口    public class Employee implements Serializable{</code></pre><ul><li>创建一个配置类</li></ul><p>config.MyRedisConfig</p><pre><code>    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        // 配置连接工厂        template.setConnectionFactory(factory);        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）        Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jacksonSeial.setObjectMapper(om);        // 值采用json序列化        template.setValueSerializer(jacksonSeial);        //使用StringRedisSerializer来序列化和反序列化redis的key值        template.setKeySerializer(new StringRedisSerializer());        // 设置hash key 和value序列化模式        template.setHashKeySerializer(new StringRedisSerializer());        template.setHashValueSerializer(jacksonSeial);        template.afterPropertiesSet();        return template;    }</code></pre><h3 id="自定义Cachemanager"><a href="#自定义Cachemanager" class="headerlink" title="自定义Cachemanager"></a>自定义Cachemanager</h3><ul><li>缓存管理器,转换为json数据</li><li>当我们运行存入缓存中的数据不是json数据，这时我们需要自定义CacheManager，把它转换为json数据</li></ul><p>config.MyRedisConfig</p><pre><code>    /**     * 缓存管理器,转换为json数据     */    @Bean    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {        //初始化一个RedisCacheWriter        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory);        //设置CacheManager的值序列化方式为json序列化        RedisSerializer&lt;Object&gt; jsonSerializer = new GenericJackson2JsonRedisSerializer();        RedisSerializationContext.SerializationPair&lt;Object&gt; pair = RedisSerializationContext.SerializationPair                .fromSerializer(jsonSerializer);        RedisCacheConfiguration defaultCacheConfig=RedisCacheConfiguration.defaultCacheConfig()                .serializeValuesWith(pair);        //设置默认超过期时间是30秒        defaultCacheConfig.entryTtl(Duration.ofSeconds(30));        //初始化RedisCacheManager        return new RedisCacheManager(redisCacheWriter, defaultCacheConfig);    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot高级缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot jdbc</title>
      <link href="/2020/01/13/springboot-lian-jie-jdbc/"/>
      <url>/2020/01/13/springboot-lian-jie-jdbc/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot连接jdbc数据库并且整合Druid数据源"><a href="#springboot连接jdbc数据库并且整合Druid数据源" class="headerlink" title="springboot连接jdbc数据库并且整合Druid数据源"></a>springboot连接jdbc数据库并且整合Druid数据源</h1><h1 id="连接jdbc数据库"><a href="#连接jdbc数据库" class="headerlink" title="连接jdbc数据库"></a>连接jdbc数据库</h1><h2 id="导入相关依赖"><a href="#导入相关依赖" class="headerlink" title="导入相关依赖"></a>导入相关依赖</h2><pre><code>&lt;!--导入jdbc相关依赖--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.1.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><h2 id="配置数据库连接信息"><a href="#配置数据库连接信息" class="headerlink" title="配置数据库连接信息"></a>配置数据库连接信息</h2><ul><li>application.yml</li></ul><pre><code>    spring:      datasource:        username: root        password: 数据库密码        url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC        driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><h2 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h2><ul><li>在测试类中测试</li></ul><pre><code>    @SpringBootTest    class SpringBootData06JdbcApplicationTests {      @Autowired      DataSource dataSource;      //测试连接数据库      @Test      void contextLoads() throws SQLException {        System.out.println(dataSource.getClass());        Connection connection = dataSource.getConnection();        System.out.println(connection);      }    }</code></pre><ul><li>springboot默认是使用com.zaxxer.hikari.HikariDataSource作为数据源，</li></ul><p>2.0以下是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p><pre><code>    如果出现com.zaxxer.hikari.HikariDataSource则表示连接成功</code></pre><h2 id="数据库查询数据返回网页"><a href="#数据库查询数据返回网页" class="headerlink" title="数据库查询数据返回网页"></a>数据库查询数据返回网页</h2><pre><code>    @RestController    public class JdbcController {        //查询数据库的数据返回网页        @Autowired        JdbcTemplate jdbcTemplate;        @GetMapping(&quot;/query&quot;)        public Map&lt;String,Object&gt; map(){            List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;SELECT * from department&quot;);            return list.get(0);        }    }</code></pre><p><a href="http://localhost:8080/query" target="_blank" rel="noopener">查询</a>  </p><h1 id="整合Druid数据源"><a href="#整合Druid数据源" class="headerlink" title="整合Druid数据源"></a>整合Druid数据源</h1><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><ul><li>在springboot项目中导入druid数据源依赖<a href="https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter" target="_blank" rel="noopener">点击查询最新依赖</a></li></ul><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.20&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><ul><li>application.yml</li></ul><pre><code>    #jdbc的配置    spring:      datasource:        password: 980508        username: root        url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8        driver-class-name: com.mysql.cj.jdbc.Driver        initialization-mode: always        #整合Druid数据源        type: com.alibaba.druid.pool.DruidDataSource        druid:          # 连接池配置          # 配置初始化大小、最小、最大          initial-size: 1          min-idle: 1          max-active: 20          # 配置获取连接等待超时的时间          max-wait: 3000          validation-query: SELECT 1 FROM DUAL          test-on-borrow: false          test-on-return: false          test-while-idle: true          pool-prepared-statements: true          time-between-eviction-runs-millis: 60000          min-evictable-idle-time-millis: 300000          filters: stat,wall,slf4j          # 配置web监控,默认配置也和下面相同(除用户名密码，enabled默认false外)，其他可以不配          web-stat-filter:            enabled: true            url-pattern: /*            exclusions: &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;          stat-view-servlet:            enabled: true            url-pattern: /druid/*            login-username: lihuazhou            login-password: 980508            allow: 192.168.182.1</code></pre><h2 id="测试类查看使用的数据源"><a href="#测试类查看使用的数据源" class="headerlink" title="测试类查看使用的数据源"></a>测试类查看使用的数据源</h2><pre><code>    @SpringBootTest    class SpringbootJdbcApplicationTests {        @Autowired        private DataSource dataSource;        @Test        void contextLoads() throws SQLException {            System.out.println(dataSource.getClass());            System.out.println(dataSource.getConnection());        }    }</code></pre><h2 id="编写一个Druid配置类"><a href="#编写一个Druid配置类" class="headerlink" title="编写一个Druid配置类"></a>编写一个Druid配置类</h2><ul><li><p>DruidConfig</p></li><li><p>需要把配置信息从application.yml中加入到容器中</p></li></ul><pre><code>    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)            @Bean            public DataSource druid(){                return  new DruidDataSource();            }</code></pre><ul><li>配置一个Servelet容器来管理后台（Druid的监控）</li></ul><pre><code>    @Bean    public ServletRegistrationBean statViewServlet(){        ServletRegistrationBean bean=new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;); //druid后台的路径        Map&lt;String,String&gt; initParams =new HashMap&lt;&gt;();        initParams.put(&quot;loginUsername&quot;,&quot;lihuazhou&quot;);        initParams.put(&quot;loginPassword&quot;,&quot;980508&quot;);        initParams.put(&quot;allow&quot;,&quot;&quot;);//可以设置为localhost下才能访问，默认是所有都可以访问        initParams.put(&quot;deny&quot;,&quot;&quot;);//默认是不禁用路径        bean.setInitParameters(initParams);        return bean;    }</code></pre><ul><li>配置一个web监控的Filter（拦截一些操作，有点类似拦截器）</li></ul><pre><code>    @Bean    public FilterRegistrationBean webStatFilter(){        FilterRegistrationBean bean = new FilterRegistrationBean();        bean.setFilter(new WebStatFilter());        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);     //除了这些操作的数据，其他都会被拦截        bean.setInitParameters(initParams);        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));      return  bean;      }</code></pre><ul><li>Druid页面<h1 id="springboot连接jdbc数据库并且整合Druid数据源-1"><a href="#springboot连接jdbc数据库并且整合Druid数据源-1" class="headerlink" title="springboot连接jdbc数据库并且整合Druid数据源"></a>springboot连接jdbc数据库并且整合Druid数据源</h1></li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>1.<a href="#连接jdbc数据库">连接jdbc数据库</a><ul><li>1.<a href="#导入相关依赖">导入相关依赖</a></li><li>2.<a href="#配置数据库连接信息">配置数据库连接信息</a></li><li>3.<a href="#测试连接">测试连接</a></li><li>4.<a href="#数据库查询数据返回网页">数据库查询数据返回网页</a></li></ul></li><li>1.<a href="#整合Druid数据源">整合Druid数据源</a><ul><li>1.<a href="#导入依赖">导入依赖</a></li><li>2.<a href="#配置信息">配置信息</a></li><li>3.<a href="#测试类查看使用的数据源">测试类查看使用的数据源</a></li><li>4.<a href="#编写一个Druid配置类">编写一个Druid配置类</a></li></ul></li></ul><h1 id="连接jdbc数据库-1"><a href="#连接jdbc数据库-1" class="headerlink" title="连接jdbc数据库"></a>连接jdbc数据库</h1><h2 id="导入相关依赖-1"><a href="#导入相关依赖-1" class="headerlink" title="导入相关依赖"></a>导入相关依赖</h2><pre><code>&lt;!--导入jdbc相关依赖--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.1.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><h2 id="配置数据库连接信息-1"><a href="#配置数据库连接信息-1" class="headerlink" title="配置数据库连接信息"></a>配置数据库连接信息</h2><ul><li>application.yml</li></ul><pre><code>    spring:      datasource:        username: root        password: 数据库密码        url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC        driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><h2 id="测试连接-1"><a href="#测试连接-1" class="headerlink" title="测试连接"></a>测试连接</h2><ul><li>在测试类中测试</li></ul><pre><code>    @SpringBootTest    class SpringBootData06JdbcApplicationTests {      @Autowired      DataSource dataSource;      //测试连接数据库      @Test      void contextLoads() throws SQLException {        System.out.println(dataSource.getClass());        Connection connection = dataSource.getConnection();        System.out.println(connection);      }    }</code></pre><ul><li>springboot默认是使用com.zaxxer.hikari.HikariDataSource作为数据源，</li></ul><p>2.0以下是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p><pre><code>    如果出现com.zaxxer.hikari.HikariDataSource则表示连接成功</code></pre><h2 id="数据库查询数据返回网页-1"><a href="#数据库查询数据返回网页-1" class="headerlink" title="数据库查询数据返回网页"></a>数据库查询数据返回网页</h2><pre><code>    @RestController    public class JdbcController {        //查询数据库的数据返回网页        @Autowired        JdbcTemplate jdbcTemplate;        @GetMapping(&quot;/query&quot;)        public Map&lt;String,Object&gt; map(){            List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;SELECT * from department&quot;);            return list.get(0);        }    }</code></pre><p><a href="http://localhost:8080/query" target="_blank" rel="noopener">查询</a>  </p><h1 id="整合Druid数据源-1"><a href="#整合Druid数据源-1" class="headerlink" title="整合Druid数据源"></a>整合Druid数据源</h1><h2 id="导入依赖-1"><a href="#导入依赖-1" class="headerlink" title="导入依赖"></a>导入依赖</h2><ul><li>在springboot项目中导入druid数据源依赖<a href="https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter" target="_blank" rel="noopener">点击查询最新依赖</a></li></ul><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.20&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h2 id="配置信息-1"><a href="#配置信息-1" class="headerlink" title="配置信息"></a>配置信息</h2><ul><li>application.yml</li></ul><pre><code>    #jdbc的配置    spring:      datasource:        password: 980508        username: root        url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8        driver-class-name: com.mysql.cj.jdbc.Driver        initialization-mode: always        #整合Druid数据源        type: com.alibaba.druid.pool.DruidDataSource        druid:          # 连接池配置          # 配置初始化大小、最小、最大          initial-size: 1          min-idle: 1          max-active: 20          # 配置获取连接等待超时的时间          max-wait: 3000          validation-query: SELECT 1 FROM DUAL          test-on-borrow: false          test-on-return: false          test-while-idle: true          pool-prepared-statements: true          time-between-eviction-runs-millis: 60000          min-evictable-idle-time-millis: 300000          filters: stat,wall,slf4j          # 配置web监控,默认配置也和下面相同(除用户名密码，enabled默认false外)，其他可以不配          web-stat-filter:            enabled: true            url-pattern: /*            exclusions: &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;          stat-view-servlet:            enabled: true            url-pattern: /druid/*            login-username: lihuazhou            login-password: 980508            allow: 192.168.182.1</code></pre><h2 id="测试类查看使用的数据源-1"><a href="#测试类查看使用的数据源-1" class="headerlink" title="测试类查看使用的数据源"></a>测试类查看使用的数据源</h2><pre><code>    @SpringBootTest    class SpringbootJdbcApplicationTests {        @Autowired        private DataSource dataSource;        @Test        void contextLoads() throws SQLException {            System.out.println(dataSource.getClass());            System.out.println(dataSource.getConnection());        }    }</code></pre><h2 id="编写一个Druid配置类-1"><a href="#编写一个Druid配置类-1" class="headerlink" title="编写一个Druid配置类"></a>编写一个Druid配置类</h2><ul><li><p>DruidConfig</p></li><li><p>需要把配置信息从application.yml中加入到容器中</p></li></ul><pre><code>    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)            @Bean            public DataSource druid(){                return  new DruidDataSource();            }</code></pre><ul><li>配置一个Servelet容器来管理后台（Druid的监控）</li></ul><pre><code>    @Bean    public ServletRegistrationBean statViewServlet(){        ServletRegistrationBean bean=new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;); //druid后台的路径        Map&lt;String,String&gt; initParams =new HashMap&lt;&gt;();        initParams.put(&quot;loginUsername&quot;,&quot;lihuazhou&quot;);        initParams.put(&quot;loginPassword&quot;,&quot;980508&quot;);        initParams.put(&quot;allow&quot;,&quot;&quot;);//可以设置为localhost下才能访问，默认是所有都可以访问        initParams.put(&quot;deny&quot;,&quot;&quot;);//默认是不禁用路径        bean.setInitParameters(initParams);        return bean;    }</code></pre><ul><li>配置一个web监控的Filter（拦截一些操作，有点类似拦截器）</li></ul><pre><code>    @Bean    public FilterRegistrationBean webStatFilter(){        FilterRegistrationBean bean = new FilterRegistrationBean();        bean.setFilter(new WebStatFilter());        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);     //除了这些操作的数据，其他都会被拦截        bean.setInitParameters(initParams);        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));      return  bean;      }</code></pre><ul><li>Druid页面</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/25.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot jdbc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
