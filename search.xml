<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2021/04/05/linux-de-xue-xi/"/>
      <url>/2021/04/05/linux-de-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="linux命令篇"><a href="#linux命令篇" class="headerlink" title="linux命令篇"></a>linux命令篇</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>1.善用帮助，对于不熟悉的命令，可以通过查资料等来熟悉它的常用参数。还可以通过linux命令查看具体的用法，几乎所有的命令都可以使用cmd –help或者cmd -h或者man cmd，查看cmd命令的用法</li><li>2.可以通过此链接进行学习  <a href="https://wangchujiang.com/linux-command/" target="_blank" rel="noopener">https://wangchujiang.com/linux-command/</a></li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>短参：-a</li><li>长参：–help</li><li>两个赋值的方式有点不同：-a 9，–help=9</li></ul><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>根目录：/</li><li>bin：存放二进制文件，二进制文件都是可执行文件，bin目录包含了会被所有用户使用的可执行程序</li><li>boot：boot的意思是启动，它包含了与linux启动密切相关的文件</li><li>dev：dev（device）设备，它包含外设，它里面的子目录，每一个对应一个外设，比方说光盘驱动器等等</li><li>etc：包含系统的配置文件</li><li>home：用户私人目录，用来存放私人的文件，每个用户都在home下有一个私人目录，除了root。比如我的用户是lhz，那么有一个目录就叫/home/lhz</li><li>lib：库，包含被程序所调用的库文件，例如.so结尾的文件</li><li>media：媒体，可移动的外设（usb，sd卡，dvd）等等插入电脑时，linux通过media的子目录来访问这些外设中的内容</li><li>mnt：挂载，有点类似media目录，但一般用于临时挂载一些装置</li><li>opt：可选的应用软件包，用于安装多数第三方软件和插件</li><li>root：超级用户root的家目录</li><li>sbin：系统二进制文件，比bin目录多了个前缀system（“系统”），sbin包含系统级别的重要可执行程序</li><li>srv：service，服务。包含一些网络服务启动之后所需要取用的数据</li><li>tmp：temporary，临时的。它是普通用户和程序存放临时文件的地方</li><li>usr：unix操作系统软件资源，类似etc，usr目录是最庞大的目录之一。usr目录中安装了大部分用户要调用的程序</li><li>var：动态的，var通常包含程序的数据，比如log日志文件</li><li>以上目录的列表形式，在类unix的操作系统里是类似的</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/110.png" alt=""></p><h3 id="命令查询类"><a href="#命令查询类" class="headerlink" title="命令查询类"></a>命令查询类</h3><ul><li>man</li><li>apropos：查找命令（根据信息查找你想要的命令），你不知道这个命令的话可以用它查</li><li>–help/-h</li><li>whatis：man的精简版</li></ul><h3 id="系统查询类"><a href="#系统查询类" class="headerlink" title="系统查询类"></a>系统查询类</h3><h4 id="日期-时间"><a href="#日期-时间" class="headerlink" title="日期/时间"></a>日期/时间</h4><ul><li>date</li></ul><h4 id="系统-内核版本"><a href="#系统-内核版本" class="headerlink" title="系统/内核版本"></a>系统/内核版本</h4><ul><li>uname</li><li>lsb_release</li></ul><h4 id="命令执行历史"><a href="#命令执行历史" class="headerlink" title="命令执行历史"></a>命令执行历史</h4><ul><li>history</li></ul><h4 id="用户切换"><a href="#用户切换" class="headerlink" title="用户切换"></a>用户切换</h4><ul><li>su：su root（切换到root）</li><li>sudo（以root身份运行命令）</li></ul><h5 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h5><h6 id="切换到root用户"><a href="#切换到root用户" class="headerlink" title="切换到root用户"></a>切换到root用户</h6><ul><li>su root：切换到root用户</li><li>sudo su：切换到root用户，exit：退出root用户</li><li>su -：切换到root用户，也切换到root用户目录</li><li>su：切换到root用户，但是还是在个人用户目录</li><li>sudo -i</li></ul><h4 id="定位命令位置"><a href="#定位命令位置" class="headerlink" title="定位命令位置"></a>定位命令位置</h4><ul><li>which</li></ul><h3 id="文件目录操作类"><a href="#文件目录操作类" class="headerlink" title="文件目录操作类"></a>文件目录操作类</h3><h4 id="回显"><a href="#回显" class="headerlink" title="回显"></a>回显</h4><ul><li>echo</li></ul><h4 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h4><ul><li>pwd</li><li>cd</li></ul><h4 id="目录创建-删除"><a href="#目录创建-删除" class="headerlink" title="目录创建/删除"></a>目录创建/删除</h4><ul><li>mkdir</li><li>rmdir</li></ul><h4 id="目录-文件权限修改"><a href="#目录-文件权限修改" class="headerlink" title="目录/文件权限修改"></a>目录/文件权限修改</h4><ul><li>chown：改变文件/目录的拥有者或者群组（root权限）<ul><li>chown lhz:friends file.txt（chown用来修改所属群组）</li></ul></li><li>chgrp：用来变更文件或目录的所属群组（root权限）</li><li>chmod：修改文件访问权限（不需要root）<ul><li>d：目录，l：链接，r：可读权限，w：可写权限，x：可运行权限</li><li>第1位如果是d则代表目录，是-则代表普通文件，是l则表示一个链接。</li><li>第2到4位代表当前用户的权限。</li><li>第5到7位代表群组组用户的权限。</li><li>第8到10位代表其他用户的权限。</li></ul></li></ul><h4 id="目录-文件详细信息"><a href="#目录-文件详细信息" class="headerlink" title="目录/文件详细信息"></a>目录/文件详细信息</h4><ul><li>ls</li><li>stat</li></ul><h4 id="文件创建"><a href="#文件创建" class="headerlink" title="文件创建"></a>文件创建</h4><ul><li>touch</li></ul><h4 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h4><ul><li>cat</li><li>tac</li><li>tail</li><li>head</li><li>more</li><li>less</li></ul><h4 id="文件-文件夹查找"><a href="#文件-文件夹查找" class="headerlink" title="文件/文件夹查找"></a>文件/文件夹查找</h4><ul><li>find比locate更快，更精准</li><li>locate：搜索包含关键字的所有文件和目录<ul><li>部分系统找不到这个命令，原因是没下载这个包，下载安装：yum  -y install mlocate</li><li>然后可能还是会报错，原因是安装完后没有更新库，更新：updatedb</li><li>locate有一个缺点，它的原理是在文件的数据库中查找记录，不会对实际的整个硬盘进行查找。所以对于刚创建不久的文件，因为它们还没被收录进文件的数据库，就会查找不到。但是可以用updatedb（root）去更新数据库，这样就能查到</li><li>locate命令方便快捷，易于使用，但是它缺点也很明显<ul><li>locate命令会列出所有在文件数据库中找到的内容，有时候太多了，太繁杂</li><li>locate命令不能找到一天之内刚创建的文件，除非你用root身份运行updatedb去更新文件数据库</li><li>当locate命令不够用时，我们需要一个更强大的命令，那就是find</li></ul></li></ul></li><li>find：深入查找<ul><li>会遍历实际硬盘</li><li>find 何处 何物 做什么，这几个参数中只有何物是必须指定的，也就是查找什么，可以根据文件名/文件大小/最近访问时间等来查找<ul><li>何处是指定在哪个目录查，其子目录也会被查找，与locate命令查找所有文件数据库的所有记录不同，如果没有给出何处这个参数，就会在当前目录下及其子目录查找</li><li>做什么，用find命令找到的文件，可以对每个文件做一定的操作，称为后续处理</li></ul></li><li>ex：find -name “lhz.txt”，用来查找当前目录下的lhz.txt文件</li><li>find是精准匹配，不会想locate一样匹配到类似的，但是我们要匹配xxx开头或者结尾就可以使用通配符 *</li></ul></li></ul><h4 id="文件编辑"><a href="#文件编辑" class="headerlink" title="文件编辑"></a>文件编辑</h4><ul><li>vim<ul><li>如何同时打开两个文件：vim file1 file2，:n切换到下一个文件，:N切换到上一个文件</li><li>如何显示行数：文件中使用命令”:nu”</li><li>如何查找文件中是否存在指定内容：通过”/“或者”?”</li></ul></li></ul><h4 id="文件类型查看"><a href="#文件类型查看" class="headerlink" title="文件类型查看"></a>文件类型查看</h4><ul><li>file</li></ul><h4 id="文件-目录重命名"><a href="#文件-目录重命名" class="headerlink" title="文件/目录重命名"></a>文件/目录重命名</h4><ul><li>mv</li></ul><h4 id="文件-目录复制"><a href="#文件-目录复制" class="headerlink" title="文件/目录复制"></a>文件/目录复制</h4><ul><li>cp</li><li>rsync</li></ul><h4 id="文件-目录生成链接"><a href="#文件-目录生成链接" class="headerlink" title="文件/目录生成链接"></a>文件/目录生成链接</h4><ul><li>ln（硬链接，软连接）</li></ul><h4 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h4><ul><li>tr</li><li>wc：文件的统计，可以统计单词数，行数，字符数，字节数等等</li><li>grep：筛选数据，功能就是在文件中查找关键字，并显示关键字所在行</li><li>sort：为文件的行进行排序</li><li>uniq：忽略文件中的重复内容</li><li>cut：剪切文件的一部分内容，用来显示行中的指定部分</li></ul><h4 id="压缩-解压-打包"><a href="#压缩-解压-打包" class="headerlink" title="压缩/解压/打包"></a>压缩/解压/打包</h4><ul><li>tar</li><li>gzip</li><li>gunzip</li></ul><h4 id="文件-文本处理"><a href="#文件-文本处理" class="headerlink" title="文件/文本处理"></a>文件/文本处理</h4><ul><li>sed</li><li>awk</li></ul><h3 id="进程操作类"><a href="#进程操作类" class="headerlink" title="进程操作类"></a>进程操作类</h3><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><ul><li>ps</li><li>top</li></ul><h4 id="杀掉进程"><a href="#杀掉进程" class="headerlink" title="杀掉进程"></a>杀掉进程</h4><ul><li>kill</li><li>killall</li></ul><h4 id="cpu负载相关"><a href="#cpu负载相关" class="headerlink" title="cpu负载相关"></a>cpu负载相关</h4><ul><li>uptime</li></ul><h3 id="网络操作类"><a href="#网络操作类" class="headerlink" title="网络操作类"></a>网络操作类</h3><h4 id="ip信息显示"><a href="#ip信息显示" class="headerlink" title="ip信息显示"></a>ip信息显示</h4><ul><li>ifconfig</li><li>ip addr</li><li>ip a</li></ul><h4 id="路由信息显示"><a href="#路由信息显示" class="headerlink" title="路由信息显示"></a>路由信息显示</h4><ul><li>ip r</li><li>route</li><li>traceroute</li></ul><h4 id="网络连通性检查"><a href="#网络连通性检查" class="headerlink" title="网络连通性检查"></a>网络连通性检查</h4><ul><li>telnet</li><li>ping</li></ul><h3 id="内存操作类"><a href="#内存操作类" class="headerlink" title="内存操作类"></a>内存操作类</h3><ul><li>free</li></ul><h3 id="用户-用户组操作类（只能在root用户下才能使用）"><a href="#用户-用户组操作类（只能在root用户下才能使用）" class="headerlink" title="用户/用户组操作类（只能在root用户下才能使用）"></a>用户/用户组操作类（只能在root用户下才能使用）</h3><ul><li>useradd：添加用户<ul><li>useradd lhz</li><li>passwd lhz</li></ul></li><li>userdel：删除用户</li><li>groupadd：添加群组<ul><li>groupadd friends</li></ul></li><li>groupdel：删除群组</li><li>usermod：修改用户账户，常用的是修改用户名和所在群组，-G参数可以加入多个群组</li><li>groups：打印用户所在群组</li></ul><h3 id="磁盘操作类"><a href="#磁盘操作类" class="headerlink" title="磁盘操作类"></a>磁盘操作类</h3><h4 id="查看磁盘使用率"><a href="#查看磁盘使用率" class="headerlink" title="查看磁盘使用率"></a>查看磁盘使用率</h4><ul><li>df</li></ul><h4 id="查看文件大小"><a href="#查看文件大小" class="headerlink" title="查看文件大小"></a>查看文件大小</h4><ul><li>du</li></ul><h4 id="生成大文件"><a href="#生成大文件" class="headerlink" title="生成大文件"></a>生成大文件</h4><ul><li>dd</li></ul><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><ul><li>crontab<ul><li>crontab -e：能修改配置和创建定时任务</li><li>ex：0 8 * * 5 top &gt; /tmp/xxx：每周五八点自动执行top命令，并重定向到/tmp/xxx文件</li></ul></li></ul><h3 id="逻辑与，逻辑或"><a href="#逻辑与，逻辑或" class="headerlink" title="逻辑与，逻辑或"></a>逻辑与，逻辑或</h3><ul><li>&amp;&amp;和||以及分号一样，用于分隔两个命令，使得命令依次执行。貌似与分号类似，但其实是有区别的<ul><li>&amp;&amp;：&amp;&amp;号前的命令执行成功，才会执行后面的命令</li><li>||：||号前的命令执行失败，才会执行后面的命令</li><li>分号：不论分号前的命令执行成功与否，都执行分号后的命令</li></ul></li></ul><h3 id="流，管道，重定向"><a href="#流，管道，重定向" class="headerlink" title="流，管道，重定向"></a>流，管道，重定向</h3><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><h5 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h5><ul><li>把本来要显示在终端的命令结果，输送到别的地方。到文件中或者作为其他命令的输入</li><li>‘&gt;和&gt;&gt;’：重定向到文件，最简单的操作就是把命令的输出结果重定向到文件中，就不会在终端显示命令运行结果了<ul><li>‘&gt;’：重定向到新文件，如果此文件不存在就新建一个文件，如果存在就把原有的覆盖掉</li><li>‘&gt;&gt;’：重定向到文件末尾，起到追加的作用，如果文件不存在就会创建</li><li>/dev/null：“黑洞”文件，它是一个特殊文件，此文件的唯一属性就是它总是空的，它能使发送到/dev/null的任何数据作废，就好像这些数据掉进了无底的黑洞</li></ul></li><li>从键盘向终端输入数据，这是标准输入，也就是stdin。终端接收键盘输入的命令，会产生两种输出。标准输出：stdout，指终端输出的信息（不包括错误信息）。标准错误输出：stderr。指终端输出的错误信息<ul><li>stdin：标准输入。文件描述符：0</li><li>stdout：标准输出。文件描述符：1</li><li>stderr：标准错误输出。文件描述符：2</li><li>2&gt;：将标准错误输出重定向到文件<ul><li>ex：cat not_exist_file.csv &gt; result.txt 2&gt; errors.log 这个命令的意思是如果没有标准错误输出就重定向到result文件，如果有标准错误输出就重定向到errors文件</li></ul></li><li>2&gt;&gt;：将标准错误输出重定向到文件末尾</li></ul></li><li>合并输出<ul><li>2&gt;&amp;1：将标准错误输出重定向到标准输出相同的地方</li><li>ex：cat not_exist_file.csv &gt; result.txt 2&gt;&amp;1</li><li>追加则是：cat not_exist_file.csv &gt;&gt; result.txt 2&gt;&amp;1</li></ul></li></ul><h5 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h5><ul><li>&lt;,&lt;&lt;：从文件或键盘中读取<ul><li>&lt;符号用于指定命令的输入</li><li>cat &lt; test.txt，它的运行结果和cat test.txt是一样的，但是原理不一样<ul><li>cat test.txt：cat命令接受的输入是test.txt这个文件名，那么它要先打开test.txt文件，然后打印出文件内容</li><li>cat &lt; test.txt：cat命令接受的输入直接是test.txt这个文件的内容，cat命令只负责把它打印</li></ul></li><li>&lt;&lt;符号的作用是将键盘的输入重定向为某个命令的输入：sort -n &lt;&lt; END，输入这个命令之后按下回车，终端就进入了键盘输入模式，这个命令是把输入的值进行排序，以END为结束符，所有输入的行都将在输入结束字符串之后发送给命令</li></ul></li></ul><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><ul><li>把两个命令连起来使用，一个命令的输出作为另一个命令的输入</li></ul><h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><ul><li>在计算机科学中，流是时间上可用的一系列数据元素。我们可以把流比喻成传送带上的物件，每个时间点传输一个，而不是多个打包传输。</li></ul><h3 id="软件包下载"><a href="#软件包下载" class="headerlink" title="软件包下载"></a>软件包下载</h3><ul><li>linux的软件包都存放在一个地方，叫做软件仓库</li><li>.rpm文件：Red Hat家族</li><li>.deb文件：Debian家族</li></ul><h4 id="更新-下载-删除软件包"><a href="#更新-下载-删除软件包" class="headerlink" title="更新/下载/删除软件包"></a>更新/下载/删除软件包</h4><ul><li>yum update/upgrade：如果不加特定的软件包就会更新所有软件包，加了就只更新指定的软件包</li><li>yum install xxx</li><li>yum remove xxx</li><li>有时候会找不到，就要去找到它的.rpm文件，下载到本地安装：sudo rpm -i *.rpm，卸载：sudo rpm -e 报名</li><li>本地的.rpm软件包，也可以使用yum命令来安装。sudo yum localinstall *.rpm 用于安装，sudo yum remove 包名 用于卸载</li></ul><h4 id="替换源"><a href="#替换源" class="headerlink" title="替换源"></a>替换源</h4><ul><li>系统自带的源，有时候下载会很慢，所以我们需要替换源，国内常常选择阿里源或者网易源等等</li><li>查看系统源的方法：/etc/yum.repos.d/CentOS-Base.repo此文件夹下查看</li></ul><h3 id="进程和系统检测"><a href="#进程和系统检测" class="headerlink" title="进程和系统检测"></a>进程和系统检测</h3><ul><li>w：w命令 用于显示已经登陆系统的用户列表，并显示用户正在执行的指令。执行这个命令可得知目前登入系统的用户有那些人，以及他们正在执行的程序。单独执行w命令会显示所有的用户，您也可指定用户名称，仅显示某位用户的相关信息。</li><li>uptime：查看服务器负载情况</li><li>who：登录的用户列表</li><li>ps和top命令：列出运行的进程<ul><li>ps：进程的静态列表，ps命令用于显示当前系统中的进程，ps命令显示的进程列表不会随时间而更新，是静态的，只是运行ps命令当时的那个状态<ul><li>ps -ef：列出所有进程</li><li>ps -aux：通过CPU和内存使用来过滤进程</li><li>ps -aux –sort -pcpu：根据CPU使用率来降序排序</li><li>ps -aux –sort -pmem：根据内存使用率来降序排序</li><li>ps -aux –sort -pcpu,+pmem：将CPU和内存参数合并到一起</li><li>pstree：以树形结构显示进程，ps -axjf与pstree效果类似</li></ul></li><li>top：进程的动态列表<ul><li>一些比top更好用的软件：glances，htop</li></ul></li></ul></li><li>kill：结束一个进程，kill命令后接需要结束的进程号，也就是PID，kill命令也可以来结束多个继承，只需加空格隔开它们的PID，kill 123 456 789<ul><li>kill -9 PID：强制结束进程</li><li>killall：结束多个进程（不同终端存在的多个名字相同的进程），kill命令是用来结束全部要结束的进程，不同于kill命令，killall后面接程序名，而不是PID</li></ul></li><li>halt命令和reboot命令：停止和重启系统，实际上这两个命令都调用了另一个命令：shutdown，poweroff命令也可以实现关机</li></ul><h4 id="前台进程和后台进程"><a href="#前台进程和后台进程" class="headerlink" title="前台进程和后台进程"></a>前台进程和后台进程</h4><ul><li>默认情况下，用户创建的进程都是前台进程，前台进程从键盘中读取数据，并把处理结果输出到显示器。后台进程的优点是不必等待程序运行结束，就可以输入其他命令</li><li>&amp;符号和nohup命令：后台运行进程<ul><li>&amp;符号：把&amp;符号加在命令的末尾，即可实现后台运行进程</li><li>nohupm命令：使进程与终端分离：&amp;符号虽常用，但却有一个b不可忽视的点，就是后台进程与终端相关联，一旦终端关闭或者用户登出，进程就自动结束，想让进程在以上情况下依旧继续在后台运行，就需要用到nohup命令，用法：加在命令的开头</li></ul></li><li>Ctrl+z，jobs，bg和fg命令控制进程的前后台切换<ul><li>Ctrl+z：转到后台并暂停运行，比方说在运行top命令的时候，按下Ctrl+z就会把这个进程转到后台并暂停运行</li><li>bg：使进程转到后台，假如命令已经在后台并且暂停着，那么bg命令会使其状态改为运行，不加参数就会作用于最近的一个后台进程，如果加上%1，%2这样的参数（不加%也行），就会作用于指定标号的进程。ex：bg %2就是作用于编号为2的进程</li><li>如果你原本想要使一个命令运行在后台，成为后台进程，但是你忘记加&amp;符号了，那么可以按下面的顺序使此进程转为h后台进程，Ctrl + z使进程转为后台暂停，然后使用bg命令使进程转为后台运行</li><li>jobs：显示后台运行进程状态</li><li>fg：使进程转到前台，用法于bg一样，fg %2就是作用于编号为2的进程，把它转到前台运行<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/108.png" alt=""></li></ul></li><li>5种常见的进程状态：<ul><li>运行：对应状态码R</li><li>中断（休眠中，受阻）：对应状态码S</li><li>不可中断（进程b不响应系统异步信号，即使用kill命令也不能使其中断）：对应状态码D</li><li>僵死（进程已终止，但进程描述符依然存在，直到父进程调用wait4()系统函数后将其释放）：对应状态码Z</li><li>停止（进程接收到SIGSTOP，SIGSTP，SIGTIN，SIGTOU等停止信号后停止运行），对应的状态码T</li></ul></li></ul><h3 id="任务的定时与延期"><a href="#任务的定时与延期" class="headerlink" title="任务的定时与延期"></a>任务的定时与延期</h3><ul><li>date</li><li>at：延时执行一个命令，可以用at命令来设定一个程序的执行时间，注意：at命令只能让程序执行一次，怎样结束输入并退出at命令：Ctrl + d <ul><li>atq：列出正在等待执行的at任务</li><li>atrm：删除正在等待执行的at任务，后加任务编号</li></ul></li><li>sleep：休息一会，在两句命令之间可以插入一定的暂停等待时间。touch test.txt;sleep 10;rm test.txt，此命令的意思是创建txt文件后暂停10s（默认为s），然后再删除它</li><li>crontab：定时执行程序，at命令只能执行某个（某几个）命令一次。crontab却可以重复执行命令，例如：每分钟，每小时，每天，每月，每星期等<ul><li>crontab -e：能修改配置和创建定时任务</li><li>ex：0 8 * * 5 top &gt; /tmp/xxx：每周五八点自动执行top命令，并重定向到/tmp/xxx文件<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/109.png" alt=""></li></ul></li></ul><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><ul><li>有些软件不能通过yum来安装，因为没有被收录到CentOS的软件仓库中，我们可以试着在网上找软件的rpm安装包</li><li>假如这两种方法都不行，就只能从源代码编译安装方法。一般通用的编译安装步骤就是从网上下载程序的源代码（通常被打包压缩成.tar.gz的格式），然后就是解压压缩包，运行解压之后的文件夹里的configure文件：./configure，再运行make来编译，最后运行sudo make install完成安装。可以用rar和unrar命令来压缩和解压.rar文件</li></ul><h3 id="服务器安装ssh服务"><a href="#服务器安装ssh服务" class="headerlink" title="服务器安装ssh服务"></a>服务器安装ssh服务</h3><ul><li>安装ssh：yum install openssh-server</li><li>启动ssh：systemctl start（或者restart）sshd</li><li>设置开机运行ssh：systemctl enable sshd</li></ul><h4 id="config文件配置ssh"><a href="#config文件配置ssh" class="headerlink" title="config文件配置ssh"></a>config文件配置ssh</h4><ul><li>全局的config文件有两个<ul><li>ssh客户端的配置：/etc/ssh/ssh_config</li><li>ssh服务端的配置：/etc/ssh/sshd_config</li><li>查看config文件的使用手册：ex：man sshd_config，查看ssh服务端config文件的使用手册</li></ul></li></ul><h4 id="ssh免密码登录"><a href="#ssh免密码登录" class="headerlink" title="ssh免密码登录"></a>ssh免密码登录</h4><ul><li>~表示root目录</li><li>ssh-keygen：首先使用这个命令，在客户端生成密钥对（公钥和私钥，默认用RSA非对称加密算法）</li><li>然后会在~/.ssh/目录下（隐藏文件），会新生成两个文件，ip_rsa.pub：公钥，ip_rsa：私钥</li><li>将客户端的公钥传送到服务端：ssh-copy-id root@服务端地址，等价于ssh-copy-id -i ~/.ssh/ip_rsa.pub root@服务端地址，因为它默认就是把.ssh目录下的公钥传送过去</li><li>ssh-copy-id把客户端的公钥追加到服务端的一个文件~/.ssh/authorized_keys</li><li>设置ssh免密码登录后仍想使用密码登录：ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no user@host</li></ul><h3 id="高级文本编译器Vim"><a href="#高级文本编译器Vim" class="headerlink" title="高级文本编译器Vim"></a>高级文本编译器Vim</h3><ul><li>安装Vim：yum install vim</li><li>在vim中有四种模式，交互模式，命令模式，插入模式，可视模式<ul><li>vim的默认模式是交互模式，也就是正常模式</li><li>进入插入模式需要按i键（I，a或A，o或O都可以进入插入模式）</li><li>从插入模式回到交互模式按esc键</li><li>在交互模式中，按冒号:进入命令模式，例如:w保存文件，:q退出，:wq保存并退出，:q!不保存最近修改且强制退出<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/111.png" alt=""></li></ul></li></ul><h4 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h4><ul><li>在交互模式下，w可以一个单词一个单词的移动，home或者0移动到行首，end或者$移动到行尾</li><li>:x 保存并退出，效果和:wq是一样的</li><li>:set nu 显示行号</li><li>:set nonu 隐藏行号</li></ul><h4 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h4><ul><li>x：删除字符，删除当前光标所在字符，也可以一次性删除多个字符，只需要在按x键之前输入数字即可。比如按下4，然后再按x就会删除当前光标所在后的4个字符（包含光标所在字符）</li><li>d：删除单词，行等。被删除的内容会被暂存在内存中，类似剪切，之后是可以粘贴的，之后会学到，要使用字母键p<ul><li>单词的定义是空格隔开的</li><li>dd：删除光标所在行，dd也可以和数字配合，一次性删除多行</li><li>dw：删除一个单词，将光标置于一个单词的首字母处，然后按下dw，就可以删除一个单词。如果光标不在单词首字母，它就会删除从当前字符开始到下一个空格前的所有字符，也可以一次性删除多个单词</li><li>d0和d$：删除行首和行末<ul><li>d0：删除从光标到行首的所有字符</li><li>d$：删除从光标到行末的所有字符</li></ul></li></ul></li><li>yy：复制行到内存中，与dd类似，但是dd是剪切，而yy是复制</li><li>yw：复制一个单词</li><li>y$：复制从光标到行末的所有字符</li><li>y0：复制从光标到行首的所有字符</li><li>p：粘贴，注意：用p来粘贴时，内容会被粘贴到光标之后。也可以将同样的内容粘贴多次，例如7p，表示粘贴7次</li><li>r：替换一个字符，在交互模式下，将光标置于想要替换的字符上，按下r键，接着输入你要替换的字符，例如rs表示替换当前字符为s</li><li>R：如果用大写的R，那么就是切换到替换模式了，左下角就会显示–REPLACE–，在替换模式下你可以一次性替换多个字符，esc即可退出替换模式</li><li>u：撤销操作，如果要撤销最近的修改，只需按下u键，如果要撤销多次操作，按下数字加u即可</li><li>Ctrl+r：重做，可以取消最近的撤销操作</li><li>g：跳转到指定行，7G：跳转到第7行，gg也可以实现同样的操作，7gg：跳转到第7行<ul><li>G：跳转到最后行</li><li>gg：跳转到第一行</li><li>跳转到指定行：行号+G或者行号+gg</li></ul></li></ul><h4 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h4><ul><li>分屏，合并，查找等等</li><li>/：在交互模式下按下/，就会进入查找模式，输入你要查找的字符串，然后按下回车，光标就会转到文件中下一个查找到的匹配处，例如/see会查出所有see并高亮显示。如果字符串不存在，就会显示”Pattern not found”，表示没有找到匹配项<ul><li>如果要查找下一个匹配项，需要按n键。如果要反向查找，需要按N</li><li>用/来进行的查找是从当前光标处开始，向文件尾搜索。如果要从当前光标处开始，向文件开头搜索，那么只需要将/换成?即可，其他功能都是一样的</li></ul></li><li>:s 查找并替换，要实现字符串替换，有几种方法，最简单的就是:s/就字符串/新字符串，但这种方法只会替换光标所在行的第一个匹配的字符串<ul><li>:s/就字符串/新字符串，替换光标所在行的第一个匹配的字符串</li><li>:s/就字符串/新字符串/g，替换光标所在行的所有匹配的字符串</li><li>:#,# s/就字符串/新字符串/g，替换文件中第#行到第#行所有匹配的旧字符串为新字符串</li><li>:%s/就字符串/新字符串/g，替换文件中所有匹配到的字符串（最常用）</li></ul></li><li>:r 合并文件，实现在光标所在行的下一行插入一个文件的内容，例如:r+另一个文件名，可以使用tab键来补全文件名</li><li>:sp 横向分屏，只需要输入:sp，按下回车即可，默认是横向分屏<ul><li>:sp 另一个文件名，就可以实现在两个分开的屏幕中分别打开两个不同的文件</li></ul></li><li>:vsp 垂直分屏</li><li>分屏模式下的主要快捷键<ul><li>ctrl + w 然后再 ctrl + w就会移动到下一个分屏</li><li>ctrl + w 然后按 j就会移动到下方的分屏，如果是h，k，l，那么就会移动到如下表所示的分屏<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/112.png" alt=""></li><li>ctrl + w 然后按+就会扩大当前的分屏</li><li>ctrl + w 然后按-就会缩小当前的分屏</li><li>ctrl + w 然后按=就会重新均匀分配每个分屏</li><li>ctrl + w 然后按r就会调换各个分屏的位置，用R是方向调换</li><li>ctrl + w 然后按q或者c会关闭当前的分屏，输入:quit或者:close也有一样的效果</li><li>ctrl + w 然后按o只保留当前所在分屏，关闭其他。输入:only也有一样的效果</li></ul></li><li>:! 运行外部命令，可以在不离开vim的情况下运行外部命令，只需要输入:!然后接命令名称，例如:!ls就是vim下运行ls命令，命令运行完以后按回车键或命令来继续</li></ul><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ul><li>1.mv和cp的区别<ul><li>mv是移动文件/目录，可以对文件/目录进行重命名。而cp是复制文件</li></ul></li><li>2.怎么查看压缩文件内容<ul><li>tar -tf + xxx.tar.gz</li></ul></li><li>3.怎么查看运行进程全名<ul><li>ps aux | awk ‘{print $NF}’</li></ul></li><li>4.如何查看进程的调用关系<ul><li>ps -ef 查看第二列第三列，第二列是进程号，第三列是父进程id，父进程调用子进程。查看进程之间的调用关系 pstree</li></ul></li><li>5.用awk怎么判断变量A是否包含变量B<ul><li>awk -v a=$a -v b=$b ‘a-b{print a}’</li></ul></li><li>如何查看某个文件的创建时间<ul><li>stat+文件名</li></ul></li><li>如何实现监控CPU10分钟内的使用变化。如：间隔10s，读取一次数据<ul><li>uptime 或者 top</li></ul></li><li>如何打印红色输出<ul><li>echo -e “\e[1;33mlhz\e[0m”</li></ul></li><li>如何生成10G文件<ul><li>dd if=/dev/zero of=filename bs=1G count=10</li></ul></li><li>实现输出一下明天的日期<ul><li>date -d tomorrow</li></ul></li><li>如何监听端口以及使用该端口的进程<ul><li>netstat -antupl</li></ul></li><li>用tar如何实现压缩后删除原文件<ul><li>tar -zcvf lhz.log.tar.gz lhz.log –remove-files</li></ul></li><li>如何创建指定时间的文件<ul><li>touch -t”202103131010” test.log</li></ul></li><li>仅使用awk获取/etc/password中dy1用户的UID<br>  * </li><li>如何获取服务器当前内存使用情况<ul><li>free -m或者top</li></ul></li><li>用root创建当前多级目录，并将目录拥有者改为dy1，权限修改为777<ul><li>mkdir -p test1/test2/test3 &amp;&amp; chown -R dy1:dy1 test1 &amp;&amp; chmod -R 777 test1</li></ul></li><li>列出当前目录下所有不以.txt结尾的文件<ul><li>ls | grep -vE “.txt$”</li></ul></li><li>怎么判断网卡eth0是否存在<ul><li>ip a show eth0</li></ul></li><li>将文件xxx.txt中所有的换行替换为空格<ul><li>sed’s/\n/ /g’ xxx.txt</li><li>cat xxx.txt | tr ‘\n’ ‘ ‘</li></ul></li><li>rm的-rf参数有什么作用，什么情况下可以使用<ul><li>-rf其中r是递归删除文件，f是强制删除，不管存不存在；使用rm的时候，最好不要使用rm -rf进行删除。如果必须要使用，路径不要使用变量</li></ul></li><li>如何查看文件的前100行<ul><li>head -n 100 xxx.txt</li></ul></li><li>请对“39,23,13,43,221,34,13”进行逆向排序输出<ul><li>echo “39,23,13,43,221,34,13” | tr ‘,’ ‘\n’ | sort -nr</li></ul></li><li>如何判断一个文件是不是打包文件<ul><li>file xxx.tar | grep “tar achive”</li></ul></li><li>请找出/home/dy1/目录下超过100M的文件<ul><li>find /home/dy1/ -size +100M</li></ul></li><li>如何修改一个文件的所属用户以及用户组为dy1<ul><li>chown dy1:dy1 xxx</li></ul></li><li>打印/etc/password最后一列<ul><li>awk ‘{print $NF}’ /etc/password</li></ul></li><li>请写出你知道的查看cpu负载的几种方法<ul><li>uptime或者top</li></ul></li><li>如何查看系统从开机到现在运行了多长时间<ul><li>uptime</li></ul></li><li>如何查看mysql这个进程的进程号<ul><li>ps aux | grep mysql | awk ‘{print $2}’</li></ul></li><li>如何统计一个文件有多少行<ul><li>cat xxx.txt | wc -l</li></ul></li><li>如何测试10.10.10.10到10.10.10.11的22端口的连通性（tcp）<ul><li>在10.10.10.10上执行telnet 10.10.10.11 22</li></ul></li><li>如何查看当前服务器的默认路由<ul><li>ip r | grep default 或 route -n观察destination是0.0.0.0的条目</li></ul></li><li>如何查看当前服务器的内核版本<ul><li>uname -r</li></ul></li><li>如何实现复制A/目录下的所有以.py结尾文件到B/目录<ul><li>rsync -vzrtopg –include=’*.py’A/B</li></ul></li><li>假设某集成的pid是2222，简述kill掉其父进程的过程<ul><li>ps -ef找出pid为2222的父进程，然后使用kill -9父进程id杀掉</li></ul></li><li>如何生成一个safeops用户<ul><li>useradd safeops -m -d “/home/safeops” -s /bin/bash</li></ul></li><li>列出当前文件夹下所有文件的详细信息，并按时间排序<ul><li>ls -lt</li></ul></li><li>如何统计一个文件有多少字符<ul><li>wc -m 文件名</li></ul></li><li>使用top命令，如何查看当前可用内存<ul><li>top命令的第四五行，free+buffer+cached</li></ul></li><li>如何判断一个文件是否为二进制文件<ul><li>file -b 文件名，有binary即为二进制文件</li></ul></li><li>设A服务器上有一个db_test数据库，有tal_testA,tal_testB,tbl_testC三张表<ul><li>1.使用mysqldump导出db_test数据库，并打包压缩存放到/tmp/db_test.tar.gz文件中，请写出命令<ul><li>mysqldump -h Aip -u user -p passwd db_test | gzip &gt; /tmp/db_test.tar.gz</li></ul></li><li>2.使用select语句导出题设中三个数据表的内容，并打包压缩存放到/tmp/db_test.tar.gz文件中，请写出对应命令<ul><li>mysql -h Aip -u user -p passwd tbl_colander -e”select * from tbl_testA” | gzip &gt; /tmp/db_test.tar.gz</li><li>mysql -h Aip -u user -p passwd tbl_colander -e”select * from tbl_testB” | gzip &gt; /tmp/db_test.tar.gz</li><li>mysql -h Aip -u user -p passwd tbl_colander -e”select * from tbl_testC” | gzip &gt; /tmp/db_test.tar.gz</li></ul></li><li>解压题1中的数据包，并导入到db_test_new数据库中<ul><li>gunzip /tmp/db_test.tar.gz &gt; mysql -u user -p passwd db_test_new</li></ul></li><li>解压题2中的数据包，使用load语句将数据表分别导入，tal_testA_new,tal_testB_new,tal_testC_new,三个数据表中<ul><li>使用load语句要比使用insert语句将近快20倍的速度，平时开发中很少涉及导入大量数据，所以，平时都是使用insert语句导入。</li><li>gunzip /tmp/db_test.tar.gz /tmp/db_test</li><li>load data infile ‘tbl_testA.txt’ into table db_test.tbl_testA_new</li><li>load data infile ‘tbl_testB.txt’ into table db_test.tbl_testB_new</li><li>load data infile ‘tbl_testC.txt’ into table db_test.tbl_testC_new</li></ul></li></ul></li></ul><h3 id="软件服务器基础"><a href="#软件服务器基础" class="headerlink" title="软件服务器基础"></a>软件服务器基础</h3><ul><li>1.如何在NS-2017_02_14.log文件中获取到关键字CSingeChat的信息<ul><li>cat NS-2017_02_14.log | grep CSingeChat</li></ul></li><li>如何远程登录一个ip为10.17.64.68的linux服务器<ul><li>ssh 用户名@10.17.64.68</li><li>指定端口：ssh -p 8080 用户名@10.17.64.68</li></ul></li><li>如何为进程创建软链接，链接到所需的脚本代码<ul><li>ln -s 源文件 目标文件</li></ul></li><li>如何在当前路径查找后缀为.bin的相关文件<ul><li>find . -name “*.bin”</li></ul></li><li>如何删除一个非空目录/tmp<ul><li>rm -r tmp</li></ul></li><li>如果执行命令chmod 746 file.txt,该文件的权限是？<ul><li>当前用户拥有所有权限，组用户具有读权限，其他用户拥有读写权限</li><li>等价于chmod u=rwx,g=r,o=rw file.txt</li></ul></li><li>某文件的权限是d-rw-r–r–，用8进制来标识是什么，该文件的属性是什么<ul><li>第2到4位代表当前用户的权限。第5到7位代表组用户的权限。第8到10位代表其他用户的权限。</li><li>用8进制来标识是644，该文件只用当前用户具有读写权限，其他只拥有读权限</li></ul></li><li>如何给文件改名，将user.bin改成new_user.bin<ul><li>mv user.bin new_user.bin</li></ul></li><li>如何给debian系统安装一个deb文件</li><li>如何在后台运行一个叫做PD的进程</li><li>前台启动的进程如何终止<ul><li>kill -9 PID</li></ul></li><li>如何杀死一个正在运行的，命名为NS的进程<ul><li>ps -ef | grep NS 查出它的PID</li><li>kill -9 PID</li></ul></li><li>如何添加一个新用户<ul><li>useradd lhz -u 520（指定用户ID）</li></ul></li><li>在linux下，设备是通过什么来访问的<ul><li>通过文件方式来访问,就是将设备当做一个特殊的文件来进行读写等操作</li></ul></li><li>如何确认两个服务器之间的网络可以直接连接</li><li>vim编辑器，如何修改内容退出，如何不修改内容退出<ul><li>wq修改退出  !q（强制退出）不修改内容退出</li></ul></li><li>如何分页显示大文本文件</li><li>如果一个文件无执行权限，如何添加可执行权限<ul><li>chmod a+r filename</li></ul></li><li>如何将当前目录下所有的.txt文件压缩到文件this.tar.gz<ul><li>tar -zcvf this.tar.gz *.txt</li></ul></li><li>用vim打开一个文件，如何用字母new来替换字母old<ul><li>:1,$s/old/new/g</li><li>:%s/old/new/g</li></ul></li><li>linux中能够匹配100~999的正则表达式是<ul><li>[1-9][0-9]{2}</li></ul></li><li>如何查看linux系统运行的时间<ul><li>uptime</li></ul></li><li>如何查看某个进程所占用的内存的大小<ul><li>ps aux | grep 进程名</li></ul></li><li>如何查看某个进程的CPU使用率<ul><li>ps aux | grep 进程名</li></ul></li><li>如何在进程中使用linux命令</li><li>进程间通信主要有哪些方式，各有什么特点</li><li>多线程是如何却确保对资源的唯一访问的</li><li>gcc编译工具如何将c语言分步转换成可执行文件</li><li>如何查找进程崩溃的原因</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis之resultMap</title>
      <link href="/2021/04/05/mybatis-resultmap/"/>
      <url>/2021/04/05/mybatis-resultmap/</url>
      
        <content type="html"><![CDATA[<h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><h3 id="实体类与数据库字段不一致"><a href="#实体类与数据库字段不一致" class="headerlink" title="实体类与数据库字段不一致"></a>实体类与数据库字段不一致</h3><pre><code>&lt;select id=&quot;getById&quot; resultMap=&quot;BaseResultMap&quot;&gt;    select * from student where id=#{id}&lt;/select&gt;</code></pre><p>查出来发现字段不一致的属性值为空</p><p>解决：</p><ul><li><p>方法一：为列名指定别名 , 别名和java实体类的属性名一致 .</p><pre><code>&lt;select id=&quot;getById&quot; resultType=&quot;com.imooc.mimall.pojo.Student&quot;&gt;  select id,name,t_id as t from student where id=#{id}&lt;/select&gt;</code></pre></li><li><p>方案二：使用结果集映射-&gt;ResultMap 【推荐】</p><pre><code>&lt;select id=&quot;getById&quot; resultMap=&quot;BaseResultMap&quot;&gt;  select * from student where id=#{id}&lt;/select&gt;</code></pre></li></ul><resultMap id="BaseResultMap" type="com.imooc.mimall.pojo.Student">    <!-- id为主键 -->    <id column="id" jdbcType="INTEGER" property="id"/>    <!-- column是数据库表的列名 , property是对应实体类的属性名 -->    <result column="t_id" jdbcType="INTEGER" property="t"/>    <result column="name" jdbcType="VARCHAR" property="name"/></resultMap>```<h3 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h3><ul><li>多个学生对应一个老师</li><li>场景：如何查出所有学生信息，以及对应的老师的信息</li></ul><pre><code>@Datapublic class Student {    private Integer id;    private String name;    //多个学生可以是同一个老师，即多对一    private Teacher teacher;}</code></pre><pre><code>@Datapublic class Teacher {    private Integer id;    private String name;}</code></pre><p>*方法一：（子查询） reslutMap+association</p><p>先查出所有学生信息，然后根据tid查出对应老师信息</p><pre><code>&lt;select id=&quot;queryAll&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select * from student    &lt;/select&gt;    &lt;!--    思路：        1.先查出所有的学生的信息        2.根据查询出来的学生的tId，寻找对应的老师        3.然后再用resultMap结果集映射    --&gt;    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.mimall.pojo.Student&quot;&gt;        &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt;        &lt;!--            复杂的属性，需要单独处理            对象：association            集合：collection            column是数据库表的列名 , property是对应实体类的属性名，javaType属性类型，select根据column的嵌套查询        --&gt;        &lt;association property=&quot;teacher&quot; column=&quot;t_id&quot; javaType=&quot;com.imooc.mimall.pojo.Teacher&quot; select=&quot;getById&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;getById&quot; resultType=&quot;com.imooc.mimall.pojo.Teacher&quot;&gt;        select * from teacher where id=#{id}    &lt;/select&gt;</code></pre><ul><li>方式二：（按结果集嵌套查询）</li></ul><pre><code>    &lt;select id=&quot;queryAll&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select s.id sid,s.name sname,t.name tname,t.id tid from student s , teacher t where s.t_id = t.id    &lt;/select&gt;    &lt;!--    按查询结果嵌套处理    思路：       1. 直接查询出结果，进行结果集的映射    --&gt;    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.mimall.pojo.Student&quot;&gt;        &lt;id column=&quot;sid&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;sname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt;        &lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;        &lt;association property=&quot;teacher&quot; javaType=&quot;com.imooc.mimall.pojo.Teacher&quot;&gt;            &lt;id property=&quot;id&quot; column=&quot;tid&quot;/&gt;            &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;        &lt;/association&gt;    &lt;/resultMap&gt;</code></pre><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><ul><li>一个老师有多个学生</li></ul><pre><code>@Datapublic class Student {    private Integer id;    private String name;    private Integer tId;}</code></pre><pre><code>@Datapublic class Teacher {    private Integer id;    private String name;    private List&lt;Student&gt; students;}</code></pre><ul><li>方式一：（子查询）resultMap+collection</li></ul><p>先根据id查出老师的信息，然后根据老师的id查出学生的信息</p><pre><code>    &lt;select id=&quot;getSutdentById&quot; resultType=&quot;com.imooc.mimall.pojo.Student&quot;&gt;        select * from student where t_id = #{id}    &lt;/select&gt;    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.mimall.pojo.Teacher&quot;&gt;        &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt;        &lt;!--        1. 集合的话，使用collection！               JavaType和ofType都是用来指定对象类型的               JavaType是用来指定pojo中属性的类型               ofType指定的是映射到list集合属性中pojo的类型。               column是一对多的外键 , 写的是一的主键的列名        --&gt;        &lt;collection property=&quot;students&quot; ofType=&quot;com.imooc.mimall.pojo.Student&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; select=&quot;getSutdentById&quot;&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;getTeacherById&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select * from teacher where id=#{id}    &lt;/select&gt;</code></pre><ul><li>方式二：按结果集嵌套查询</li></ul><pre><code>    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.mimall.pojo.Teacher&quot;&gt;        &lt;id column=&quot;tid&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;tname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt;        &lt;collection property=&quot;students&quot; ofType=&quot;com.imooc.mimall.pojo.Student&quot; javaType=&quot;ArrayList&quot;&gt;            &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt;            &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;            &lt;result property=&quot;tId&quot; column=&quot;tid&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;       &lt;!--   思路:       1. 从学生表和老师表中查出学生id，学生姓名，老师姓名       2. 对查询出来的操作做结果集映射           1. 集合的话，使用collection！               JavaType和ofType都是用来指定对象类型的               JavaType是用来指定pojo中属性的类型               ofType指定的是映射到list集合属性中pojo的类型。   --&gt;    &lt;select id=&quot;getTeacherById&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select t.name tname,t.id tid,s.name sname,s.id sid from teacher t,student s where s.t_id = t.id and t.id=#{id}    &lt;/select&gt;</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1、关联-association</p><p>2、集合-collection</p><p>3、所以association是用于一对一和多对一，而collection是用于一对多的关系</p><p>4、JavaType和ofType都是用来指定对象类型的</p><ul><li>JavaType是用来指定pojo中属性的类型</li><li>ofType指定的是映射到list集合属性中pojo的类型。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis之动态sql</title>
      <link href="/2021/02/27/mybatis-dong-tai-sql/"/>
      <url>/2021/02/27/mybatis-dong-tai-sql/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是动态Sql"><a href="#什么是动态Sql" class="headerlink" title="什么是动态Sql"></a>什么是动态Sql</h2><p>如果有比较复杂的业务，我们需要写复杂的SQL语句，往往需要拼接，而拼接SQL，稍微不注意，由于引号，空格等缺失可能都会导致错误。那么怎么去解决这个问题呢？</p><p>这就是本篇所讲的使用 mybatis 动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。</p><h3 id="动态SQL-if-语句"><a href="#动态SQL-if-语句" class="headerlink" title="动态SQL:if 语句"></a>动态SQL:if 语句</h3><p>根据 username 和 sex 来查询数据。如果username为空，那么将只根据sex来查询；反之只根据username来查询</p><p>首先不使用 动态SQL 来书写</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token keyword">select</span> id<span class="token operator">=</span><span class="token string">"selectUserByUsernameAndSex"</span>        resultType<span class="token operator">=</span><span class="token string">"user"</span> parameterType<span class="token operator">=</span><span class="token string">"com.ys.po.User"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token comment" spellcheck="true">-- 这里和普通的sql 查询语句差不多，对于只有一个参数，后面的 #{id}表示占位符，里面不一定要写id,</span>            写啥都可以，但是不要空着，如果有多个参数则必须写pojo类里面的属性 <span class="token comment" spellcheck="true">--></span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> username<span class="token operator">=</span><span class="token comment" spellcheck="true">#{username} and sex=#{sex}</span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">select</span><span class="token operator">></span></code></pre><p>上面的查询语句，我们可以发现，如果 #{username} 为空，那么查询结果也是空，如何解决这个问题呢？使用 if 来判断</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token keyword">select</span> id<span class="token operator">=</span><span class="token string">"selectUserByUsernameAndSex"</span> resultType<span class="token operator">=</span><span class="token string">"user"</span> parameterType<span class="token operator">=</span><span class="token string">"com.ys.po.User"</span><span class="token operator">></span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span>        <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"username != null"</span><span class="token operator">></span>           username<span class="token operator">=</span><span class="token comment" spellcheck="true">#{username}</span>        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"username != null"</span><span class="token operator">></span>           <span class="token operator">and</span> sex<span class="token operator">=</span><span class="token comment" spellcheck="true">#{sex}</span>        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">select</span><span class="token operator">></span></code></pre><p>这样写我们可以看到，如果 sex 等于 null，那么查询语句为 select * from user where username=#{username},但是如果usename 为空呢？那么查询语句为 select * from user where and sex=#{sex}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句</p><h3 id="动态SQL-if-where-语句"><a href="#动态SQL-if-where-语句" class="headerlink" title="动态SQL:if+where 语句"></a>动态SQL:if+where 语句</h3><pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token keyword">select</span> id<span class="token operator">=</span><span class="token string">"selectUserByUsernameAndSex"</span> resultType<span class="token operator">=</span><span class="token string">"user"</span> parameterType<span class="token operator">=</span><span class="token string">"com.ys.po.User"</span><span class="token operator">></span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span>    <span class="token operator">&lt;</span><span class="token keyword">where</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"username != null"</span><span class="token operator">></span>           username<span class="token operator">=</span><span class="token comment" spellcheck="true">#{username}</span>        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"username != null"</span><span class="token operator">></span>           <span class="token operator">and</span> sex<span class="token operator">=</span><span class="token comment" spellcheck="true">#{sex}</span>        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">where</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">select</span><span class="token operator">></span></code></pre><p>这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。</p><h3 id="动态SQL-if-set-语句"><a href="#动态SQL-if-set-语句" class="headerlink" title="动态SQL:if+set 语句"></a>动态SQL:if+set 语句</h3><p>同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token comment" spellcheck="true">-- 根据 id 更新 user 表的数据 --></span><span class="token operator">&lt;</span><span class="token keyword">update</span> id<span class="token operator">=</span><span class="token string">"updateUserById"</span> parameterType<span class="token operator">=</span><span class="token string">"com.ys.po.User"</span><span class="token operator">></span>    <span class="token keyword">update</span> <span class="token keyword">user</span> u        <span class="token operator">&lt;</span><span class="token keyword">set</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"username != null and username != ''"</span><span class="token operator">></span>                u<span class="token punctuation">.</span>username <span class="token operator">=</span> <span class="token comment" spellcheck="true">#{username},</span>            <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"sex != null and sex != ''"</span><span class="token operator">></span>                u<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token comment" spellcheck="true">#{sex}</span>            <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">set</span><span class="token operator">></span>     <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id}</span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">update</span><span class="token operator">></span></code></pre><p>这样写，如果第一个条件 username 为空，那么 sql 语句为：update user u set u.sex=? where id=?</p><p>如果第一个条件不为空，那么 sql 语句为：update user u set u.username = ? ,u.sex = ? where id=?</p><h3 id="动态SQL-choose-when-otherwise-语句"><a href="#动态SQL-choose-when-otherwise-语句" class="headerlink" title="动态SQL:choose(when,otherwise) 语句"></a>动态SQL:choose(when,otherwise) 语句</h3><p>有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token keyword">select</span> id<span class="token operator">=</span><span class="token string">"selectUserByChoose"</span> resultType<span class="token operator">=</span><span class="token string">"com.ys.po.User"</span> parameterType<span class="token operator">=</span><span class="token string">"com.ys.po.User"</span><span class="token operator">></span>      <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span>      <span class="token operator">&lt;</span><span class="token keyword">where</span><span class="token operator">></span>          <span class="token operator">&lt;</span>choose<span class="token operator">></span>              <span class="token operator">&lt;</span><span class="token keyword">when</span> test<span class="token operator">=</span><span class="token string">"id !='' and id != null"</span><span class="token operator">></span>                  id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id}</span>              <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">when</span><span class="token operator">></span>              <span class="token operator">&lt;</span><span class="token keyword">when</span> test<span class="token operator">=</span><span class="token string">"username !='' and username != null"</span><span class="token operator">></span>                  <span class="token operator">and</span> username<span class="token operator">=</span><span class="token comment" spellcheck="true">#{username}</span>              <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">when</span><span class="token operator">></span>              <span class="token operator">&lt;</span>otherwise<span class="token operator">></span>                  <span class="token operator">and</span> sex<span class="token operator">=</span><span class="token comment" spellcheck="true">#{sex}</span>              <span class="token operator">&lt;</span><span class="token operator">/</span>otherwise<span class="token operator">></span>          <span class="token operator">&lt;</span><span class="token operator">/</span>choose<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">where</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">select</span><span class="token operator">></span></code></pre><p>也就是说，这里我们有三个条件，id,username,sex，只能选择一个作为查询条件</p><p>如果 id 不为空，那么查询语句为：select * from user where  id=?</p><p>如果 id 为空，那么看username 是否为空，如果不为空，那么语句为 select * from user where  username=?;</p><p>如果 username 为空，那么查询语句为 select * from user where sex=?</p><h3 id="动态SQL-trim-语句"><a href="#动态SQL-trim-语句" class="headerlink" title="动态SQL:trim 语句"></a>动态SQL:trim 语句</h3><p>trim标记是一个格式化的标记，可以完成set或者是where标记的功能</p><p>①、用 trim 改写上面第二点的 if+where 语句</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token keyword">select</span> id<span class="token operator">=</span><span class="token string">"selectUserByUsernameAndSex"</span> resultType<span class="token operator">=</span><span class="token string">"user"</span> parameterType<span class="token operator">=</span><span class="token string">"com.ys.po.User"</span><span class="token operator">></span>        <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token comment" spellcheck="true">-- &lt;where></span>            <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"username != null"</span><span class="token operator">></span>               username<span class="token operator">=</span><span class="token comment" spellcheck="true">#{username}</span>            <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"username != null"</span><span class="token operator">></span>               <span class="token operator">and</span> sex<span class="token operator">=</span><span class="token comment" spellcheck="true">#{sex}</span>            <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">where</span><span class="token operator">></span>  <span class="token comment" spellcheck="true">--></span>        <span class="token operator">&lt;</span>trim prefix<span class="token operator">=</span><span class="token string">"where"</span> prefixOverrides<span class="token operator">=</span><span class="token string">"and | or"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"username != null"</span><span class="token operator">></span>               <span class="token operator">and</span> username<span class="token operator">=</span><span class="token comment" spellcheck="true">#{username}</span>            <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"sex != null"</span><span class="token operator">></span>               <span class="token operator">and</span> sex<span class="token operator">=</span><span class="token comment" spellcheck="true">#{sex}</span>            <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>trim<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">select</span><span class="token operator">></span></code></pre><p>prefix：前缀　　　　　　</p><p>prefixoverride：去掉第一个and或者是or</p><p>②、用 trim 改写上面第三点的 if+set 语句</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token comment" spellcheck="true">-- 根据 id 更新 user 表的数据 --></span>    <span class="token operator">&lt;</span><span class="token keyword">update</span> id<span class="token operator">=</span><span class="token string">"updateUserById"</span> parameterType<span class="token operator">=</span><span class="token string">"com.ys.po.User"</span><span class="token operator">></span>        <span class="token keyword">update</span> <span class="token keyword">user</span> u            <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token comment" spellcheck="true">-- &lt;set></span>                <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"username != null and username != ''"</span><span class="token operator">></span>                    u<span class="token punctuation">.</span>username <span class="token operator">=</span> <span class="token comment" spellcheck="true">#{username},</span>                <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>                <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"sex != null and sex != ''"</span><span class="token operator">></span>                    u<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token comment" spellcheck="true">#{sex}</span>                <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">set</span><span class="token operator">></span> <span class="token comment" spellcheck="true">--></span>            <span class="token operator">&lt;</span>trim prefix<span class="token operator">=</span><span class="token string">"set"</span> suffixOverrides<span class="token operator">=</span><span class="token string">","</span><span class="token operator">></span>                <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"username != null and username != ''"</span><span class="token operator">></span>                    u<span class="token punctuation">.</span>username <span class="token operator">=</span> <span class="token comment" spellcheck="true">#{username},</span>                <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>                <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"sex != null and sex != ''"</span><span class="token operator">></span>                    u<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token comment" spellcheck="true">#{sex},</span>                <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>trim<span class="token operator">></span>         <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id}</span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">update</span><span class="token operator">></span></code></pre><p>suffix：后缀　　</p><p>suffixoverride：去掉最后一个逗号（也可以是其他的标记，就像是上面前缀中的and一样）</p><p>③、insert插入</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token keyword">insert</span> id<span class="token operator">=</span><span class="token string">"insertSelective"</span> parameterType<span class="token operator">=</span><span class="token string">"com.imooc.mimall.pojo.OrderItem"</span><span class="token operator">></span>        <span class="token keyword">insert</span> <span class="token keyword">into</span> mall_order_item        <span class="token operator">&lt;</span>trim prefix<span class="token operator">=</span><span class="token string">"("</span> suffix<span class="token operator">=</span><span class="token string">")"</span> suffixOverrides<span class="token operator">=</span><span class="token string">","</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"id != null"</span><span class="token operator">></span>                id<span class="token punctuation">,</span>            <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"userId != null"</span><span class="token operator">></span>                user_id<span class="token punctuation">,</span>            <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>trim<span class="token operator">></span>        <span class="token operator">&lt;</span>trim prefix<span class="token operator">=</span><span class="token string">"values ("</span> suffix<span class="token operator">=</span><span class="token string">")"</span> suffixOverrides<span class="token operator">=</span><span class="token string">","</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"id != null"</span><span class="token operator">></span>                <span class="token comment" spellcheck="true">#{id,jdbcType=INTEGER},</span>            <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"userId != null"</span><span class="token operator">></span>                <span class="token comment" spellcheck="true">#{userId,jdbcType=INTEGER},</span>            <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>trim<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">insert</span><span class="token operator">></span></code></pre><p>suffix：后缀　　</p><p>suffixoverride：去掉最后一个逗号（也可以是其他的标记，就像是上面前缀中的and一样）</p><h3 id="动态SQL-SQL-片段"><a href="#动态SQL-SQL-片段" class="headerlink" title="动态SQL: SQL 片段"></a>动态SQL: SQL 片段</h3><p>有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。</p><p>比如：假如我们需要经常根据用户名和性别来进行联合查询，那么我们就把这个代码抽取出来，如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token comment" spellcheck="true">-- 定义 sql 片段 --></span><span class="token operator">&lt;</span>sql id<span class="token operator">=</span><span class="token string">"selectUserByUserNameAndSexSQL"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"username != null and username != ''"</span><span class="token operator">></span>        <span class="token operator">AND</span> username <span class="token operator">=</span> <span class="token comment" spellcheck="true">#{username}</span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"sex != null and sex != ''"</span><span class="token operator">></span>        <span class="token operator">AND</span> sex <span class="token operator">=</span> <span class="token comment" spellcheck="true">#{sex}</span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>sql<span class="token operator">></span></code></pre><p>引用 sql 片段</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token keyword">select</span> id<span class="token operator">=</span><span class="token string">"selectUserByUsernameAndSex"</span> resultType<span class="token operator">=</span><span class="token string">"user"</span> parameterType<span class="token operator">=</span><span class="token string">"com.ys.po.User"</span><span class="token operator">></span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span>    <span class="token operator">&lt;</span>trim prefix<span class="token operator">=</span><span class="token string">"where"</span> prefixOverrides<span class="token operator">=</span><span class="token string">"and | or"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token comment" spellcheck="true">-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --></span>        <span class="token operator">&lt;</span>include refid<span class="token operator">=</span><span class="token string">"selectUserByUserNameAndSexSQL"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>include<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token comment" spellcheck="true">-- 在这里还可以引用其他的 sql 片段 --></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>trim<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">select</span><span class="token operator">></span></code></pre><p>注意：①、最好基于 单表来定义 sql 片段，提高片段的可重用性</p><p>②、在 sql 片段中最好不要包括 where </p><h3 id="动态SQL-foreach-语句"><a href="#动态SQL-foreach-语句" class="headerlink" title="动态SQL: foreach 语句"></a>动态SQL: foreach 语句</h3><p>需求：我们需要查询 user 表中 id 分别为1,2,3的用户</p><p>sql语句：select * from user where id=1 or id=2 or id=3</p><p>select * from user where id in (1,2,3)</p><p>①、建立一个 UserVo 类，里面封装一个 List<Integer> ids 的属性</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>ys<span class="token punctuation">.</span>vo<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserVo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//封装多个用户的id</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ids<span class="token punctuation">;</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">getIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ids<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setIds</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ids<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ids <span class="token operator">=</span> ids<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>　　</code></pre><p>②、我们用 foreach 来改写 select * from user where id=1 or id=2 or id=3</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token keyword">select</span> id<span class="token operator">=</span><span class="token string">"selectUserByListId"</span> parameterType<span class="token operator">=</span><span class="token string">"com.ys.vo.UserVo"</span> resultType<span class="token operator">=</span><span class="token string">"com.ys.po.User"</span><span class="token operator">></span>    <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span>    <span class="token operator">&lt;</span><span class="token keyword">where</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token comment" spellcheck="true">--</span>            collection:指定输入对象中的集合属性            item:每次遍历生成的对象            <span class="token keyword">open</span>:开始遍历时的拼接字符串            <span class="token keyword">close</span>:结束时拼接的字符串            separator:遍历对象之间需要拼接的字符串            <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token punctuation">(</span>id<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">or</span> id<span class="token operator">=</span><span class="token number">2</span> <span class="token operator">or</span> id<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">--></span>        <span class="token operator">&lt;</span>foreach collection<span class="token operator">=</span><span class="token string">"ids"</span> item<span class="token operator">=</span><span class="token string">"id"</span> <span class="token keyword">open</span><span class="token operator">=</span><span class="token string">"and ("</span> <span class="token keyword">close</span><span class="token operator">=</span><span class="token string">")"</span> separator<span class="token operator">=</span><span class="token string">"or"</span><span class="token operator">></span>            id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id}</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>foreach<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">where</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">select</span><span class="token operator">></span></code></pre><p>测试：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//根据id集合查询user表数据</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectUserByListId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    String statement <span class="token operator">=</span> <span class="token string">"com.ys.po.userMapper.selectUserByListId"</span><span class="token punctuation">;</span>    UserVo uv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserVo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ids <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ids<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ids<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ids<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    uv<span class="token punctuation">.</span><span class="token function">setIds</span><span class="token punctuation">(</span>ids<span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>User<span class="token operator">></span> listUser <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>statement<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>User u <span class="token operator">:</span> listUser<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    session<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>③、我们用 foreach 来改写 select * from user where id in (1,2,3)</p><pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token keyword">select</span> id<span class="token operator">=</span><span class="token string">"selectUserByListId"</span> parameterType<span class="token operator">=</span><span class="token string">"com.ys.vo.UserVo"</span> resultType<span class="token operator">=</span><span class="token string">"com.ys.po.User"</span><span class="token operator">></span>        <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span>        <span class="token operator">&lt;</span><span class="token keyword">where</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token comment" spellcheck="true">--</span>                collection:指定输入对象中的集合属性                item:每次遍历生成的对象                <span class="token keyword">open</span>:开始遍历时的拼接字符串                <span class="token keyword">close</span>:结束时拼接的字符串                separator:遍历对象之间需要拼接的字符串                <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">--></span>            <span class="token operator">&lt;</span>foreach collection<span class="token operator">=</span><span class="token string">"ids"</span> item<span class="token operator">=</span><span class="token string">"id"</span> <span class="token keyword">open</span><span class="token operator">=</span><span class="token string">"and id in ("</span> <span class="token keyword">close</span><span class="token operator">=</span><span class="token string">") "</span> separator<span class="token operator">=</span><span class="token string">","</span><span class="token operator">></span>                <span class="token comment" spellcheck="true">#{id}</span>            <span class="token operator">&lt;</span><span class="token operator">/</span>foreach<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">where</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">select</span><span class="token operator">></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2020/07/21/linux-chang-yong-ming-ling/"/>
      <url>/2020/07/21/linux-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>此文记录一些常用的linux命令</li></ul><h3 id="常用命令（重要）"><a href="#常用命令（重要）" class="headerlink" title="常用命令（重要）"></a>常用命令（重要）</h3><ul><li>ls/ll：列出当前目录下文件</li><li>cat：查看文件内容</li><li>cd：进入指定目录</li><li>mkdir：创建空白的文件夹</li><li>touch：创建一个文件</li><li>rm -rf：删除当前目录下的所有文件及目录</li><li>cp：复制文件或目录</li><li>mv：移动文件或目录</li><li>ps -ef | grep xxx：查看进程</li><li>kill：杀死进程</li><li>free-m：显示的当前内存的使用,-m的意思是M字节来显示内容</li><li>tar -xvf file.tar：解压tar包</li></ul><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><ul><li>ps -ef | grep xxx (xxx表示进程名)</li><li>ps -aux | grep xxx (-aux显示所有状态)</li></ul><h3 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h3><p>vi/vim</p><ul><li>i 写入</li><li>:wq 保存退出</li><li>:q! 或者ctrl + c 退出不保存</li><li>shift+g 跳至当前文本的最后一行</li></ul><h3 id="top⭐"><a href="#top⭐" class="headerlink" title="top⭐"></a>top⭐</h3><p>显示系统中各个进程的资源占用状况，可以看是否有 CPU 占用过大的进程。</p><h3 id="less和more"><a href="#less和more" class="headerlink" title="less和more"></a>less和more</h3><p>less和more相似，但使用less可以随意浏览文件，而more仅能向前移动，却不能先后移动，而且less在查看之前不会加载整个文件</p><h3 id="如何查找指定的文件"><a href="#如何查找指定的文件" class="headerlink" title="如何查找指定的文件"></a>如何查找指定的文件</h3><p>find</p><ul><li>语法：find path [options] params</li><li>作用：在指定目录下查找文件</li><li>find -name “target.java”：查找当前目录下的这个文件</li><li>find ~ -name “target.java”：精确查找文件，可以查找所有目录下的这个文件</li><li>find ~ -name “target*”：模糊查找target开头的文件</li><li>find ~ -iname “target*”：不区分文件名大小写去查找文件</li><li>man find：更多关于find指令的使用说明</li></ul><h3 id="检索文件内容"><a href="#检索文件内容" class="headerlink" title="检索文件内容"></a>检索文件内容</h3><p>grep</p><ul><li>语法：grep [options] pattern file</li><li>作用：查找文件里符合条件的字符串</li><li>grep “moo” target*：查找当前目录下文件内容里有”moo”且文件名以target开头的文件</li><li>grep “moo”：由于没有指定去哪个文件查找，所以从当前标准输入中去获取数据</li></ul><h4 id="常用的方式"><a href="#常用的方式" class="headerlink" title="常用的方式"></a>常用的方式</h4><ul><li>grep ‘partial[true]‘ bsc-plat-al-data.info.log：在内容里面查找包含某个字段的文件，并将相关的行展示出来</li><li>grep -o ‘engine[[0-9a-z]*]‘：在内容里面查找包含某个字段的文件，筛选出符合正则表达式的内容并返回</li><li>grep -v ‘grep’：过滤掉包含相关字符串的内容</li></ul><h4 id="管道操作符"><a href="#管道操作符" class="headerlink" title="管道操作符 |"></a>管道操作符 |</h4><ul><li>可将指令连接起来，前一个指令的输出作为后一个指令的输入</li><li>find ~ | grep “target”：相当于find ~ -name “target*”</li><li>find ~：递归查找home目录下所有的文件和文件夹</li><li>grep “target”：从当前标准输入下获取有target的文件</li></ul><h5 id="使用管道注意的要点"><a href="#使用管道注意的要点" class="headerlink" title="使用管道注意的要点"></a>使用管道注意的要点</h5><ul><li>只处理前一个命令正确输出，不处理错误输出</li><li>右边命令必须能够接收标准输入流，否则传递过程中数据就会被抛弃</li><li>sed,awk,grep,cut,head,top,less,more,wc,join,sort,split等</li></ul><h3 id="对文件内容做统计"><a href="#对文件内容做统计" class="headerlink" title="对文件内容做统计"></a>对文件内容做统计</h3><p>awk</p><ul><li>语法：awk [options] ‘cmd’ file</li><li>依次处理文件的每一行，并读取里面的每一个字段，可用作统计。</li><li>一次读取一行文本，按输入分隔符进行切片，切成多个组成部分</li><li>将切片直接保存在内建的变量中，$1,$2…($0表示行的全部)</li><li>支持对单个切片的判断，支持循环判断，默认分隔符为空格</li></ul><h4 id="常用的方式-1"><a href="#常用的方式-1" class="headerlink" title="常用的方式"></a>常用的方式</h4><ul><li>awk ‘{print $1,$4}’ netstat.txt：筛选出文件中第一列和第四列的数据，其中文件也可以是多个</li><li>awk ‘$1==”tcp” &amp;&amp; $2==1 {print $0}’ netstat.txt：筛选出第一列为tcp，第二列为1的所有数据</li><li>awk ‘{enginearr[$1]++}END{for(i in enginearr)print i “\t” enginearr[i]}’：对第一列逐行从头至尾做统计，筛选出不同文本内容出现的次数，enginearr[$1]表示有相同的内容就+1</li><li>awk的默认分隔符是空格，此操作可以修改分隔符，此时修改为逗号：awk -F “,” ‘{print $2}’ test.txt</li></ul><h3 id="批量替换文本内容"><a href="#批量替换文本内容" class="headerlink" title="批量替换文本内容"></a>批量替换文本内容</h3><p>sed</p><ul><li>语法：sed [options] ‘sed command’ filename</li><li>适合用于对文本的行内容进行处理</li></ul><h4 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h4><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><ul><li>如果不加 - i，那么仅仅只是输出被替换之后的文件，并不会修改文件</li><li>sed -i ‘s/^Str/String/‘ test.java：把每行中以Str开头的字符串替换成String</li><li>sed -i ‘s/.$/;/‘ test.java：把每行中以.号结尾的字符替换为分号</li><li>sed -i ‘s/Jack/me/g’：把每一行中所有的Jack替换成me，注意加了g之后是全局，没加就是只替换第一个出现的Jack</li></ul><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul><li>sed -i ‘/^ *$/d’ test.java：删除所有的空行，^ *$表示空行，/d表示删除符合条件的行</li><li>sed -i ‘/Integer/d’ test.java：删除以Integer开头的行</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程，并发</title>
      <link href="/2020/07/19/mian-shi-java-duo-xian-cheng/"/>
      <url>/2020/07/19/mian-shi-java-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。</p><h4 id="临界区："><a href="#临界区：" class="headerlink" title="临界区："></a>临界区：</h4><p>每个进程中访问临界资源的那段代码称为临界区（criticalsection），每次只允许一个进程进入临界区，进入后，不允许其他进程进入。</p><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>进程是操作系统进行资源分配的基本单位。进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。一个进程中可以有多个线程，线程是cpu独立调度的基本单位。同一个进程中的多个线程之间可以并发执行，它们共享进程资源。</p><p>进程是系统中独立存在的实体，它可以拥有自己独立的资源，每个进程都拥有自己私有的地址空间，在没有进程本身运行的情况下是不能访问其中的内容的。</p><p>线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程主要是为了节约CPU时间，发挥利用，根据具体情况而定。线程的运行中需要使用计算机的内存资源和CPU。</p><p>进程与线程区别总结：</p><ul><li>进程是系统资源分配的最小单位，线程是程序执行的最小单位</li><li>进程使用独立的数据空间，而线程共享进程的数据空间</li><li>进程的切换比线程的切换开销大</li><li>通信方式不同</li></ul><h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><ul><li>无名管道：半双工的，即数据只能在一个方向上流动，只能用于具有亲缘关系的进程之间的通信，可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li><li>FIFO命名管道：FIFO是一种文件类型，可以在无关的进程之间交换数据，与无名管道不同，FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li><li>消息队列：消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</li><li>信号量：信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</li><li>共享内存：共享内存指两个或多个进程共享一个给定的存储区，一般配合信号量使用。</li></ul><h3 id="线程通信方式"><a href="#线程通信方式" class="headerlink" title="线程通信方式"></a>线程通信方式</h3><ul><li>volatile 关键字： 使用共享内存的思想，多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。</li><li>使用 Object 类的wait() 和 notify() 方法</li><li>使用 ReentrantLock 结合 Condition的 await() 和 signal() 方法</li><li>信号量 Semaphore，可以控制对共享资源的并发访问度，有 accquire() 和 release() 方法</li><li>CountDownLatch：控制线程等待，计数器功能，可以用来等待多个线程执行任务后进行汇总</li><li>CyclicBarrier：类似CountDownLatch但更强大，可以重复使用，控制多个线程，一般测试使用</li><li>基本LockSupport实现线程间的阻塞和唤醒</li></ul><h3 id="java进程与线程的关系"><a href="#java进程与线程的关系" class="headerlink" title="java进程与线程的关系"></a>java进程与线程的关系</h3><ul><li>java对操作系统提供的功能进行包装，包括进程和线程</li><li>运行一个程序会产生一个进程，一个进程至少包括一个线程</li><li>每个进程对应一个JVM实例，多个线程共享JVM中的堆</li><li>java采用单线程编程模型，程序会自动创建主线程（main）</li><li>主线程会创建子线程，原则上要后于子线程完成执行、</li></ul><h3 id="理解线程的同步与异步、阻塞与非阻塞"><a href="#理解线程的同步与异步、阻塞与非阻塞" class="headerlink" title="理解线程的同步与异步、阻塞与非阻塞"></a>理解线程的同步与异步、阻塞与非阻塞</h3><p>同步与异步的区别是任务是否在同一个线程中执行的 ，阻塞与非阻塞的区别是异步执行任务时线程是不是会阻塞等待结果还是会继续执行后面的逻辑</p><h3 id="线程的-run-和-start-有什么区别"><a href="#线程的-run-和-start-有什么区别" class="headerlink" title="线程的 run()和 start()有什么区别"></a>线程的 run()和 start()有什么区别</h3><ul><li>看下面一段代码</li></ul><pre><code>    public class Test {        public static void main(String[] args) {            Thread t = new Thread(){              @Override              public void run(){                  attack();              }            };            t.run();        //current Thread:main            t.start();      //current Thread:Thread-0            System.out.println(&quot;current Thread:&quot; + Thread.currentThread().getName());       //current Thread:main        }        public static void attack() {            System.out.println(&quot;current Thread:&quot; + Thread.currentThread().getName());        }    }</code></pre><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/74.png" alt=""></p><ul><li>调用start()方法会创建一个新的子线程并启动</li><li>run()方法只是Thread类里面的一个普通方法的调用，还是在主线程里面启动</li></ul><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><h4 id="继承Thread类创建线程类"><a href="#继承Thread类创建线程类" class="headerlink" title="继承Thread类创建线程类"></a>继承Thread类创建线程类</h4><ul><li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li><li>创建Thread子类的实例，即创建了线程对象。</li><li>调用线程对象的start()方法来启动该线程。</li></ul><pre><code>    //继承Thread类，并重写run方法    public class MyThread extends Thread {        private String name;        public MyThread(String name) {            this.name = name;        }        @Override        public void run() {            for (int i = 0; i &lt; 10; i++) {                System.out.println(name + &quot; : &quot; + i);            }        }    }    //创建子类的实例，调用start方法启动线程    public class MyThreadTest {        public static void main(String[] args) {            MyThread m1 = new MyThread(&quot;li&quot;);            MyThread m2 = new MyThread(&quot;hua&quot;);            MyThread m3 = new MyThread(&quot;zhou&quot;);            m1.start();            m2.start();            m3.start();        }    }</code></pre><h4 id="通过Runnable接口创建线程类"><a href="#通过Runnable接口创建线程类" class="headerlink" title="通过Runnable接口创建线程类"></a>通过Runnable接口创建线程类</h4><ul><li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li><li>调用线程对象的start()方法来启动该线程。</li></ul><pre><code>    //实现runnable接口，并重写run方法    public class MyRunnable implements Runnable {        private String name;        public MyRunnable(String name) {            this.name = name;        }        @Override        public void run() {            for (int i = 0; i &lt; 10; i++) {                System.out.println(name + &quot; : &quot; + i);            }        }    }    //创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象    public class MyRunnableTest {        public static void main(String[] args) {            MyRunnable m1 = new MyRunnable(&quot;li&quot;);            MyRunnable m2 = new MyRunnable(&quot;hua&quot;);            MyRunnable m3 = new MyRunnable(&quot;zhou&quot;);            Thread t1 = new Thread(m1);            Thread t2 = new Thread(m2);            Thread t3 = new Thread(m3);            t1.start();            t2.start();            t3.start();        }    }</code></pre><h4 id="Thread和Runnable是什么关系"><a href="#Thread和Runnable是什么关系" class="headerlink" title="Thread和Runnable是什么关系"></a>Thread和Runnable是什么关系</h4><ul><li>Thread是实现了Runnable接口的类，使得run支持多线程</li><li>因为类单一继承的原则，推荐多使用Runnable接口</li></ul><h4 id="通过Callable和Future创建线程"><a href="#通过Callable和Future创建线程" class="headerlink" title="通过Callable和Future创建线程"></a>通过Callable和Future创建线程</h4><ul><li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li><li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li><li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li><li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li></ul><pre><code>    //创建Callable接口的实现类，并实现call()方法    public class MyCallable implements Callable&lt;String&gt; {        @Override        public String call() throws Exception {            String value = &quot;test&quot;;            System.out.println(&quot;ready to work&quot;);            Thread.sleep(5000);            System.out.println(&quot;work done&quot;);            return value;        }    }    public class FutureTaskDemo {        public static void main(String[] args) throws ExecutionException, InterruptedException {            //传入一个Callable类型的对象            FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new MyCallable());            //传入一个FutureTask类型的对象，因为FutureTask实现了RunnableFuture接口，而RunnableFuture接口继承自Runnable接口            new Thread(futureTask).start();            //futureTask.isDone()方法表示任务是否已经完成，若任务完成，则返回true；            if(!futureTask.isDone()){                System.out.println(&quot;task in not finished, please wait&quot;);            }            //get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；            System.out.println(&quot;task in done: &quot;+ futureTask.get());        }    }</code></pre><h5 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h5><p>FutureTask实现了Future接口，Future接口有5个方法：</p><ul><li>1、boolean cancel(boolean mayInterruptIfRunning)</li></ul><p>cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</p><ul><li>2、boolean isCancelled()</li></ul><p>如果任务在正常结束之前被被取消返回true</p><ul><li>3、boolean isDone()</li></ul><p>正常结束、异常或者被取消导致任务完成，将返回true</p><ul><li>4、V get()</li></ul><p>方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；如果任务在等待过程中被终端将抛出InterruptedException，如果任务被取消将抛出CancellationException，如果任务中执行过程中发生异常将抛出ExecutionException。</p><ul><li>5、V get(long timeout, TimeUnit unit)</li></ul><p>任务最多在给定时间内完成并返回结果，如果没有在给定时间内完成任务将抛出TimeoutException。</p><h4 id="runnable-和-callable-有什么区别"><a href="#runnable-和-callable-有什么区别" class="headerlink" title="runnable 和 callable 有什么区别"></a>runnable 和 callable 有什么区别</h4><ul><li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</li><li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li></ul><h4 id="通过线程池创建线程"><a href="#通过线程池创建线程" class="headerlink" title="通过线程池创建线程"></a>通过线程池创建线程</h4><ul><li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li><li>调用Executors.newCachedThreadPool方法创建线程池。</li><li>提交线程任务,返回一个Future接口,参数为Callable实现类对象</li><li>结束要调用shutdown关闭线程池。</li></ul><pre><code>    public class MyCallable implements Callable&lt;String&gt; {        @Override        public String call() throws Exception {            String value = &quot;test&quot;;            System.out.println(&quot;ready to work&quot;);            Thread.sleep(5000);            System.out.println(&quot;work done&quot;);            return value;        }    }    public class MyThreadPool {        public static void main(String[] args) {            //创建一个线程池            ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();            //提交线程任务,返回一个Future接口,参数为Callable实现类对象            Future&lt;String&gt; future = newCachedThreadPool.submit(new MyCallable());            if(!future.isDone()){                System.out.println(&quot;task in not finished , please wait&quot;);            }            try {                System.out.println(future.get());            } catch (InterruptedException e) {                e.printStackTrace();            } catch (ExecutionException e) {                newCachedThreadPool.shutdown();            }        }    }</code></pre><h3 id="如何给run方法传参"><a href="#如何给run方法传参" class="headerlink" title="如何给run方法传参"></a>如何给run方法传参</h3><ul><li>构造函数传参</li><li>成员变量传参（getset方法）</li><li>回调函数传参</li></ul><h3 id="如何实现处理线程的返回值"><a href="#如何实现处理线程的返回值" class="headerlink" title="如何实现处理线程的返回值"></a>如何实现处理线程的返回值</h3><p>实现的方式主要有三种</p><ul><li>主线程等待法</li><li>使用Thread类的join()阻塞当前线程等待子线程处理完毕</li></ul><p>没使用这两种方法时value值为null</p><pre><code>    public class Test implements Runnable{        private String value;        public static void main(String[] args) throws InterruptedException {            Test test = new Test();            Thread t = new Thread(test);            t.start();            //join方法            t.join();            //主线程等待法    //        while (test.value==null){    //            Thread.sleep(100);    //        }            System.out.println(&quot;value = &quot;+ test.value);        }        @Override        public void run() {            try {                Thread.sleep(5000);            } catch (InterruptedException e) {                e.printStackTrace();            }            value = &quot;we have data now&quot;;        }    }</code></pre><ul><li>通过Callable接口实现：通过FutureTask或者线程池获取</li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul><li>新建(New)：创建后尚未启动的线程的状态（没有调用start()方法）</li><li>运行(Runnable)：包含Running和Ready（Running是正在运行，而Ready是就绪状态，调用了线程的start方法，已经在java虚拟机中执行，等待获取操作系统资源如CPU，操作系统调度运行。）</li><li>无限期等待(Waiting)：不会被分配CPU执行时间，需要显示被唤醒<ul><li>没有设置Timeout参数的Object.wait()方法</li><li>没有设置Timeout参数的Object.join()方法</li><li>LockSupport.park()方法</li></ul></li><li>限期等待(Timed Waiting)：在一定时间后由系统自动唤醒<ul><li>Thread.sleep()方法</li><li>设置了Timeout参数的Object.wait()方法</li><li>设置了Timeout参数的Object.join()方法</li><li>LockSupport.parkNanos()方法</li><li>LockSupport.parkUntil()方法</li></ul></li><li>阻塞(Blocked)：等待获取排他锁，线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</li><li>结束(Terminated)：已终止线程的状态，线程已经结束执行，若此时调用start()方法则会报错IllegalThreadStateException</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/75.jpeg" alt=""></p><h3 id="线程状态以及状态之间的转换"><a href="#线程状态以及状态之间的转换" class="headerlink" title="线程状态以及状态之间的转换"></a>线程状态以及状态之间的转换</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/76.png" alt=""></p><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><p>基本差别：</p><ul><li>sleep是Thread类的方法，wait是Object类的方法</li><li>sleep()方法可以在任何地方使用</li><li>wait()方法只能在synchronized方法或synchronized块中使用</li><li>sleep需要捕获异常、wait不需要</li></ul><p>最本质的区别：</p><ul><li>Thread.sleep()方法只会让出CPU，不会导致锁行为的改变</li><li>wait()方法不仅让出CPU，还会释放占有的同步资源锁</li></ul><h4 id="sleep-0-的意义。"><a href="#sleep-0-的意义。" class="headerlink" title="sleep(0)的意义。"></a>sleep(0)的意义。</h4><p>Thread.Sleep(0) 并非是真的要线程挂起0毫秒，意义在于这次调用Thread.Sleep(0)的当前线程确实的被冻结了一下，让其他线程有机会优先执行。Thread.Sleep(0) 是你的线程暂时放弃cpu，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个让位动作。</p><p>在线程没退出之前，线程有三个状态，就绪态，运行态，等待态。sleep(n)之所以在n秒内不会参与CPU竞争，是因为，当线程调用sleep(n)的时候，线程是由运行态转入等待态，线程被放入等待队列中，等待定时器n秒后的中断事件，当到达n秒计时后，线程才重新由等待态转入就绪态，被放入就绪队列中，等待队列中的线程是不参与cpu竞争的，只有就绪队列中的线程才会参与cpu竞争，所谓的cpu调度，就是根据一定的算法（优先级，FIFO等），从就绪队列中选择一个线程来分配cpu时间。</p><p>而sleep(0)之所以马上回去参与cpu竞争，是因为调用sleep(0)后，因为0的原因，线程直接回到就绪队列，而非进入等待队列，只要进入就绪队列，那么它就参与cpu竞争。</p><h3 id="notify-和-notifyAll-有什么区别"><a href="#notify-和-notifyAll-有什么区别" class="headerlink" title="notify()和 notifyAll()有什么区别"></a>notify()和 notifyAll()有什么区别</h3><ul><li>锁池EntiyList：当一个线程需要调用此方法时必须获得该对象的锁，而该对象的锁被其他线程占用，该线程就需要在一个地方等待锁释放，这个地方就是锁池。（准备抢锁的池子） </li><li>等待池WaitSet：调用了wait方法的线程会释放锁并进入等待池，在等待池的线程不会竞争锁。（休息的池子）</li><li>notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会</li><li>notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会。</li><li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li></ul><h3 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h3><p>概念：当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是当前线程调度器可能会忽略这个暗示</p><ul><li>对锁的行为无影响</li></ul><pre><code>    public class yeld {        public static void main(String[] args) {            ThreadDemo demo = new ThreadDemo();            Thread thread = new Thread(demo, &quot;花花&quot;);            Thread thread1 = new Thread(demo, &quot;草草&quot;);            thread.start();            thread1.start();        }    }    class ThreadDemo implements Runnable {        @Override        public void run() {            for (int i = 0; i &lt; 5; i++) {                if (i == 3) {                    System.out.println(&quot;当前的线程是     &quot; + Thread.currentThread().getName());                    Thread.yield();                }                System.out.println(&quot;执行的是    &quot; + Thread.currentThread().getName());            }        }    }    //运行结果    执行的是    草草    执行的是    草草    执行的是    草草    当前的线程是     草草//并没有礼让    执行的是    草草    执行的是    草草    执行的是    花花    执行的是    花花    执行的是    花花    当前的线程是     草草//礼让啦    执行的是    花花    执行的是    花花</code></pre><p>可以看到有的让了，有的没有让</p><h3 id="如何中断线程"><a href="#如何中断线程" class="headerlink" title="如何中断线程"></a>如何中断线程</h3><p>在以前可以通过thread.stop()可以让一个线程去停止另一个线程，但这种方法太暴力，突然间停止其他线程会导致被停止的线程无法完成一些清理工作，所以stop()已经被抛弃了。</p><p>目前使用的方法：</p><ul><li>调用Thread.interrput(),通知线程应该中断了（但是否中断由线程决定，不能真正中断线程）</li></ul><p>而Thread.interrupt的作用其实不是中断线程，而是通知线程应该中断了，给这个线程发一个信号，告诉它，它应该结束了，设置一个停止标志， 具体到底中断还是运行，应该由被通知的线程自己处理。具体来说,对一个线程，调用interrupt()时：</p><ul><li>如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait、1.5中的condition.await、以及可中断的通道上的 I/O 操作方法后可进入阻塞状态），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法（sleep、join、wait、1.5中的condition.await及可中断的通道上的 I/O 操作方法）调用处抛出InterruptedException异常，</li><li>如果线程处于正常活动状态，那么会将该线程中的中断标志设置为true，仅此而已， 被设置中断标志的线程将继续正常执行，不受影响。<br>interrupt()并不能真正中断线程，需要被调用的线程自己进行配合才行。一个线程如果有被中断的需求，那么就可以这样做：<ul><li>在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志，就自行停止线程</li><li>在调用阻塞方法时正常处理InterruptException异常，</li></ul></li></ul><h3 id="线程安全的主要诱因"><a href="#线程安全的主要诱因" class="headerlink" title="线程安全的主要诱因"></a>线程安全的主要诱因</h3><ul><li>存在共享数据（也称临界资源）</li><li>存在多条线程共同操作这些数据</li></ul><p>解决问题的根本方法：同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作</p><h3 id="保证线程安全的方法⭐"><a href="#保证线程安全的方法⭐" class="headerlink" title="保证线程安全的方法⭐"></a>保证线程安全的方法⭐</h3><p>前提是保证下面三个方面：</p><ul><li>1.原子性（可以用到lock和synchronized关键字）<br>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，即一个操作或者多个操作，要么全部执行并且在执行过程中不会被任何因素打断，要么就不执行，</li><li>2可见性（Volatile，Synchronized，lock）<br>可见性是当多个线程访问一个变量时，一个线程改变了变量的值，其他线程立马可以知道这个改变。</li><li>3.有序性：即程序的执行是按照代码编写的先后顺序执行的，</li></ul><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>根据获取锁的分类：获取对象锁和获取类锁</p><p>获取锁对象锁的两种方法：</p><ul><li>同步代码块(synchronized(this),synchronized(类实例对象))，锁是小括号中的实例对象</li><li>同步非静态方法（synchronized method），锁是当前对象的实例对象</li></ul><p>获取类锁的两种方法</p><ul><li>同步代码块（synchronized(类.class)），锁是小括号中的类对象（Class对象）</li><li>同步静态方法（synchronized static method），锁是当前对象的类对象（Class对象）</li></ul><p>测试代码</p><pre><code>    public class SyncThread implements Runnable {        @Override        public void run() {            String threadName = Thread.currentThread().getName();            if (threadName.startsWith(&quot;A&quot;)) {                async();            } else if (threadName.startsWith(&quot;B&quot;)) {                syncObjectBlock1();            } else if (threadName.startsWith(&quot;C&quot;)) {                syncObjectMethod1();            } else if (threadName.startsWith(&quot;D&quot;)) {                syncClassBlock1();            } else if (threadName.startsWith(&quot;E&quot;)) {                syncClassMethod1();            }        }        /**         * 异步方法         */        private void async() {            try {                System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                Thread.sleep(1000);                System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            } catch (InterruptedException e) {                e.printStackTrace();            }        }        /**         * 方法中有 synchronized(this|object) {} 同步代码块         */        private void syncObjectBlock1() {            System.out.println(Thread.currentThread().getName() + &quot;_SyncObjectBlock1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            synchronized (this) {                try {                    System.out.println(Thread.currentThread().getName() + &quot;_SyncObjectBlock1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                    Thread.sleep(1000);                    System.out.println(Thread.currentThread().getName() + &quot;_SyncObjectBlock1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }        /**         * synchronized 修饰非静态方法         */        private synchronized void syncObjectMethod1() {            System.out.println(Thread.currentThread().getName() + &quot;_SyncObjectMethod1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            try {                System.out.println(Thread.currentThread().getName() + &quot;_SyncObjectMethod1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                Thread.sleep(1000);                System.out.println(Thread.currentThread().getName() + &quot;_SyncObjectMethod1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            } catch (InterruptedException e) {                e.printStackTrace();            }        }        private void syncClassBlock1() {            System.out.println(Thread.currentThread().getName() + &quot;_SyncClassBlock1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            synchronized (SyncThread.class) {                try {                    System.out.println(Thread.currentThread().getName() + &quot;_SyncClassBlock1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                    Thread.sleep(1000);                    System.out.println(Thread.currentThread().getName() + &quot;_SyncClassBlock1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }        private synchronized static void syncClassMethod1() {            System.out.println(Thread.currentThread().getName() + &quot;_SyncClassMethod1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            try {                System.out.println(Thread.currentThread().getName() + &quot;_SyncClassMethod1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));                Thread.sleep(1000);                System.out.println(Thread.currentThread().getName() + &quot;_SyncClassMethod1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    public class SyncDemo {        public static void main(String... args) {            SyncThread syncThread = new SyncThread();            Thread A_thread1 = new Thread(syncThread, &quot;A_thread1&quot;);            Thread A_thread2 = new Thread(syncThread, &quot;A_thread2&quot;);            Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);            Thread B_thread2 = new Thread(syncThread, &quot;B_thread2&quot;);            Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);            Thread C_thread2 = new Thread(syncThread, &quot;C_thread2&quot;);            Thread D_thread1 = new Thread(syncThread, &quot;D_thread1&quot;);            Thread D_thread2 = new Thread(syncThread, &quot;D_thread2&quot;);            Thread E_thread1 = new Thread(syncThread, &quot;E_thread1&quot;);            Thread E_thread2 = new Thread(syncThread, &quot;E_thread2&quot;);            A_thread1.start();            A_thread2.start();            B_thread1.start();            B_thread2.start();            C_thread1.start();            C_thread2.start();            D_thread1.start();            D_thread2.start();            E_thread1.start();            E_thread2.start();        }    }</code></pre><h3 id="对象锁和类锁的总结"><a href="#对象锁和类锁的总结" class="headerlink" title="对象锁和类锁的总结"></a>对象锁和类锁的总结</h3><ul><li>有线程访问对象的同步代码块，另外的线程可以访问该对象的非同步代码块</li><li>若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步代码块的线程会被阻塞</li><li>若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象的同步方法的线程会被阻塞</li><li>若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步方法的线程会被阻塞，反之亦然</li><li>同一个类的不同对象的对象锁互不干扰</li><li>类锁由于也是一种特殊的对象锁，因此表现出和上述1，2，3，4一致，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁将会是同步的</li><li>类锁和对象锁互不干扰</li></ul><h4 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h4><p>当一个线程试图获取一个它已经获取的锁时，这个获取动作就会自动成功，这个就叫重入</p><p>可重入最大的作用是避免死锁</p><h3 id="sychronized底层实现原理"><a href="#sychronized底层实现原理" class="headerlink" title="sychronized底层实现原理"></a>sychronized底层实现原理</h3><p>实现synchronized的基础：</p><ul><li>java对象头</li><li>Monitor</li></ul><p>对象在内存中的布局：</p><ul><li>对象头</li><li>实例数据</li><li>对齐填充</li></ul><p>对象在内存中分为对象头，实例数据和对齐填充三个区域。在对象头中保存了锁标志位和指向 Monitor 对象的起始地址。当 Monitor 被某个线程占用后就会处于锁定状态。 synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 synchronized 修饰的方法使用是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h4 id="同步代码块实现原理"><a href="#同步代码块实现原理" class="headerlink" title="同步代码块实现原理"></a>同步代码块实现原理</h4><p>我们想看一段简单的代码：</p><pre><code>    public class SynchronizedDemo {        public void method() {            synchronized (this) {                System.out.println(&quot;Method 1 start&quot;);            }        }    }</code></pre><p>查看反编译后结果：<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/77.png" alt=""></p><ul><li>monitorenter：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下<ul><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</li><li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；</li><li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li></ul></li><li>monitorexit：执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。<ul><li>monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；</li></ul></li></ul><p>通过上面两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p><h4 id="同步方法实现原理"><a href="#同步方法实现原理" class="headerlink" title="同步方法实现原理"></a>同步方法实现原理</h4><p>同步方法：</p><pre><code>    public class SynchronizedMethod {        public synchronized void method() {            System.out.println(&quot;Hello World!&quot;);        }    }</code></pre><p>反编译之后的结果：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/78.png" alt=""></p><p>从编译的结果来看，方法的同步并没有通过指令 monitorenter 和 monitorexit 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了 ACC_SYNCHRONIZED 标示符。JVM就是根据该标示符来实现方法的同步的：<br>    * 当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p><h4 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h4><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/79.png" alt=""></p><ul><li>实例数据：存放类的属性数据信息，包括父类的属性信息；</li><li>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐；</li><li>对象头：Java对象头一般占有2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</li></ul><p>Synchronized用的锁就是存在Java对象头里的，那么什么是Java对象头呢？Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Class Pointer（类型指针）。其中 Class Pointer是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。 </p><h4 id="监视器（Monitor）"><a href="#监视器（Monitor）" class="headerlink" title="监视器（Monitor）"></a>监视器（Monitor）</h4><p>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。 </p><ul><li>MonitorEnter指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；</li><li>MonitorExit指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；</li></ul><p>那什么是Monitor？可以把它理解为 一个同步工具，也可以描述为 一种同步机制，它通常被 描述为一个对象。</p><p>与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。</p><p>也就是通常说Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始地址。</p><p>同时，Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。</p><h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><p>从JDK5引入了现代操作系统新增加的CAS原子操作（ JDK5中并没有对synchronized关键字做优化，而是体现在J.U.C中，所以在该版本concurrent包有更好的性能 ），从JDK6开始，就对synchronized的实现机制进行了较大调整，包括使用JDK5引进的CAS自旋之外，还增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略。由于此关键字的优化使得性能极大提高，同时语义清晰、操作简单、无需手动关闭，所以推荐在允许的情况下尽量使用此关键字，同时在性能上此关键字还有优化的空间。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。</p><p>在 JDK 1.6 中默认是开启偏向锁和轻量级锁的，可以通过-XX:-UseBiasedLocking来禁用偏向锁。</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的</p><p>所谓自旋锁，就是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。</p><p>自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短。自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它占用了CPU处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p><ul><li>多数情况下，共享数据的锁定状态持续时间较短，频繁地阻塞和唤醒线程不值得</li><li>通过让线程执行忙循环等待锁的释放，不让出CPU</li><li>缺点：若锁被其他线程长时间占用，会带来许多性能上面的开销</li></ul><p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整。</p><p>如果通过参数-XX:PreBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如多自旋一两次就可以获取锁），是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。那它如何进行适应性自旋呢？ </p><p>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p><ul><li>自旋次数不再固定</li><li>由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</li></ul><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>为了保证数据的完整性，在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除，锁消除可以节省毫无意义的请求锁的时间</p><p>在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？虽然没有显示使用锁，但是在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是 为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</p><p>在大多数的情况下，上述观点是正确的。但是如果一系列的连续加锁解锁操作，比如在for循环中进行加锁解锁，可能会导致不必要的性能损耗，所以引入锁粗话的概念。</p><p>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁<br>，避免反复加锁解锁</p><h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>无锁状态-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引入了偏向锁</p><ul><li>偏向锁是在单线程执行代码块时使用的机制，如果在多线程并发的环境下（即线程A尚未执行完同步代码块，线程B发起了申请锁的申请），则一定会转化为轻量级锁或者重量级锁。</li><li>核心思想：如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变为偏向锁结构，当线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需检查Mark Word的锁标记位为偏向锁以及当前线程Id等于Mark Word的ThreadId即可，这样就省去了大量有关锁申请的操作</li><li>不适合用于锁竞争比较强烈的多线程场合</li></ul><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁</p><p>适用的场景：线程交替执行同步块</p><p>若存在多线程同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>Synchronized是通过对象内部的一个叫做 监视器锁（Monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为 “重量级锁”。</p><h4 id="锁的优劣"><a href="#锁的优劣" class="headerlink" title="锁的优劣"></a>锁的优劣</h4><p>各种锁并不是相互代替的，而是在不同场景下的不同选择，绝对不是说重量级锁就是不合适的。每种锁是只能升级，不能降级，即由偏向锁-&gt;轻量级锁-&gt;重量级锁，而这个过程就是开销逐渐加大的过程。</p><ul><li>如果是单线程使用，那偏向锁毫无疑问代价最小，并且它就能解决问题，连CAS都不用做，仅仅在内存中比较下对象头就可以了；</li><li>如果出现了其他线程竞争，则偏向锁就会升级为轻量级锁；</li><li>如果其他线程通过一定次数的CAS尝试没有成功，则进入重量级锁；</li></ul><table><thead><tr><th align="left">锁</th><th align="left">优点</th><th align="left">缺点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">偏向锁</td><td align="left">加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级别的差异</td><td align="left">如果线程存在锁竞争，会带来额外的锁撤销的消耗</td><td align="left">只有一个线程访问同步块或者同步方法的场景</td></tr><tr><td align="left">轻量级锁</td><td align="left">竞争的线程不会阻塞，提高了响应速度</td><td align="left">若线程长时间抢不到锁，自旋会消耗CPU性能</td><td align="left">线程交替执行同步块或者同步方法的场景</td></tr><tr><td align="left">重量级锁</td><td align="left">线程竞争不使用自旋，不会消耗CPU</td><td align="left">线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td><td align="left">追求吞吐量，同步块或者同步方法执行时间较长的场景</td></tr></tbody></table><h3 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h3><p>ReentrantLock（再入锁）</p><ul><li>位于java.util.concurrent.locks包</li><li>和CountDownLatch，FutureTask，Semaphore一样基于AQS实现</li><li>能够实现比synchronized更细粒度的控制，如控制fairness</li><li>调用lock()之后，必须调用unlock()释放锁</li><li>性能未必比synchronized高（因为设置公平性会带来额外的开销），并且也是可重入的</li></ul><p>synchronized是非公平锁，而ReentrantLock是公平锁</p><p>ReentrantLock公平性的设置</p><ul><li>ReentrantLock fairLock = new ReentrantLock(true)</li><li>参数为ture时，倾向于将锁赋予等待时间最长的线程</li><li>公平锁：获取锁的顺序按先后调用lock方法的顺序（慎用）</li><li>非公平锁：抢占的顺序不一定，看运气</li><li>synchronized是非公平锁</li></ul><p>代码实现：</p><pre><code>    public class ReentrantLockDemo implements Runnable {        //设置公平性为true        private static ReentrantLock lock = new ReentrantLock(true);        @Override        public void run() {            while (true) {                try {                    lock.lock();                    System.out.println(Thread.currentThread().getName() + &quot; : get lock&quot;);                    Thread.sleep(1000);                } catch (Exception e) {                    e.printStackTrace();                } finally {                    lock.unlock();                }            }        }        public static void main(String[] args) {            ReentrantLockDemo lockDemo = new ReentrantLockDemo();            Thread t1 = new Thread(lockDemo);            Thread t2 = new Thread(lockDemo);            t1.start();            t2.start();        }    }    //输出，由此可见每个线程获取锁的几率是一样的，可见公平性    Thread-0 : get lock    Thread-1 : get lock    Thread-0 : get lock    Thread-1 : get lock    Thread-0 : get lock    Thread-1 : get lock    Thread-0 : get lock    Thread-1 : get lock    Thread-0 : get lock</code></pre><p>ReentrantLock将锁对象化</p><ul><li>判断是否有线程，或者某个特定线程，在排队等待获取锁</li><li>带超时的获取锁的尝试（这是synchronized做不到的，等待时间长的更容易获取锁，而synchronized可能就会超时失效）</li><li>感知有没有成功获取锁</li></ul><p>总结：</p><ul><li>synchronized是关键字，ReentrantLock是类</li><li>ReentrantLock可以对获取锁的等待时间进行设置，避免死锁</li><li>ReentrantLock可以获取各种锁的信息</li><li>ReentrantLock可以灵活地实现多路通知</li><li>机制：sync操作Mark Word，lock调用Unsafe类地park()方法</li></ul><h3 id="jmm"><a href="#jmm" class="headerlink" title="jmm"></a>jmm</h3><p>Java内存模型(Java Memory Model，JMM)JMM主要是为了规定了线程和内存之间的一些关系。根据JMM的设计，系统存在一个主内存(Main Memory)，Java中所有变量都储存在主存中，对于所有线程都是共享的。每条线程都有自己的工作内存(Working Memory)，工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作都是在工作内存中进行，线程之间无法相互直接访问，变量传递均需要通过主存完成。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/80.png" alt=""></p><p>jmm中的主内存</p><ul><li>存储java实例对象</li><li>包括成员变量，类信息，常量，静态变量等</li><li>属于数据共享的区域，多线程并发操作时会引发线程安全问题</li></ul><p>jmm的工作内存</p><ul><li>存储当前方法的所有本地变量信息，本地变量对其他线程不可见</li><li>字节码行号指示器，Native方法信息</li><li>属于线程私有数据区域，不存在线程安全问题</li></ul><h4 id="主内存与工作内存的数据存储类型以及操作方式归纳"><a href="#主内存与工作内存的数据存储类型以及操作方式归纳" class="headerlink" title="主内存与工作内存的数据存储类型以及操作方式归纳"></a>主内存与工作内存的数据存储类型以及操作方式归纳</h4><ul><li>方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中</li><li>引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中</li><li>成员变量，static变量，类信息均会被存储在主内存中</li><li>主内存共享的方式就是线程各拷贝一份数据到工作内存，操作完成后刷新回主内存</li></ul><h3 id="jvm和jmm之间的关系"><a href="#jvm和jmm之间的关系" class="headerlink" title="jvm和jmm之间的关系"></a>jvm和jmm之间的关系</h3><p>jmm中的主内存、工作内存与jvm中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。</p><ul><li>jmm和jvm内存区域划分是不同的概念层次</li><li>jmm描述的是一组规则，围绕原子性，有序性，可见性展开</li><li>相似点：存在共享区域和私有区域</li></ul><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>指令的基本概念：</p><ul><li>指令是指示计算机执行某种操作的命令，如：数据传送指令、算术运算指令、位运算指令、程序流程控制指令、串操作指令、处理器控制指令。指令不同于我们所写的代码，一行代码按照操作的逻辑可以分成多条指令。</li><li>举个例子：int a = 1； 这段代码大致可以分为两条指令：1.加载常量1；2.将常量1赋值给变量a。</li></ul><p>指令重排序：</p><ul><li>Java语言规范JVM线程内部维持顺序花语义，即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做指令的重排序。</li><li>指令重排序的意义：使指令更加符合CPU的执行特性，最大限度的发挥机器的性能，提高程的执行效率。</li></ul><p>需要满足的条件：</p><ul><li>在单线程环境下不能改变程序执行的结果</li><li>存在数据依赖关系的不允许重排序</li><li>即无法happens-before原则推导出来的，才能进行指令的重排序</li></ul><h3 id="happens-before的八大原则"><a href="#happens-before的八大原则" class="headerlink" title="happens-before的八大原则"></a>happens-before的八大原则</h3><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C</li><li>线程启动规则：对一个线程的start()方法先行发生于此线程的每一个操作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于对被中断线程的代码检测到线程中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束,Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化先行发生于它的finalize()方法的开始</li></ul><p>如果两个操作不满足上述任意一个happens-before原则，那么这两个操作就没有顺序的保障，JVM就可以对这两个操作进行指令重排序</p><p>如果A happens-before B，那么操作A在内存上所做的操作对操作B是可见的</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile是JVM提供的轻量级同步机制</p><ul><li>它保证被volatile修饰的共享变量对所有线程总是可见的</li><li>禁止指令的重排序优化</li><li>但它不能保证线程的安全性，因为 Java 里面的运算并非是原子操作（处理器要么把这组操作全部执行完，中间不允许被其他操作所打断，要么这组操作不要执行。） 如：int a = b + 1; 需要三步：取 a 的值，计算 a=b+1，然后把 a 的值写回内存 但是！ 这三个操作处理器是不一定就会连续执行的，有可能执行了第一个操作之后，处理器就跑去执行别的操作了 。</li></ul><p>volatile变量为何立即可见</p><ul><li>当写一个volatile变量时，JMM会把该线程对应工作内存中的共享变量值刷新到主内存中</li><li>当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，则只能从主内存中读取变量</li></ul><p>volatile如何禁止指令重排序：内存屏障（Memory Barrier）</p><ul><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性</li></ul><p>通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化</p><p>强制刷出各种CPU的缓存数据，因此任何CPUsh上的线程都能读取到这些数据的最新版本</p><p>单例的双重检测实现，此代码可能会出现线程安全问题，因为指令重排序的问题</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/81.png" alt=""></p><p>如何解决这个问题呢，只需给变量加上volatile关键字，禁止指令重排序即可</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/82.png" alt=""></p><h3 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h3><ul><li>volatile的本质是在告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主内存中读取；synchronized则是锁定当前变量，只有当前线程可以访问变量，其他线程会被阻塞直到该线程完成变量操作为止</li><li>volatile仅能在变量级别使用，synchronized可以在变量，方法和类级别上使用</li><li>volatile仅能实现变量修改的可见性，不能保证原子性；而synchronized可以保证变量修改的原子性和可见性</li><li>volatile不会造成线程的阻塞，synchronized可能会造成线程的阻塞</li><li>volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p><p>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。</p><p>CompareAndSwap，一种实现线程安全性的方法</p><ul><li>支持原子更新操作，适用于计数器，序列发生器等场景</li><li>属于乐观锁机制，号称lock-free，synchronized属于悲观锁</li><li>CAS操作失败时由开发者决定是继续尝试还是执行别的操作，而不是挂起或者阻塞</li></ul><h4 id="CAS的缺点："><a href="#CAS的缺点：" class="headerlink" title="CAS的缺点："></a>CAS的缺点：</h4><p>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p><ul><li>循环时间长开销很大。</li><li>只能保证一个变量的原子操作。</li><li>ABA问题。</li></ul><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？</p><p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效</p><h3 id="java线程池"><a href="#java线程池" class="headerlink" title="java线程池"></a>java线程池</h3><h4 id="为什么要使用线程池⭐"><a href="#为什么要使用线程池⭐" class="headerlink" title="为什么要使用线程池⭐"></a>为什么要使用线程池⭐</h4><ul><li>减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内存，而把服务器累趴下，提高线程的可管理性</li></ul><h4 id="创建线程池的方式（利用Executors）"><a href="#创建线程池的方式（利用Executors）" class="headerlink" title="创建线程池的方式（利用Executors）"></a>创建线程池的方式（利用Executors）</h4><ul><li>newFixedThreadPool(int nThreads) 创建一个固定线程数量的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，新的任务会暂存在任务队列中，待有线程空闲时便处理任务。</li><li>newCachedThreadPool()，处理大量短时间工作任务的线程池<ul><li>试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程</li><li>如果线程闲置的时间超过阈值，则会被终止并移出缓存</li><li>系统长时间闲置的时候，不会消耗什么资源</li></ul></li><li>newSingleThreadExecutor()创建唯一的工作者线程来执行任务，如果线程异常结束，会有另一个线程取代它</li><li>newSingleThreadScheduledExecutor()与newScheduledThreadPool(int corePoolSize)定时或者周期性的工作制度，两者的区别在于单一工作线程还是多个工作线程</li><li>newWorkStealingPool()内部会构建ForkJoinPool，利用working-stealing算法，并行的处理任务，不保证处理顺序</li></ul><p>前四个都是使用 ThreadPoolExecutor() 的不同初始化参数创建的。</p><p>场景：大量短期的任务场景适合使用 Cached 线程池，系统资源比较紧张时使用固定线程池。慎用无界队列，有OOM风险。自己项目有一个可能高吞吐量的场景就使用了 Cached 线程池</p><h5 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h5><ul><li>把大任务分割成若干个小任务并行执行，最终汇总每个小任务结果后得到大任务结果的框架</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/83.png" alt=""></p><p>work-stealing算法：某个线程从其他队列里窃取任务来执行，当有些队列任务已经完成了，其他队列还有任务没完成，完成任务的队列就可以帮助那些未完成队列任务的执行完成</p><h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><ul><li>Executor的框架：</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/84.png" alt=""></p><p>J.U.C的三个Executor接口</p><ul><li>Executor：运行新任务的简单接口，将任务提交和任务执行细节解耦</li><li>ExecutorService：具备管理执行器和任务生命周期的方法，提交任务机制更完善</li><li>ScheduledExecutorService：支持Future和定期执行任务</li></ul><h4 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h4><p>FixedThreadPool ， SingleThreadExecutor ， CachedThreadPool 三个方法内部均使用了 ThreadPoolExecutor 类。</p><pre><code>  public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler handler) </code></pre><p>参数含义如下：</p><ul><li>corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li>maximumPoolSize : 最大线程数量。</li><li>workQueue: 任务队列，当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li><li>keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li><li>unit : keepAliveTime 参数的时间单位。</li><li>threadFactory :线程工厂，用于创建线程，一般用默认即可，Executors.defaultThreadFactory()</li><li>handler :拒绝策略。当任务太多来不及处理时，如何拒绝任务。</li></ul><h5 id="线程池的拒绝策略⭐"><a href="#线程池的拒绝策略⭐" class="headerlink" title="线程池的拒绝策略⭐"></a>线程池的拒绝策略⭐</h5><ul><li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</li><li>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务(当前任务)</li><li>ThreadPoolExecutor.CallerRunsPolicy：由提交任务的线程直接处理该任务</li><li>实现RejectExecutionHandler接口的自定义handler</li></ul><h5 id="新任务提交execute执行后的判断"><a href="#新任务提交execute执行后的判断" class="headerlink" title="新任务提交execute执行后的判断"></a>新任务提交execute执行后的判断</h5><ul><li>如果运行的线程少于corePoolSize，则创建新线程来处理任务，即线程池中的其他线程是空闲的</li><li>如果线程池中的线程数量大于等于corePoolSize且小于maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务</li><li>如果设置的corePoolSize和maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，如workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理</li><li>如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务</li></ul><p>流程图：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/85.png" alt=""></p><h5 id="如何向线程池提交任务"><a href="#如何向线程池提交任务" class="headerlink" title="如何向线程池提交任务"></a>如何向线程池提交任务</h5><p>有2种：分别使用execute 方法和 submit 方法</p><h5 id="执行execute-方法和submit-方法的区别是什么呢？"><a href="#执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="执行execute()方法和submit()方法的区别是什么呢？"></a>执行execute()方法和submit()方法的区别是什么呢？</h5><ul><li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以了解任务执行情况，并且可以通过 Future 的 get() 方法来获取返回值，还可以取消任务执行。底层也是通过 execute() 执行的。</li></ul><h5 id="线程池的关闭方式有几种，各自的区别是什么。"><a href="#线程池的关闭方式有几种，各自的区别是什么。" class="headerlink" title="线程池的关闭方式有几种，各自的区别是什么。"></a>线程池的关闭方式有几种，各自的区别是什么。</h5><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。他们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法中止。</p><h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><ul><li>RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务</li><li>SHUTDOWN：不再接受新提交的任务，但可以处理存量任务</li><li>STOP：不再接受新提交的任务，也不处理存量任务</li><li>TIDYING：所有的任务都已终止</li><li>TERMINATED：terminated()方法执行完后进入该状态</li></ul><p>状态转换图：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/86.png" alt=""></p><h4 id="线程池常用的阻塞队列？"><a href="#线程池常用的阻塞队列？" class="headerlink" title="线程池常用的阻塞队列？"></a>线程池常用的阻塞队列？</h4><ul><li>ArrayBlockingQueue：基于数组实现的一个单端阻塞队列，只能从队尾出队。</li><li>LinkedBlockingQueue：基于链表实现的一个双端阻塞队列，分别从队头队尾操作入队出队。</li><li>PriorityBlockingQueue：以上2种队列都是先进先出队列，而PriorityBlockingQueue却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限（通过源码就可以知道，它没有容器满的信号标志），前面2种都是有界队列。</li><li>DelayQueue：基于PriorityQueue，一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue也是一个无界队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</li></ul><h4 id="向线程池提交一个线程的原理-步骤⭐"><a href="#向线程池提交一个线程的原理-步骤⭐" class="headerlink" title="向线程池提交一个线程的原理/步骤⭐"></a>向线程池提交一个线程的原理/步骤⭐</h4><p>也叫做ThreadPoolexecutor工作流程</p><ul><li>先判断核心线程池是否已满<ul><li>如果没有满就创建线程</li><li>如果满了就判断等待队列是否已满<ul><li>如果没满就加入等待队列</li><li>如果满了就判断最大线程池是否已满<ul><li>没有满就提交给线程池</li><li>满了就执行拒绝策略</li></ul></li></ul></li></ul></li></ul><h4 id="线程池的线程数量怎么确定"><a href="#线程池的线程数量怎么确定" class="headerlink" title="线程池的线程数量怎么确定"></a>线程池的线程数量怎么确定</h4><ul><li>一般来说，如果是CPU密集型应用，则线程池大小设置为N+1。</li><li>一般来说，如果是IO密集型应用，则线程池大小设置为2N+1。</li><li>在IO优化中，线程等待时间所占比例越高，需要越多线程，线程CPU时间所占比例越高，需要越少线程。这样的估算公式可能更适合：最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</li></ul><h3 id="Java-中是如何实现线程同步的？"><a href="#Java-中是如何实现线程同步的？" class="headerlink" title="Java 中是如何实现线程同步的？"></a>Java 中是如何实现线程同步的？</h3><p>1.同步方法 synchronized 关键字修饰的方法（悲观锁）</p><p>2.使用特殊域变量(volatile)实现线程同步（保持可见性，多线程更新某一个值时，比如说线程安全单例双检查锁）</p><p>3.ThreadLocal（每个线程获取的都是该变量的副本）</p><p>4.使用重入锁实现线程同步（相对 synchronized 锁粒度更细了，效率高）</p><p>​ 一个java.util.concurrent 包来支持同步。</p><p>​ ReentrantLock 类是可重入、互斥、实现了 Lock 接口的锁</p><p>​ ReentrantLock() : 创建一个 ReentrantLock 实例</p><p>​ lock() : 获得锁</p><p>​ unlock() : 释放锁</p><p>5.java.util.concurrent.atomic 包 （乐观锁）</p><p>​ 方便程序员在多线程环境下，无锁的进行原子操作</p><p>​</p><h3 id="i-是线程安全的吗？"><a href="#i-是线程安全的吗？" class="headerlink" title="i++是线程安全的吗？"></a>i++是线程安全的吗？</h3><p>分2种情况</p><ul><li>局部变量肯定是线程安全的（原因：方法内局部变量是线程私有的）</li><li>成员变量多个线程共享时，就不是线程安全的（原因：成员变量是线程共享的，因为 i++ 是三步操作。)</li></ul><h3 id="ThreadLocal-实现原理"><a href="#ThreadLocal-实现原理" class="headerlink" title="ThreadLocal 实现原理"></a>ThreadLocal 实现原理</h3><p>每个线程独享的局部变量，ThreadLocal使用弱引用 ThreadLocalMap 保存弱引用的局部变量。使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。</p><h3 id="ThreadLocal用来解决什么问题？"><a href="#ThreadLocal用来解决什么问题？" class="headerlink" title="ThreadLocal用来解决什么问题？"></a>ThreadLocal用来解决什么问题？</h3><p>ThreadLocak不是用来解决多线程共享变量的问题，而是线程数据隔离的问题</p><h3 id="导致线程死锁的原因，怎么解除线程死锁。"><a href="#导致线程死锁的原因，怎么解除线程死锁。" class="headerlink" title="导致线程死锁的原因，怎么解除线程死锁。"></a>导致线程死锁的原因，怎么解除线程死锁。</h3><p>死锁是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p><p>产生死锁的必要条件：</p><p>互斥条件，所谓互斥就是线程在某一个时间内独占资源。<br>请求与保持条件，一个进程因请求资源而阻塞时，对已获得的资源保持不变。<br>不剥夺条件，线程已获得资源，在未使用之前，不能强行剥夺。<br>循环等待条件，若干线程之间形成一种头尾相接的循环等待资源关系。<br>解除线程死锁的方法：</p><p>加锁顺序，当多个线程需要相同的一些锁，必须确保所有线程都是按照相同的顺序获得锁。<br>加锁时限，在尝试获取锁的时候加一个超时时间，若超过这个时限该线程则放弃对该锁的请求。<br>死锁检测：每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。<br>当出现死锁时，释放所有锁，回退，并且等待一段随机的时间后重试。或者更好的做法是给这些线程设置优先级，让一个（或多个）线程回退，其他线程继续保持它们需要的锁。</p><h3 id="如何尽可能提高多线程并发性能？"><a href="#如何尽可能提高多线程并发性能？" class="headerlink" title="如何尽可能提高多线程并发性能？"></a>如何尽可能提高多线程并发性能？</h3><p>尽量减少临界区范围、使用ThreadLocal、减少线程切换、使用读写锁或CopyOnWrite机制</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试常考的Redis知识</title>
      <link href="/2020/07/15/mian-shi-redis/"/>
      <url>/2020/07/15/mian-shi-redis/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这些都是面试中可能会被问到的一些关于Redis的问题</li></ul><h2 id="主流应用架构"><a href="#主流应用架构" class="headerlink" title="主流应用架构"></a>主流应用架构</h2><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/47.png" alt=""></p><h2 id="缓存中间键"><a href="#缓存中间键" class="headerlink" title="缓存中间键"></a>缓存中间键</h2><h3 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h3><p>代码层次类似Hash</p><ul><li>支持简单数据类型</li><li>不支持数据持久化存储</li><li>不支持主从</li><li>不支持分片</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>数据类型丰富</li><li>支持数据磁盘持久化存储</li><li>支持主从</li><li>支持分片</li></ul><h3 id="Redis-和-memcached-的区别"><a href="#Redis-和-memcached-的区别" class="headerlink" title="Redis 和 memcached 的区别"></a>Redis 和 memcached 的区别</h3><ul><li>redis支持更丰富的数据类型（支持更复杂的应用场景）：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</li><li>集群模式：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li><li>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</li></ul><h2 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h3><p>Redis是C语言开发的一个开源的（遵从BSD协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。它是一种NoSQL（not-only sql，泛指非关系型数据库）的数据库。</p><p>Redis作为一个内存数据库。 性能优秀，数据在内存中，读写速度非常快 ， 单进程单线程，是线程安全的，采用IO多路复用机制；</p><p>丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等；</p><p>支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载；</p><p>支持 主从复制，哨兵，高可用；</p><p>可以用作分布式锁； 可以作为消息中间件使用，支持发布订阅</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>缓存</li><li>共享Session</li><li>消息队列系统</li><li>分布式锁</li></ul><h3 id="为什么要用缓存？"><a href="#为什么要用缓存？" class="headerlink" title="为什么要用缓存？"></a>为什么要用缓存？</h3><p>用缓存，主要有两个用途：高性能、高并发。</p><h3 id="怎么保证缓存和数据库数据的一致性？⭐"><a href="#怎么保证缓存和数据库数据的一致性？⭐" class="headerlink" title="怎么保证缓存和数据库数据的一致性？⭐"></a>怎么保证缓存和数据库数据的一致性？⭐</h3><p>分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。</p><p>我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。</p><ul><li>合理设置缓存的过期时间。</li><li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事务机制来保证数据的一致性。</li><li>缓存失败时增加重试机制。</li></ul><h3 id="为什么Redis这么快？⭐"><a href="#为什么Redis这么快？⭐" class="headerlink" title="为什么Redis这么快？⭐"></a>为什么Redis这么快？⭐</h3><ul><li>完全基于内存,绝大部分请求是纯粹的内存操作,执行效率高</li><li>采用单线程,单线程也能处理高并发请求,想多核也可启动多实例<br>，单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</li><li>数据结构简单，对数据操作也简单，读取速度快</li><li>核心是基于非阻塞的 IO 多路复用机制。可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间</li><li>Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li></ul><h4 id="为什么Redis是单线程的"><a href="#为什么Redis是单线程的" class="headerlink" title="为什么Redis是单线程的"></a>为什么Redis是单线程的</h4><p>1.官方答案</p><p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><p>2.性能指标</p><p>关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p><p>3.详细原因</p><p>1）不需要各种锁的性能消耗</p><p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除</p><p>一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p><p>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p><p>2）单线程多进程集群方案</p><p>单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p><p>所以单线程、多进程的集群不失为一个时髦的解决方案。</p><p>3）CPU消耗</p><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p><p>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CPU核闲置，那怎么办？</p><p>可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p><h4 id="Redis单线程的优劣势"><a href="#Redis单线程的优劣势" class="headerlink" title="Redis单线程的优劣势"></a>Redis单线程的优劣势</h4><p>1.单进程单线程优势</p><ul><li>代码更清晰，处理逻辑更简单</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li><li>不存在多进程或者多线程导致的切换而消耗CPU</li></ul><p>2.单进程单线程弊端</p><ul><li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</li></ul><h4 id="IO多路复用技术"><a href="#IO多路复用技术" class="headerlink" title="IO多路复用技术"></a>IO多路复用技术</h4><p>redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。</p><p>多路-指的是多个socket连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。</p><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路<br>I/O<br>复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><h3 id="Redis-支持的数据类型有哪些"><a href="#Redis-支持的数据类型有哪些" class="headerlink" title="Redis 支持的数据类型有哪些"></a>Redis 支持的数据类型有哪些</h3><ul><li>String字符串:字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型， Value 不仅是 String，也可以是数字。常用在缓存、计数、共享Session、限速等。</li><li>Hash哈希:在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息（对象），比如实现购物车。</li><li>List列表（双向链表）:列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。 数据结构：List 就是链表，可以用来当消息队列用。Redis 提供了 List 的 Push 和 Pop 操作，还提供了操作某一段的 API，可以直接查询或者删除某一段的元素。 实现方式：Redis List 的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。</li><li>Set集合：集合（set）类型也是用来保存多个的字符串元素，集合是通过 hashtable 实现的。 但和列表类型不一样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</li><li>Sorted Set有序集合（跳表实现）：Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。实现方式：Redis Sorted Set 的内部使用 HashMap 和跳跃表（skipList）来保证数据的存储和有序，HashMap 里放的是成员到 Score 的映射。</li><li>用于计数的HyperLogLog(不常用)</li><li>用于支持存储地理位置信息的Geo(不常用)</li></ul><h4 id="底层数据类型（不一定按顺序）"><a href="#底层数据类型（不一定按顺序）" class="headerlink" title="底层数据类型（不一定按顺序）"></a>底层数据类型（不一定按顺序）</h4><ul><li>简单的动态字符串</li><li>字典</li><li>链表</li><li>整数集合</li><li>跳跃表</li><li>压缩列表</li><li>对象</li></ul><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><table><thead><tr><th align="left">类型</th><th align="left">简介</th><th align="left">特性</th><th align="left">场景</th></tr></thead><tbody><tr><td align="left">String(字符串)</td><td align="left">二进制安全</td><td align="left">可以包含任何数据，包括jpg图片或者序列化的对象，一个键值最大能存储512M</td><td align="left">缓存，计数，共享session，限速等</td></tr><tr><td align="left">Hash(字典)</td><td align="left">键值对集合，即编程语言中的Map类型</td><td align="left">适合存储对象，并且可以像数据库一样update一个属性一样只修改某一项的属性值（Memcached中需要取出整个字符串反序列化成对象修改完再反序列化存回去）</td><td align="left">存储，读取，修改用户属性</td></tr><tr><td align="left">List(列表)</td><td align="left">链表(双向链表)</td><td align="left">增删快，提供了操作某一段的API，可以直接查询或者删除某一段的元素</td><td align="left">1.最新消息排行等功能（例如朋友圈的时间线）2.消息队列</td></tr><tr><td align="left">Set(集合)</td><td align="left">Hash表实现，元素不重复</td><td align="left">1.添加，删除，查找的复杂度都是O(1)   2.是无序的，所以也不能用索引来查找值   3.为集合添加了交集，并集和差集</td><td align="left">1.共同好友  2.利用唯一性，统计访问网站的所有独立ip  3.好友推荐时根据tag求交集，大于某个阈值就推荐</td></tr><tr><td align="left">Sorted Set(有序集合)</td><td align="left">将Set中的元素增加一个权重参数score，元素按照权重有序排序</td><td align="left">数据插入集合，已经进行天然排序</td><td align="left">排行榜，带权重的消息队列</td></tr></tbody></table><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p>① string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。value其实不仅是String，也可以是数字。string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><p>　　常用命令：get、set、incr、decr、mget等。</p><p>　　应用场景：String是最常用的一种数据类型，普通的key/ value 存储都可以归为此类，即可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受Redis的定时持久化，操作日志及 Replication等功能。除了提供与 Memcached 一样的get、set、incr、decr 等操作外，Redis还提供了下面一些操作： </p><p>获取字符串长度<br>往字符串append内容<br>设置和获取字符串的某一段内容<br>设置及获取字符串的某一位（bit）<br>批量设置一系列字符串的内容<br>　　使用场景：常规key-value缓存应用。常规计数: 微博数, 粉丝数。</p><p>　　实现方式：String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。　</p><pre><code>    redis 127.0.0.1:6379&gt; SET name &quot;runoob&quot;    &quot;OK&quot;    redis 127.0.0.1:6379&gt; GET name    &quot;runoob&quot;    　　在以上实例中我们使用了 Redis 的 SET 和 GET 命令。键为 name，对应的值为 runoob。</code></pre><p>　　注意：一个键最大能存储512MB。</p><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p>② Redis hash 是一个键值(key =&gt; value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><p>　　常用命令：hget,hset,hgetall 等。</p><p>　　应用场景：比如我们要存储一个用户信息对象数据</p><p>　　Key仍然是用户ID,value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题，很好的解决了问题。</p><p>　　　　这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据，但是如果内部Map的成员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。</p><p>　　使用场景：存储部分变更数据，如用户信息等。</p><p>　　实现方式：上面已经说到Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap，此时encoding为ht。</p><pre><code>    redis&gt; HSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;    &quot;OK&quot;    redis&gt; HGET myhash field1    &quot;Hello&quot;    redis&gt; HGET myhash field2    &quot;World&quot;</code></pre><p>实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。每个 hash 可以存储 232 -1 键值对（40多亿）</p><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>③ Redis list 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>　　常用命令：lpush（添加左边元素）,rpush,lpop（移除左边第一个元素）,rpop,lrange（获取列表片段，LRANGE key start stop）等。</p><p>　　应用场景：Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。</p><p>　　　　List 就是链表，相信略有数据结构知识的人都应该能理解其结构。使用List结构，我们可以轻松地实现最新消息排行等功能。List的另一个应用就是消息队列，<br>可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删除List中某一段的元素。</p><p>　　实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p><p>　　Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。 获取越接近两端的元素速度越快，但通过索引访问时会比较慢。</p><p>使用场景：</p><p>　　消息队列系统：使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。比如：将Redis用作日志收集器，实际上还是一个队列，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。</p><p>　　取最新N个数据的操作：记录前N个最新登陆的用户Id列表，超出的范围可以从数据库中获得。</p><pre><code>    //把当前登录人添加到链表里    ret = r.lpush(&quot;login:last_login_times&quot;, uid)    //保持链表只有N位    ret = redis.ltrim(&quot;login:last_login_times&quot;, 0, N-1)    //获得前N个最新登陆的用户Id列表    last_login_list = r.lrange(&quot;login:last_login_times&quot;, 0, N-1)</code></pre><p>比如微博：</p><p>　　在Redis中我们的最新微博ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。　　</p><pre><code>    redis 127.0.0.1:6379&gt; lpush runoob redis    (integer) 1    redis 127.0.0.1:6379&gt; lpush runoob mongodb    (integer) 2    redis 127.0.0.1:6379&gt; lpush runoob rabitmq    (integer) 3    redis 127.0.0.1:6379&gt; lrange runoob 0 10    1) &quot;rabitmq&quot;    2) &quot;mongodb&quot;    3) &quot;redis&quot;    redis 127.0.0.1:6379&gt;</code></pre><p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>④ Redis set是string类型的无序集合。集合是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。所以添加，删除，查找的复杂度都是O(1)。</p><p>　　sadd 命令：添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</p><p>　　常用命令：sadd,spop,smembers,sunion 等。</p><p>　　应用场景：Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><p>　　Set 就是一个集合，集合的概念就是一堆不重复值的组合。利用Redis提供的Set数据结构，可以存储一些集合性的数据。</p><p>　　案例：在微博中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。</p><p>　　实现方式： set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p><p>　　使用场景：</p><p>　　①交集，并集，差集：(Set)</p><pre><code>    //book表存储book名称    set book:1:name    ”The Ruby Programming Language”    set book:2:name     ”Ruby on rail”    set book:3:name     ”Programming Erlang”    //tag表使用集合来存储数据，因为集合擅长求交集、并集    sadd tag:ruby 1    sadd tag:ruby 2    sadd tag:web 2    sadd tag:erlang 3    //即属于ruby又属于web的书？    inter_list = redis.sinter(&quot;tag.web&quot;, &quot;tag:ruby&quot;)     //即属于ruby，但不属于web的书？    inter_list = redis.sdiff(&quot;tag.ruby&quot;, &quot;tag:web&quot;)     //属于ruby和属于web的书的合集？    inter_list = redis.sunion(&quot;tag.ruby&quot;, &quot;tag:web&quot;)</code></pre><p>②获取某段时间所有数据去重值</p><p>　　这个使用Redis的set数据结构最合适了，只需要不断地将数据往set中扔就行了，set意为集合，所以会自动排重。</p><pre><code>    redis 127.0.0.1:6379&gt; sadd runoob redis    (integer) 1    redis 127.0.0.1:6379&gt; sadd runoob mongodb    (integer) 1    redis 127.0.0.1:6379&gt; sadd runoob rabitmq    (integer) 1    redis 127.0.0.1:6379&gt; sadd runoob rabitmq    (integer) 0    redis 127.0.0.1:6379&gt; smembers runoob    1) &quot;redis&quot;    2) &quot;rabitmq&quot;    3) &quot;mongodb&quot;</code></pre><p>注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</p><h5 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h5><p>⑤ Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p><p>　　zadd 命令：添加元素到集合，元素在集合中存在则更新对应score。</p><p>　　常用命令：zadd,zrange,zrem,zcard等</p><p>　　使用场景：Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。和Set相比，Sorted Set关联了一个double类型权重参数score，使得集合中的元素能够按score进行有序排列，redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。比如一个存储全班同学成绩的Sorted Set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用Sorted Set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p><p>　　实现方式：Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单</p><pre><code>    redis 127.0.0.1:6379&gt; zadd runoob 0 redis    (integer) 1    redis 127.0.0.1:6379&gt; zadd runoob 0 mongodb    (integer) 1    redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq    (integer) 1    redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq    (integer) 0    redis 127.0.0.1:6379&gt; &gt; ZRANGEBYSCORE runoob 0 1000    1) &quot;mongodb&quot;    2) &quot;rabitmq&quot;    3) &quot;redis&quot;</code></pre><h3 id="从海量Key里查询出某一固定前缀的Key"><a href="#从海量Key里查询出某一固定前缀的Key" class="headerlink" title="从海量Key里查询出某一固定前缀的Key"></a>从海量Key里查询出某一固定前缀的Key</h3><ul><li>注意留意细节：摸清数据规模</li></ul><h4 id="keys指令"><a href="#keys指令" class="headerlink" title="keys指令"></a>keys指令</h4><ul><li>KEYS pattern：查找所有符合给定模式pattern的key</li></ul><pre><code>    //查询所有以k1开头的key    keys k1*</code></pre><ul><li>缺点<ul><li>keys指令一次性返回所有的匹配项</li><li>键的数量过多会使服务器卡顿</li></ul></li></ul><h4 id="scan指令"><a href="#scan指令" class="headerlink" title="scan指令"></a>scan指令</h4><p>SCAN cursor [MATCH pattern] [COUNT count]</p><ul><li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程</li><li>以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历</li><li>不保证每次执行都返回某个给定数量的元素，支持模糊查询</li><li>一次返回的数量不可控，只能是大概率符合count参数</li></ul><pre><code>    //开始迭代，搜索以k1开头的key，并且期望一次返回10个。结果会返回一个cursor游标和数据，cursor表示迭代到的位置    scan 0 match k1* count 10</code></pre><h3 id="如何通过Redis实现分布式锁"><a href="#如何通过Redis实现分布式锁" class="headerlink" title="如何通过Redis实现分布式锁"></a>如何通过Redis实现分布式锁</h3><h4 id="分布式锁需要解决的问题"><a href="#分布式锁需要解决的问题" class="headerlink" title="分布式锁需要解决的问题"></a>分布式锁需要解决的问题</h4><ul><li>互斥性</li><li>安全性</li><li>死锁</li><li>容错</li></ul><h4 id="setnx指令"><a href="#setnx指令" class="headerlink" title="setnx指令"></a>setnx指令</h4><p>SETNX key value</p><ul><li>如果key不存在，则创建并赋值。成功则返回1，失败则返回0</li></ul><pre><code>    //设置key    setnx locknx test    //获取key    get locknx</code></pre><ul><li>因为setnx有此功能，所以在初期的时候被用来作分布式锁，对某个key设值，如果设值成功就说明没有线程在执行该段代码。如果失败则表明有别的线程在占用该资源，就只能等待直至setnx成功，但是setnx成功后是长期有效的，我们需要设置一个过期时间</li></ul><h4 id="如何解决SETNX长期有效的问题"><a href="#如何解决SETNX长期有效的问题" class="headerlink" title="如何解决SETNX长期有效的问题"></a>如何解决SETNX长期有效的问题</h4><p>EXPIRE key seconds</p><ul><li>设置key的生存时间，当key过期时，会被自动删除</li></ul><pre><code>    //设置过期时间为2秒，过期完之后key被删除，则又可以进行创建赋值了    expire locknx 2</code></pre><ul><li>缺点：原子性得不到满足，看以下代码</li></ul><pre><code>    //此代码会出现一个致命问题，就是当程序执行到if语句的时候就挂掉    了，来不及expire，key就会一直被占用，这就意味着其他的线程永远也执行不了独占的资源    RedisService redisService = SpringUtils.getBean(RedisService.class);    long status = redisService.setnx(key,&quot;1&quot;);    if(status == 1){        redisService.expire(key,expire);        //执行独占资源        doWork();    }</code></pre><p>SET key value [EX seconds] [PX milliseconds] [NX|XX]</p><ul><li>EX seconds：设置过期的时间为多少秒</li><li>PX millisecond：设置过期的时间为多少毫秒</li><li>NX：只有在键不存在时，才对键进行设置操作</li><li>XX：只有键已经存在时，才对键进行设置操作</li><li>SET 设置成功，返回OK，失败返回nil</li><li>这个指令就能保证分布式锁的原子性了</li></ul><pre><code>    //当键不存在时设置一个过期时间10秒的key    set locktarget 12345 ex 10 nx</code></pre><h4 id="大量的key同时过期需要注意的事项"><a href="#大量的key同时过期需要注意的事项" class="headerlink" title="大量的key同时过期需要注意的事项"></a>大量的key同时过期需要注意的事项</h4><ul><li>集中过期，由于清除大量key会很耗时，会出现短暂的卡顿现象</li><li>解决方案：在设置key过期时间的时候，给每个key加上一个随机值，使得过期时间分散一些</li></ul><h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p>在一个较短的时间内，缓存中较多的key集中过期或者缓存挂了，导致了数据库服务器崩溃</p><p>缓存雪崩的事前事中事后的解决方案如下：</p><p>在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。如果 Redis 是集群部署，将热点数据均匀分布在不同的 Redis 库中也能避免全部失效。或者设置热点数据永不过期，有更新操作就更新缓存就好了</p><h3 id="如何使用Redis做异步队列"><a href="#如何使用Redis做异步队列" class="headerlink" title="如何使用Redis做异步队列"></a>如何使用Redis做异步队列</h3><p>使用List作为队列，RPUSH生产消息，LPOP消费消息</p><ul><li>缺点：没有等待队列里有值就直接消费</li><li>弥补：可以通过在应用层引入Sleep机制去调用LPOP重试</li></ul><h4 id="blpop指令"><a href="#blpop指令" class="headerlink" title="blpop指令"></a>blpop指令</h4><ul><li>代替sleep机制</li></ul><p>BLPOP key [key …] timeout：阻塞直到队列有消息或者超时</p><pre><code>    //开两个客户端，一个用来生产消息，一个用来消费消息    //在三十秒之内如果有新的消息，则输出，否则输出nil    blpop testlist 30    //队列生产消息    rpush testlist 123</code></pre><ul><li>缺点：只能供一个消费者消费，消费完就没了</li></ul><h4 id="pub-sub主题订阅者模式"><a href="#pub-sub主题订阅者模式" class="headerlink" title="pub/sub主题订阅者模式"></a>pub/sub主题订阅者模式</h4><ul><li>发送者(pub)发送消息，订阅者(sub)接收消息</li><li>订阅者可以订阅任意数量的频道</li><li>发送者发送的消息可以供n个订阅者消费，只要订阅了就可以接收到</li></ul><pre><code>    //订阅消息    subscribe myTopic    //发布消息    publish myTopic &quot;Hello&quot;</code></pre><ul><li>缺点：消息的发布是无状态的，无法保证可达</li></ul><h3 id="数据过期策略⭐"><a href="#数据过期策略⭐" class="headerlink" title="数据过期策略⭐"></a>数据过期策略⭐</h3><p>定期删除+惰性删除。</p><p>通过名字大概就能猜出这两个删除方式的意思了。</p><ul><li>定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li><li>惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。<br>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ redis 内存淘汰机制。</li></ul><h3 id="数据淘汰机制⭐"><a href="#数据淘汰机制⭐" class="headerlink" title="数据淘汰机制⭐"></a>数据淘汰机制⭐</h3><p>当内存到达最大内存限制时进行的数据淘汰策略</p><ul><li>新写入操作会报错。（Redis 默认策略）</li><li>在键空间中，移除最近最少使用的 Key。（LRU推荐使用）</li><li>在键空间中，随机移除某个 Key。</li><li>在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。</li><li>在设置了过期时间的键空间中，随机移除某个 Key。</li><li>在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。</li></ul><p>LRU 算法实现：1.通过双向链表来实现，新数据插入到链表头部；2.每当缓存命中（即缓存 数据被访问），则将数据移到链表头部；3.当链表满的时候，将链表尾部的数据丢弃。 LinkedHashMap：HashMap 和双向链表合二为一即是 LinkedHashMap。HashMap 是无序 的，LinkedHashMap 通过维护一个额外的双向链表保证了迭代顺序。该迭代顺序可以是插 入顺序（默认），也可以是访问顺序</p><h3 id="Redis持久化的两种方式"><a href="#Redis持久化的两种方式" class="headerlink" title="Redis持久化的两种方式"></a>Redis持久化的两种方式</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><ul><li>RDB：快照形式直接将内存中的所有数据保存到一个dump文件中，定时保存，保存策略。当Redis需要做持久化的时候，Redis会fork一个子进程，子进程将数据写到磁盘的一个临时RDB文件中。当子进程完成写临时文件后，会替换原来的RDB</li><li>优点：RDB是一个紧凑压缩的二进制文件，存储效率高，RDB恢复速度比AOF快</li><li>缺点：无法做到实时持久化，宕机将带来数据丢失风险，具有较大可能丢失数据。存储数量大时，效率较低。I/O性能较低。基于fork创建子进程，内存产生额外消耗。</li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><ul><li>AOF：把所有对Redis服务器修改的命令都保存到一个文件中，命令的集合。使用AOF做持久化，每一个命令都通过write函数追加到appendonly.aof中。afo的策略是每秒钟fsync一次，在这种配置下，就算发生宕机，也最多只会丢失一秒的数据。缺点是对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积。根据所需要的fsync策略，AOF速度也会比RDB慢。对于主从同步来说，主从刚刚连接的时候，进行全面同步（RDB）；全同步结束后，进行增量同步（AOF）</li><li>优点：<ul><li>AOF有更好的保护，数据不丢失，一般AOF会每隔一秒进行一次fsync操作，最多丢失一秒数据</li><li>写入性能非常高，而且文件不容易破损</li><li>适合做灾难性的误删除的紧急恢复</li></ul></li><li>缺点：<ul><li>对于同一份数据，AOF 日志文件通常比 RDB 数据快照文件更大。</li><li>恢复速度慢</li></ul></li></ul><h4 id="RDB和AOF如何选择"><a href="#RDB和AOF如何选择" class="headerlink" title="RDB和AOF如何选择"></a>RDB和AOF如何选择</h4><ul><li>对于数据非常敏感，建议使用默认的AOF持久化方案，AOF策略使用everysync，每隔一秒钟进行一次fsync，该策略可以保持良好性能，最多丢失一秒的数据</li><li>如果数据可以做到阶段内无丢失，且恢复速度快，阶段点数据恢复通常启用RDB方案</li><li>综合：如果不能承受分钟内数据丢失，对数据非常敏感，启用AOF方案。如果能承受分钟内数据丢失，且追求大数据集的恢复速度就采用RDB方案，RDB非常适合灾难恢复。双保险策略：同时开启AOF和RDB，redis重启时会优先使用AOF来恢复数据，因为AOF中数据更加完整，降低数据丢失量</li></ul><h3 id="redis的同步机制"><a href="#redis的同步机制" class="headerlink" title="redis的同步机制"></a>redis的同步机制</h3><p>主从的意义</p><ul><li>redis要达到高并发，高可用，只有单个redis是不够的，单个redis只能支持几万的QPS，所以必须以集群的方式提供服务，而集群又是以多个主从组成</li><li>主从是以多个redis集合而成，以一个Master多个Slave为模式对外提供服务，master主要以写为主，slave提供读，即读写分离。以读多写少为准，如果写比较多一般就以异步的形式提供服务</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/48.png" alt=""></p><p>同步全过程（两个阶段）：</p><ul><li>从服务器向主服务器发送SYNC命令。</li><li>收到SYNC命令的主服务器执行BGSAVE命令,在后台生成一个RDB文件,并使用一个缓冲区记录从现在开始执行的所有写命令。</li><li>当主服务器的BGSAVE命令执行完毕时,主服务器会将BGSAVE命令生成的RDB文件发送给从服务器,从服务器接收并载人这个RDB文件,将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。</li><li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器,从服务器执行这些写命令,将自己的数据库状态更新至主服务器数据库当前所处的状态。</li></ul><h4 id="全同步过程"><a href="#全同步过程" class="headerlink" title="全同步过程"></a>全同步过程</h4><ul><li>从服务器连接主服务器，发送SYNC命令； </li><li>主服务器接收到SYNC命令后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； </li><li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； </li><li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li><li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li><li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/87.png" alt=""></p><h4 id="增量同步过程"><a href="#增量同步过程" class="headerlink" title="增量同步过程"></a>增量同步过程</h4><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 </p><p>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p><h4 id="复制-数据同步过程分为两个阶段"><a href="#复制-数据同步过程分为两个阶段" class="headerlink" title="复制/数据同步过程分为两个阶段"></a>复制/数据同步过程分为两个阶段</h4><ul><li>全量复制： slave接收到master生成的RDB文件，先清空自身的旧数据，然后执行RDB恢复过程，然后告知master已经恢复完毕。</li><li>部分复制（增量复制）： 主节点发送数据给从节点过程中，主节点还会进行一些写操作，这时候的数据存储在复制缓冲区中。master把自己之前创建的复制缓冲区的数据发送到slave，slave接收到aof指令后执行重写操作，恢复数据。</li></ul><h4 id="Redis主从同步策略"><a href="#Redis主从同步策略" class="headerlink" title="Redis主从同步策略"></a>Redis主从同步策略</h4><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步</p><h4 id="主从复制会存在以下问题："><a href="#主从复制会存在以下问题：" class="headerlink" title="主从复制会存在以下问题："></a>主从复制会存在以下问题：</h4><ul><li>一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去连接新的主节点，整个过程需要人工干预。</li><li>主节点的写能力受到单机的限制。</li><li>主节点的存储能力受到单机的限制。</li></ul><h4 id="Redis-Sentinel（哨兵）"><a href="#Redis-Sentinel（哨兵）" class="headerlink" title="Redis Sentinel（哨兵）"></a>Redis Sentinel（哨兵）</h4><p>哨兵（Sentinel）是一个分布式系统，用于对主从结构的每一台服务器进行监控，当出现故障时通过投票机制选出新的master并将所有的slave连接到新的master</p><ul><li>解决主从同步Master宕机后的主从切换问题：<ul><li>监控：检查主从服务器是否运行正常</li><li>提醒：当被监控的服务器出现问题时，通过API向管理员或者其他应用程序发送故障通知</li><li>自动故障迁移：主从切换，断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</li></ul></li></ul><h5 id="流言协议Gossip"><a href="#流言协议Gossip" class="headerlink" title="流言协议Gossip"></a>流言协议Gossip</h5><ul><li>分布式系统通常用gossip协议来解决一些用其他方法难以解决的问题，上述的哨兵原理就是流言协议<ul><li>每个节点都随机地与对方通信，最终所有节点的状态都达成一致</li><li>种子节点定期随机向其他节点发送节点列表以及需要传播的消息</li><li>不保证信息一定会传递给所有节点，但保证最终会趋于一致</li></ul></li></ul><h3 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h3><ul><li>主从模式</li><li>Sentinel模式</li><li>Cluster模式</li></ul><h3 id="知道哪些Redis的优化操作。"><a href="#知道哪些Redis的优化操作。" class="headerlink" title="知道哪些Redis的优化操作。"></a>知道哪些Redis的优化操作。</h3><ul><li>使用简短的key。</li><li>大的数据压缩后再存入value。</li><li>设置key有效期。</li><li>选择回收策略。当 Redis 的实例空间被填满了之后，将会尝试回收一部分key。在Redis中，允许用户设置最大使用内存大小server.maxmemory，当Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略，有很多不同的回收策略。</li><li>在服务器端使用Lua脚本。（没看过Lua就算了）</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指一个Key非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发直接落到了数据库上，就在这个Key的点上击穿了缓存。</p><p>解决：设置热点数据永不过期，或者加上个锁就搞定了。</p><p>假如 Redis 里面有 1 亿个 key ，其中有 10w 个 个 key 是以某个固定的已知的前缀开头的，如 果将它们全部找出来？ 使用 keys 指令可以扫出指定模式的 key 列表。 对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问 题？ 这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一 段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指 令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客 户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>原因：</p><ul><li>Redis中大面积出现未命中</li><li>出现非正常URL访问</li></ul><p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><p><strong>布隆过滤器（Bloom Filter）</strong>这个也能很好的预防缓存穿透的发生，就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查DB刷新KV再return</p><h3 id="Redis的SDS相比char-的优点。"><a href="#Redis的SDS相比char-的优点。" class="headerlink" title="Redis的SDS相比char[]的优点。"></a>Redis的SDS相比char[]的优点。</h3><p>SDS结构中拥有len（字符串长度）、free（未使用字节的数量）和buf数组（保存字符串）。具有以下几点优势。</p><ul><li>常数复杂度获取字符串长度。</li><li>杜绝缓冲区溢出。</li><li>减少修改字符串时带来的内存重分配次数，因为有空间预分配和惰性空间释放。</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC垃圾回收机制</title>
      <link href="/2020/07/13/mian-shi-gc-la-ji-hui-shou-ji-zhi/"/>
      <url>/2020/07/13/mian-shi-gc-la-ji-hui-shou-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本篇主要记录java垃圾回收机制的一些主要面试问题</li></ul><h2 id="java垃圾回收机制"><a href="#java垃圾回收机制" class="headerlink" title="java垃圾回收机制"></a>java垃圾回收机制</h2><ul><li>java回收机制主要是回收java堆中的对象</li></ul><h3 id="对象被判定为垃圾的标准"><a href="#对象被判定为垃圾的标准" class="headerlink" title="对象被判定为垃圾的标准"></a>对象被判定为垃圾的标准</h3><ul><li>没有被其他对象引用</li></ul><h3 id="判断对象是否为垃圾的算法"><a href="#判断对象是否为垃圾的算法" class="headerlink" title="判断对象是否为垃圾的算法"></a>判断对象是否为垃圾的算法</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>判断对象的引用数量</p><ul><li>通过判断对象的引用数量来决定对象是否可以回收</li><li>每个对象都有一个引用计数器，如果被引用就+1，完成引用就-1</li><li>任何引用计数为0的对象实例都可以被当作垃圾收集</li><li>优点：执行效率高，程序执行受影响小</li><li>缺点：无法检测出循环引用的情况，导致内存泄漏（如父对象对子对象有一个引用，子对象又反过来引用父对象，这样引用数量永远不可能为0）</li></ul><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>通过判断对象的引用链是否可达来决定对象是否可以回收</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/62.png" alt=""></p><h4 id="可作为GC-Root的对象"><a href="#可作为GC-Root的对象" class="headerlink" title="可作为GC Root的对象"></a>可作为GC Root的对象</h4><ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）</li><li>方法区中的常量引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>本地方法栈中JNI（Native方法）的引用对象</li><li>活跃线程的引用对象</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><ul><li>标记：从根集合进行扫描，把存活的对象进行标记（可达性算法）</li><li>清除：从堆内存从头到尾进行线性遍历，回收不可达对象</li><li>缺点：一是效率问题，两个过程的效率都不高。二是空间问题，清除之后会产生大量不连续的内存，容易造成内存碎片化</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/63.png" alt=""></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法是将原有的内存空间分成两块，每次只使用其中的一块。在GC时，将正在使用的内存块中的存活对象复制到未使用的那一块中，然后清除正在使用的内存块中的所有对象，并交换两块内存的角色，完成一次垃圾回收。它比标记-清除算法要高效，但不适用于存活对象较多的内存，因为复制的时候会有较多的时间消耗。它的致命缺点是会有一半的内存浪费。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/64.png" alt=""></p><p>优点：</p><ul><li>解决碎片化</li><li>顺序分配内存，简单高效</li><li>适用于对象存活率低的场景</li></ul><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记整理算法适用于存活对象较多的场合，它的标记阶段和标记-清除算法中的一样。整理阶段是将所有存活的对象压缩到内存的一端，之后清理边界外所有的空间。它的效率也不高。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/65.png" alt=""></p><ul><li>标记：从根集合进行扫描，对存活的对象进行标记</li><li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收</li><li>避免内存的不连续</li><li>不用设置两块内存互换</li><li>适用于存活率高的场景</li></ul><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><ul><li>垃圾回收算法的组合拳</li><li>按照对象生命周期的不同划分区域采用不同的垃圾回收算法</li><li>目的：提高JVM的回收效率</li></ul><h4 id="GC的分类"><a href="#GC的分类" class="headerlink" title="GC的分类"></a>GC的分类</h4><p>GC：垃圾收集器</p><p>Minor GC：新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂。因为存活率较低，所以常用复制算法</p><p>Major GC/Full GC：老年代GC，指发生在老年代的GC，因为存活率高，所以常用标记整理算法</p><h4 id="新生代和老年代"><a href="#新生代和老年代" class="headerlink" title="新生代和老年代"></a>新生代和老年代</h4><ul><li>jdk8以前java堆分为新生代，老年代和永久代。jdk8以后java堆就只分为年轻代和老年代</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/66.png" alt=""></p><h5 id="为什么要划分成年轻代和老年代？"><a href="#为什么要划分成年轻代和老年代？" class="headerlink" title="为什么要划分成年轻代和老年代？"></a>为什么要划分成年轻代和老年代？</h5><p>因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。</p><h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><p>主要是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收,尽可能快速收集掉那些生命周期短的对象</p><p>新生代又分为 Eden区、SurvivorFrom、SurvivorTo三个区。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/67.png" alt=""></p><ul><li>Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。</li><li>ServivorTo：保留了一次MinorGC过程中的幸存者。</li><li>ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。</li></ul><p>当JVM无法为新建对象分配内存空间的时候(Eden满了)，Minor GC被触发。因此新生代空间占用率越高，Minor GC越频繁。</p><p>MinorGC的过程：采用复制算法。</p><ul><li>首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，一般是15，则赋值到老年代区）</li><li>同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）</li><li>然后，清空Eden和ServicorFrom中的对象；最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。</li></ul><h5 id="年轻代为什么被划分成eden、survivor区域？"><a href="#年轻代为什么被划分成eden、survivor区域？" class="headerlink" title="年轻代为什么被划分成eden、survivor区域？"></a>年轻代为什么被划分成eden、survivor区域？</h5><p>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC（因为Major GC一般伴随着Minor GC，也可以看做触发了Full GC）。老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。</p><p>没有survivor的解决办法：</p><ul><li>增加老年代内存，那么老年代清理频次减少，但清理一次花费时间更长。</li><li>减少老年代内存，老年代一次FullGC时间更少，频率增加。</li></ul><p>都不行，只有再加一层Survivor。将Eden区满了的对象，添加到Survivor区，等对象反复清理几遍之后都没清理掉，再放到老年区，这样老年区的压力就会小很多。即Survivor相当于一个筛子，筛掉生命周期短的，将生命周期长的放到老年代区，减少老年代被清理的次数。</p><h5 id="对象如何晋升到老年代"><a href="#对象如何晋升到老年代" class="headerlink" title="对象如何晋升到老年代"></a>对象如何晋升到老年代</h5><ul><li>经历一定次数的Minor GC依然存活的对象</li><li>Suivivor区中存放不下的对象</li><li>新生成的大对象(设置大对象的标准：-XX:+PretenuerSizeThreshold)</li></ul><h5 id="常见的调优参数"><a href="#常见的调优参数" class="headerlink" title="常见的调优参数"></a>常见的调优参数</h5><ul><li>-XX:SurvivorRatio：Eden和Survivor的比值，默认是8：1</li><li>-XX:NewRatio：老年代和新生代内存大小的比例</li><li>-XX:MaxTenuringThreshold：对象从新生代晋升到老年代经过Gc次数的最大阈值</li></ul><h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><ul><li>存放生命周期较长的对象</li></ul><p>MajorGC比MinorGC慢10倍以上，但是它不会频繁执行</p><p>老年代的对象比较稳定，所以MajorGC不会频繁执行。</p><p>在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。</p><p>MajorGC采用标记—清除算法或者标记-整理算法</p><h5 id="Full-GC和Major-GC"><a href="#Full-GC和Major-GC" class="headerlink" title="Full GC和Major GC"></a>Full GC和Major GC</h5><ul><li>都是发生在老年代的GC，通常情况下这两个GC是一样的概念，但是经过这么多年的发展，名词的解释可能存在有些许不同，所以你要问清楚FullGC是不是指的就是MajorGC</li><li>FullGC可能是清理整个堆中的年轻代和老年代，而MajorGC是清理老年代</li></ul><h4 id="触发MinorGC和FullGC的条件"><a href="#触发MinorGC和FullGC的条件" class="headerlink" title="触发MinorGC和FullGC的条件"></a>触发MinorGC和FullGC的条件</h4><ul><li>触发MinorGC的条件：当Eden区满的时候，触发Minor</li><li>触发FullGC的条件：<ul><li>老年代空间不足</li><li>永久代空间不足</li><li>CMSGC出现promotion failed，concurrent mode failure</li><li>MinorGC晋升到老年代的平均大小大于老年代剩余空间</li><li>调用System.gc()，系统建议执行Full GC，但是不必然执行</li><li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li><li>使用RMI来进行RPC或管理的JDK应用，每小时执行一次FullGC</li></ul></li></ul><h3 id="stop-the-world"><a href="#stop-the-world" class="headerlink" title="stop-the-world"></a>stop-the-world</h3><ul><li>jvm由于要执行GC而停止了应用程序的执行</li><li>任何一种GC算法中都会发生</li><li>多数GC优化通过减少stop-the-world发生的时间来提高程序性能</li></ul><h3 id="safepoint"><a href="#safepoint" class="headerlink" title="safepoint"></a>safepoint</h3><ul><li>分析过程中对象引用关系不会发生变化的点（即在垃圾进行回收的时候不会产生垃圾）</li><li>产生safepoint的地方：方法调用，循环跳转，异常跳转等</li><li>安全点数量要适中</li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集器是垃圾回收算法（标记-清除算法、复制算法、标记-整理算法）的具体实现，不同商家、不同版本的JVM所提供的垃圾收集器可能会有很在差别.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/68.png" alt=""></p><ul><li>图中展示了7种不同分代的收集器：</li></ul><p>Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；</p><ul><li>而它们所处区域，则表明其是属于新生代收集器还是老年代收集器：</li></ul><p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p><p>老年代收集器：Serial Old、Parallel Old、CMS；</p><p>整堆收集器：G1；</p><ul><li>两个收集器间有连线，表明它们可以搭配使用：</li></ul><p>Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>相关概念</p><ul><li><p>并行和并发</p><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。</li></ul></li><li><p>吞吐量（Throughput）</p></li></ul><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即</p><p>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。</p><p>假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><ul><li>VM client模式和Server模式</li></ul><p>JVM Server模式与client模式启动，最主要的差别在于：-Server模式启动时，速度较慢，但是一旦运行起来后，性能将会有很大的提升。</p><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>Serial（串行）收集器是最基本、发展历史最悠久的收集器，它是采用复制算法的新生代收集器，曾经（JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。它是一个单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）。这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接收的。</p><ul><li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li><li>简单高效，Client模式下默认的年轻代收集器</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/69.png" alt=""></p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><ul><li>多线程收集，其余的行为，特点都和Serial收集器一样</li><li>单核执行效率不如Serial，在多核下执行才有优势</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/70.png" alt=""></p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge收集器也是一个并行的多线程新生代收集器，它也使用复制算法。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。</p><ul><li>比起关注用户线程停顿时间，更关注系统的吞吐量</li><li>在多核下执行才有优势，Server模式下默认的年轻代收集器</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/70.png" alt=""></p><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old 是 Serial收集器的老年代版本，它同样是一个单线程收集器，使用<strong>“标记-整理”（Mark-Compact）</strong>算法。</p><p>此收集器的主要意义也是在于给Client模式下的虚拟机使用</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/71.png" alt=""></p><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和<strong>“标记-整理”算法。前面已经提到过，这个收集器是在JDK 1.6中才开始提供的，在此之前，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old以外别无选择，所以在Parallel Old诞生以后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感</strong>的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作流程与Parallel Scavenge相同</p><ul><li>多线程，吞吐量优先</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/72.png" alt=""></p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。从名字上（“Mark Sweep”）就可以看出它是基于<strong>“标记-清除”</strong>算法实现的。</p><ul><li>初始标记：stop-the-world</li><li>并发标记：并发追溯标记，程序不会停顿</li><li>并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象</li><li>重新标记：暂停虚拟机，扫描CMS堆中的对象，stop-the-world</li><li>并发清理：清理垃圾对象，程序不会停顿</li><li>并发重置：重置CMS收集器的数据结构</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/73.png" alt=""></p><p>优点：</p><p>CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，因此CMS收集器也被称为并发低停顿收集器（Concurrent Low Pause Collector）。</p><p>缺点：</p><ul><li>无法处理浮动垃圾（Floating Garbage） 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为“浮动垃圾”。</li><li>标记-清除算法导致的空间碎片 CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。</li></ul><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，采用复制和标记整理算法，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p><ul><li>并行和并发</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li><li>将整个java堆内存划分成多个大小相等的Region</li><li>年轻代和老年代将不再物理隔离</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th align="left">收集器</th><th align="left">串行、并行or并发</th><th align="left">新生代/老年代</th><th align="left">算法</th><th align="left">目标</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">Serial</td><td align="left">串行</td><td align="left">新生代</td><td align="left">复制算法</td><td align="left">响应速度优先</td><td align="left">单CPU环境下的Client模式</td></tr><tr><td align="left">Serial Old</td><td align="left">串行</td><td align="left">老年代</td><td align="left">标记-整理</td><td align="left">响应速度优先</td><td align="left">单CPU环境下的Client模式、CMS的后备预案</td></tr><tr><td align="left">ParNew</td><td align="left">并行</td><td align="left">新生代</td><td align="left">复制算法</td><td align="left">响应速度优先</td><td align="left">多CPU环境时在Server模式下与CMS配合</td></tr><tr><td align="left">Parallel Scavenge</td><td align="left">并行</td><td align="left">新生代</td><td align="left">复制算法</td><td align="left">吞吐量优先</td><td align="left">在后台运算而不需要太多交互的任务</td></tr><tr><td align="left">Parallel Old</td><td align="left">并行</td><td align="left">老年代</td><td align="left">标记-整理</td><td align="left">吞吐量优先</td><td align="left">在后台运算而不需要太多交互的任务</td></tr><tr><td align="left">CMS</td><td align="left">并发</td><td align="left">老年代</td><td align="left">标记-清除</td><td align="left">响应速度优先</td><td align="left">集中在互联网站或B/S系统服务端上的Java应用</td></tr><tr><td align="left">G1</td><td align="left">并发</td><td align="left">both</td><td align="left">标记-整理+复制算法</td><td align="left">响应速度优先</td><td align="left">面向服务端应用，将来替换CMS</td></tr></tbody></table><h3 id="java的四种引用类型"><a href="#java的四种引用类型" class="headerlink" title="java的四种引用类型"></a>java的四种引用类型</h3><p>强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul><li>最普遍的引用，例如：Object obj = new Object()</li><li>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收</li><li>如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，obj=null</li></ul><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><ul><li>对象处在有用但非必需的状态</li><li>只有当内存空间不足时，GC才会回收该引用的对象的内存</li><li>常常用来实现高速缓存</li></ul><pre><code>    String str = new String(&quot;abc&quot;) //强引用    SoftReference&lt;String&gt; softRef = new SoftReference&lt;String&gt;(str); //软引用</code></pre><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><ul><li>非必需的对象，比软引用更弱一些</li><li>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</li><li>适于引用被偶尔使用且不影响垃圾收集的对象</li></ul><pre><code>String str = new String(&quot;abc&quot;) //强引用WeakReference&lt;String&gt; weakRef = new WeakReference&lt;String&gt;(str); //弱引用</code></pre><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><ul><li>不会决定对象的生命周期</li><li>任何时候都可能被垃圾回收器回收</li><li>跟踪对象被垃圾回收器回收的活动，起哨兵作用</li><li>必须和引用队列ReferenceQueue联合使用</li></ul><pre><code>String str = new String(&quot;abc&quot;) //强引用ReferenceQueue queue = new ReferenceQueue();    //引用队列PhantomReference&lt;String&gt; phantomRef = new PhantomReference&lt;String&gt;(str,queue); //虚引用</code></pre><h3 id="引用队列（ReferenceQueue）"><a href="#引用队列（ReferenceQueue）" class="headerlink" title="引用队列（ReferenceQueue）"></a>引用队列（ReferenceQueue）</h3><p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p><p>与软引用、弱引用不同，虚引用必须和引用队列一起使用。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm</title>
      <link href="/2020/07/13/mian-shi-jvm/"/>
      <url>/2020/07/13/mian-shi-jvm/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这些都是面试中常问到到jvm知识</li></ul><h2 id="谈谈你对java的理解"><a href="#谈谈你对java的理解" class="headerlink" title="谈谈你对java的理解"></a>谈谈你对java的理解</h2><ul><li>平台无关性：java是一门跨平台的语言</li><li>GC：垃圾回收机制，不用手动去释放堆内存</li><li>语言特性：泛型，反射，lambda表达式</li><li>面向对象：封装，继承，多态</li><li>类库</li><li>异常处理</li></ul><h3 id="如何实现跨平台"><a href="#如何实现跨平台" class="headerlink" title="如何实现跨平台"></a>如何实现跨平台</h3><p>java源码首先被编译成字节码，再由不同平台的JVM进行解析，java语言在不同平台下运行时不需要重新编译，java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令</p><ul><li>为什么JVM不直接解释执行源码<ul><li>准备工作：每次执行都要进行各种检查，语法，安全等；且这些都不会被保存下来，这样每次都会做很多重复的操作，通过生成中间字节码至少可以在重复执行代码的时候省去很多校验和检查</li><li>兼容性：字节码不一定要java源码生成，其他一些语言比如scala也可以编译生成字节码。这样其他语言就可以利用经过多年发展的JVM</li></ul></li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/49.png" alt=""></p><h3 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h3><p>java反射机制是运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制</p><h3 id="jvm如何加载-class文件"><a href="#jvm如何加载-class文件" class="headerlink" title="jvm如何加载.class文件"></a>jvm如何加载.class文件</h3><p>java虚拟机主要包含四个部分：Class Loader,Runtime Data Area,Execution Engine,Native Interface</p><ul><li>Class Loader：依据特定格式将.class文件加载进内存</li><li>Execution Engine：将命令进行解析</li><li>Native Interface：融合不同语言的原生库为java所用</li><li>Runtime Data Area：jvm内存空间结构模型</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/50.png" alt=""></p><p>组件的作用： 首先通过类加载器（ClassLoader）会加载类文件到内存，Class loader只管加载，只要符合文件结构就加载。运行时数据区（Runtime Data Area)是jvm的重点，我们所有所写的程序都被加载到这里，之后才开始运行。而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来融合不同的语言为java所用,从而实现整个程序的功能</p><p>ClassLoader在java中有着非要重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获得Class二进制数据流，它是java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责将Class文件里的二进制数据流装载进系统，然后交给java虚拟机进行连接，初始化等操作。</p><h3 id="类从编译到执行的过程"><a href="#类从编译到执行的过程" class="headerlink" title="类从编译到执行的过程"></a>类从编译到执行的过程</h3><ul><li>编译器把Robot.java源文件编译成Robot.class字节码文件</li><li>ClassLoader将字节码转换为JVM中Class<Robot>对象</li><li>JVM利用Class<Robot>对象实例化为Robot对象</li></ul><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><h4 id="什么是ClassLoader"><a href="#什么是ClassLoader" class="headerlink" title="什么是ClassLoader"></a>什么是ClassLoader</h4><p>大家都知道，当我们写好一个Java程序之后，不是管是CS还是BS应用，都是由若干个.class文件组织而成的一个完整的Java应用程序，当程序在运行时，即会调用该程序的一个入口函数来调用系统的相关功能，而这些功能都被封装在不同的class文件当中，所以经常要从这个class文件中要调用另外一个class文件中的方法，如果另外一个文件不存在的，则会引发系统异常。而程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。</p><ul><li>loadClass方法：它接收一个全类名，然后返回一个Class类型的实例，用于加载类</li><li>getParent方法：返回其父类ClassLoader</li></ul><h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>JVM 运行并不是一次性加载所需要的全部类的，它是按需加载，也就是延迟加载。程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会调用 ClassLoader 来加载这些类。加载完成后就会将 Class 对象存在 ClassLoader 里面，下次就不需要重新加载了。</p><p>比如你在调用某个类的静态方法时，首先这个类肯定是需要被加载的，但是并不会触及这个类的实例字段，那么实例字段的类别 Class 就可以暂时不必去加载，但是它可能会加载静态字段相关的类别，因为静态方法会访问静态字段。而实例字段的类别需要等到你实例化对象的时候才可能会加载。</p><h4 id="ClassLoader的种类"><a href="#ClassLoader的种类" class="headerlink" title="ClassLoader的种类"></a>ClassLoader的种类</h4><ul><li>BootStrap ClassLoader：c++编写，称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库java.*，如：rt.jar、resources.jar、charsets.jar等</li><li>Extension ClassLoader：java编写，称为扩展类加载器，负责加载Java的扩展类库javax.*，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。</li><li>App ClassLoader：java编写，称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件</li><li>自定义ClassLoader：java编写，定制化加载</li></ul><p>loadClass() 方法是加载目标类的入口，它首先会查找当前 ClassLoader 以及它的双亲里面是否已经加载了目标类，如果没有找到就会让双亲尝试加载，如果双亲都加载不了，就会调用 findClass() 让自定义加载器自己来加载目标类。ClassLoader 的 findClass() 方法是需要子类来覆盖的，不同的加载器将使用不同的逻辑来获取目标类的字节码。拿到这个字节码之后再调用 defineClass() 方法将字节码转换成 Class 对象</p><p>关键函数：</p><ul><li>findClass方法：用于寻找类文件</li><li>defineClass方法：接收一组字节，然后将它具体化为一个Class类型的实例，它一般从磁盘上加载一个文件，然后将文件的字节传给JVM（native方法）对于class的定义，将其具体化，实例化为一个Class类型实例</li></ul><p>defineClass 通常是和findClass 方法一起使用的，我们通过覆盖ClassLoader父类的findClass 方法来实现类的加载规则，从而取得要加载类的字节码，然后调用defineClass方法生成类的Class 对象</p><h4 id="类加载器的双亲委派机制"><a href="#类加载器的双亲委派机制" class="headerlink" title="类加载器的双亲委派机制"></a>类加载器的双亲委派机制</h4><ul><li>双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。</li><li>先自底向上的检查这个类曾经是否已经完成加载，如果没有加载则自顶向下的尝试加载类</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/51.png" alt=""></p><h4 id="为什么要用双亲委派机制去加载类"><a href="#为什么要用双亲委派机制去加载类" class="headerlink" title="为什么要用双亲委派机制去加载类"></a>为什么要用双亲委派机制去加载类</h4><ul><li>避免多份同样字节码的加载</li><li>保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全</li></ul><h4 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h4><ul><li>隐式加载：new</li><li>显示加载：loadClass，forName；（生成实例需要newInstance，而隐式加载不要）</li></ul><h4 id="loadClass和forName的区别"><a href="#loadClass和forName的区别" class="headerlink" title="loadClass和forName的区别"></a>loadClass和forName的区别</h4><h5 id="类的装载过程"><a href="#类的装载过程" class="headerlink" title="类的装载过程"></a>类的装载过程</h5><ul><li>加载：通过ClassLoader加载class文件字节码，生成Class对象</li><li>链接：<ul><li>校验：检查加载的class的正确性和安全性</li><li>准备：为类变量分配存储空间并设置类变量初始值</li><li>解析：JVM将常量池中的符号引用转换为直接引用（可选）</li></ul></li><li>初始化：执行类变量赋值和静态代码块</li></ul><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul><li>Class.forName得到的class是已经初始化完成的</li><li>Class.loadClass得到的class是还没有进行链接的</li></ul><h5 id="为什么要使用loadClass"><a href="#为什么要使用loadClass" class="headerlink" title="为什么要使用loadClass"></a>为什么要使用loadClass</h5><p>使用loadClass不需要执行初始化类中代码和链接的步骤，这样可以加快类的加载，把类的初始化步骤留给实际使用到这个类的时候去执行</p><h3 id="java的内存模型"><a href="#java的内存模型" class="headerlink" title="java的内存模型"></a>java的内存模型</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/52.png" alt=""></p><ul><li>JVM内存模型-JDK8</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/53.png" alt=""></p><ul><li>线程私有：程序计数器，虚拟机栈，本地方法栈</li><li>线程共享：MetaSpace，Java堆</li></ul><p>各内存模型的具体实现：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/60.png" alt=""></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>它是逻辑计数器，而非物理计数器</p><ul><li>当前线程所执行的字节码的行号指示器</li><li>改变计数器的值就可以获取下一条需要执行的字节码指令</li><li>是线程私有的</li><li>对Java方法进行计数，如果是Native方法则计数器值为Undefined</li><li>不会发生内存泄漏，也是唯一一个不会发生内存溢出的区域。（因为只是记录行号）</li></ul><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><ul><li>Java虚拟机栈也是线程私有的，描述的是Java方法执行的内存模型，每一个方法执行都会开辟一个栈帧，线程请求的栈的深度如果大于虚拟机所允许的最大深度则会抛出StackOverflowError异常,（太多的递归则会出现这个错误，因为每一个递归都会开辟一个栈帧）</li><li>虚拟机栈过多会引发java.lang.OutOfMemoryError异常</li><li>当每一个方法执行完之后，这个栈帧就会自动释放掉，也就是说不需要GC的垃圾回收机制来处理</li><li>一个栈帧包含：局部变量表，操作栈，动态链接，返回地址</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/54.png" alt=""></p><h5 id="局部变量表和操作数栈"><a href="#局部变量表和操作数栈" class="headerlink" title="局部变量表和操作数栈"></a>局部变量表和操作数栈</h5><ul><li>局部变量表：包含方法执行过程中的所有变量</li><li>操作数栈：入栈，出栈，复制，交换，产生消费变量</li></ul><p>局部变量表和操作数栈的关系：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/55.png" alt=""></p><h5 id="i-操作的字节码指令⭐"><a href="#i-操作的字节码指令⭐" class="headerlink" title="i++操作的字节码指令⭐"></a>i++操作的字节码指令⭐</h5><ul><li>将int类型常量加载到操作数栈顶</li><li>将int类型数值从操作数栈顶取出，并存储到到局部变量表的第1个Slot中</li><li>将int类型变量从局部变量表的第1个Slot中取出，并放到操作数栈顶</li><li>将局部变量表的第1个Slot中的int类型变量加1</li><li>表示将int类型数值从操作数栈顶取出，并存储到到局部变量表的第1个Slot中，即i中</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ul><li>与虚拟机栈类似，不过虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务</li></ul><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><ul><li>java堆是java虚拟机中管理的内存中最大的一部分，是线程共享的，唯一的目的就是存放对象实例。所有的对象实例以及数组都要在堆上分配内存，java堆也是垃圾回收器管理的主要区域，也被称为gc堆，收集器基本都采用分代收集算法，java堆还可以细分为新生代，老年代</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/56.png" alt=""></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul><li>方法区是线程共享的，用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，很多人也愿意称之为“永久代”</li><li>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。</li><li>JDK 1.8 中，已经没有方法区(永久代)，而是将方法区直接放在一个与堆不相连的本地内存区域(Native Memory)，这个区域被叫做元空间。</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>是方法区的一部分，用于存储编译器生成的各种字面量和符号引用</li></ul><h4 id="永久代，元空间与方法区的关系"><a href="#永久代，元空间与方法区的关系" class="headerlink" title="永久代，元空间与方法区的关系"></a>永久代，元空间与方法区的关系</h4><ul><li>涉及到内存模型时，往往会提到永久代，那么它和方法区又是什么关系呢？《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。在HotSpot上把GC分代收集扩展至方法区，或者说使用永久代来实现方法区。方法区是java虚拟机中定义，是一种规范，而永久代是一种实现，一个是标准，一个是实现</li><li>对于Java8， HotSpots取消了永久代，那么是不是也就没有方法区了呢？当然不是，方法区是一个规范，规范没变，它就一直在。那么取代永久代的就是元空间</li></ul><h4 id="元空间与永久代"><a href="#元空间与永久代" class="headerlink" title="元空间与永久代"></a>元空间与永久代</h4><p>元空间（MetaSpace）与永久代（PermGen）的区别：</p><ul><li>元空间使用本地内存（比较大），而永久代使用的是jvm内存</li></ul><p>MetaSpace相比PermGen的优势：</p><ul><li>字符串常量存在永久代中，容易出现性能问题和内存溢出</li><li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li><li>永久代会给GC带来不必要的复杂性</li><li>方便HotSpot与其他JVM如Jrockit的集成</li></ul><h3 id="JVM三大性能调优参数"><a href="#JVM三大性能调优参数" class="headerlink" title="JVM三大性能调优参数"></a>JVM三大性能调优参数</h3><ul><li>-Xms：堆的初始值</li><li>-Xmx：堆能达到的最大值</li><li>-Xss：规定了每个线程虚拟机栈（堆栈）的大小</li></ul><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><ul><li>栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</li><li>堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/57.png" alt=""></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/61.png" alt=""></p><p>所以堆与栈的区别很明显：</p><p>1.栈内存存储的是局部变量而堆内存存储的是实体；</p><p>2.栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p><p>3.栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾收机制不定时的回收。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>存放字符串常量和基本类型常量（public static final）。常量池位于堆内存</p><p>常量池的好处是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><p>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p><p>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</p><p>（2）节省运行时间：比较字符串时，== 比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</p><h3 id="理解堆，栈，常量池的几种实例"><a href="#理解堆，栈，常量池的几种实例" class="headerlink" title="理解堆，栈，常量池的几种实例"></a>理解堆，栈，常量池的几种实例</h3><ul><li>int a = 3;int b = 3;的内部工作</li></ul><p>栈有一个很重要的特殊性，就是存在栈中的数据可以共享。编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。</p><ul><li>String是一个特殊的包装类数据</li></ul><pre><code>    即可以用    String str = new String(&quot;abc&quot;); 的形式来创建    也可以用    String str = &quot;abc&quot;; 的形式来创建</code></pre><ul><li>关于String str = “abc”的内部工作。Java内部将此语句转化为以下几个步骤：<ul><li>(1) 先定义一个名为str的对String类的对象引用变量放入栈中。</li><li>(2) 在常量池中查找是否存在内容为”abc”字符串对象。</li><li>(3) 如果不存在则在常量池中创建”abc”，并让str引用该对象。</li><li>(4) 如果存在则直接让str引用该对象。</li></ul></li></ul><ul><li>我们再来看看 String str = new String(“abc”)创建过程<ul><li>(1) 先定义一个名为str的对String类的对象引用变量放入栈中。</li><li>(2) 然后在堆中（不是常量池）创建一个指定的对象，并让str引用指向该对象。</li><li>(3) 在常量池中查找是否存在内容为”abc”字符串对象。</li><li>(4) 如果不存在，则在常量池中创建内容为”abc”的字符串对象，并将堆中的对象与之联系起来。</li><li>(5) 如果存在，则将new出来的字符串对象与字符串常量池中的对象联系起来（即让个特殊* 成员变量value的指针指向它）</li></ul></li></ul><p>我们再接着看以下的代码</p><pre><code>    String str1 = new String(&quot;abc&quot;);     String str2 = &quot;abc&quot;;     System.out.println(str1==str2); //false </code></pre><p>创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。</p><p>对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份</p><p>这也就是有道面试题：String s = new String(“abc”);产生几个对象？答：一个或两个，如果常量池中原来没有”abc”,就是两个。</p><ul><li>String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</li></ul><pre><code>    String str1 = &quot;abc&quot;;      String str2 = new String(&quot;abc&quot;);     String str3 = str2.intern();    System.out.println( str1==str2 );  //false    System.out.println( str1==str3 );  //true</code></pre><ul><li>String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。 基本数据类型包装类的值不可修改。不仅仅是String类的值不可修改，所有的基本数据数据类型包装类都不能更改其内部的值。</li></ul><pre><code>    String str1 = &quot;abc&quot;;     String str2 = &quot;abc&quot;;     str1 = &quot;bcd&quot;;     System.out.println(str1 + &quot;,&quot; + str2); //bcd, abc     System.out.println(str1==str2); //false</code></pre><h3 id="元空间，堆，线程独占部分间的联系——内存角度"><a href="#元空间，堆，线程独占部分间的联系——内存角度" class="headerlink" title="元空间，堆，线程独占部分间的联系——内存角度"></a>元空间，堆，线程独占部分间的联系——内存角度</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/58.png" alt=""></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/59.png" alt=""></p><h3 id="Java中对象创建的几种方式。"><a href="#Java中对象创建的几种方式。" class="headerlink" title="Java中对象创建的几种方式。"></a>Java中对象创建的几种方式。</h3><p>创建对象的方式有四种：</p><ul><li>用new关键字创建。</li></ul><pre><code>User user = new User();</code></pre><ul><li>调用对象的clone方法。</li><li>利用反射，调用Class类的或者是Constructor类的newInstance（）方法。</li></ul><pre><code>    User user = User.class.newInstance();</code></pre><p>或者是</p><pre><code>    Constructor&lt;User&gt; constructor =User.class.getConstructor();    User user= constructor.newInstance();</code></pre><ul><li>用反序列化，调用ObjectInputStream类的readObject（）方法。</li></ul><h3 id="什么情况下会发生栈内存溢出。"><a href="#什么情况下会发生栈内存溢出。" class="headerlink" title="什么情况下会发生栈内存溢出。"></a>什么情况下会发生栈内存溢出。</h3><p>在HotSpot虚拟机中是不区分虚拟机栈和本地方法栈，栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈桢在虚拟机栈中入栈到出栈的过程。本地方法栈与虚拟机栈相似，区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><p>栈内存溢出是指线程请求的栈深度大于虚拟机所允许的最大深度，则将抛出StackOverflowError异常（StackOverflowError 不属于 OOM 异常）。最有可能的原因就是方法递归产生的这种结果。</p><p>另一个可能是引用了大的变量，在拓展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常（这个属于内存溢出）。</p><h3 id="Java对象创建的过程是怎么样的。"><a href="#Java对象创建的过程是怎么样的。" class="headerlink" title="Java对象创建的过程是怎么样的。"></a>Java对象创建的过程是怎么样的。</h3><p>对于一个普通的Java对象的创建，大致过程如下：</p><ul><li>虚拟机遇到new指令，到常量池定位到这个类的符号引用。</li><li>检查符号引用代表的类是否被加载、解析、初始化过 ，如果没有的话，则执行相应的类加载过程。</li><li>虚拟机为对象分配内存。 根据Java内存是否规整，分别通过“指针碰撞”或“空闲列表”来分配。</li><li>虚拟机将分配到的内存空间都初始化为零值。</li><li>虚拟机对对象进行必要的设置。</li><li>执行方法，成员变量进行初始化</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射</title>
      <link href="/2020/07/10/java-fan-she/"/>
      <url>/2020/07/10/java-fan-she/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>此文章用来记录java反射的用途和基本用法</li></ul><h3 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h3><p>java反射机制是运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制</p><h3 id="反射的用途"><a href="#反射的用途" class="headerlink" title="反射的用途"></a>反射的用途</h3><p>1、反编译：.class–&gt;.java</p><p>2、通过反射机制访问java对象的属性，方法，构造方法等（包括私有）</p><p>3、当我们在使用IDE,比如Ecplise时，当我们输入一个对象或者类，并想调用他的属性和方法是，一按点号，编译器就会自动列出他的属性或者方法，这里就是用到反射。</p><p>4、反射最重要的用途就是开发各种通用框架。比如很多框架（Spring）都是配置化的（比如通过XML文件配置Bean），为了保证框架的通用性，他们可能需要根据配置文件加载不同的类或者对象，调用不同的方法，这个时候就必须使用到反射了，运行时动态加载需要的加载的对象。</p><p>比如，加载数据库驱动的，用到的也是反射。</p><pre><code>    Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 动态加载mysql驱动</code></pre><h3 id="反射的基本使用"><a href="#反射的基本使用" class="headerlink" title="反射的基本使用"></a>反射的基本使用</h3><ul><li>通过反射机制可以访问java对象的属性，方法和构造方法等（包括私有）</li></ul><pre><code>    //但访问私有东西需要突破访问限制，调用setAccessible(true)方法，设置成true    私有东西.setAccessible(true);//暴力访问(忽略掉访问修饰符)</code></pre><h4 id="获取Class类"><a href="#获取Class类" class="headerlink" title="获取Class类"></a>获取Class类</h4><p>主要有三种方法</p><ul><li>getClass()</li><li>任何数据类型（包括基本数据类型）都有一个”静态”的class属性</li><li>forName(String className),最常用</li></ul><pre><code>    package fanshe;    public class Fanshe {        public static void main(String[] args) {            //第一种方式获取Class对象              Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。            Class stuClass = stu1.getClass();//获取Class对象            System.out.println(stuClass.getName());            //第二种方式获取Class对象            Class stuClass2 = Student.class;            System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个            //第三种方式获取Class对象            try {                Class stuClass3 = Class.forName(&quot;fanshe.Student&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名                System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象            } catch (ClassNotFoundException e) {                e.printStackTrace();            }        }    }</code></pre><p>三种方式中，常用第三种，第一种对象都有了还要反射干什么，第二种需要导入类包，依赖太强，不导包就抛编译错误。一般都使用第三种，一个字符串可以传入也可以写在配置文件中等多种方法。</p><h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><p>通过反射创建实例主要有两种方式</p><ul><li>使用Class的newInstance()方法来创建Class对象对应类的实例</li></ul><pre><code>    Class c = Class.forName(&quot;fanshe.Student&quot;);    Object str = c.newInstance();</code></pre><ul><li>先通过Class对象获取指定的Constructor对象，再调用Constuctor对象的newInstance()方法来创建对象，这种方法可以用指定的构造器构造类的实例,上述是无参构造实例</li></ul><pre><code>    //获取Class对象    Class c = Class.forName(&quot;fanshe.Student&quot;);    //通过Class对象获取指定的Constructor构造器对象    Constructor constructor = c.getConstructor(String.class);    //创建指定的构造器构造类实例    Object str = constructor.newInstance(&quot;Hello reflection&quot;);</code></pre><h4 id="通过反射获取构造方法并使用"><a href="#通过反射获取构造方法并使用" class="headerlink" title="通过反射获取构造方法并使用"></a>通过反射获取构造方法并使用</h4><p>1）批量获取的方法：</p><ul><li>public Constructor[] getConstructors()：所有”公有的”构造方法</li><li>public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</li></ul><p>（2）单个获取的方法，并调用：</p><ul><li>public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法：</li><li>public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有；</li></ul><p>（3） 调用构造方法：</p><p>Constructor–&gt;newInstance(Object… initargs)</p><p>newInstance是 Constructor类的方法（管理构造函数的类）</p><p>api的解释为：newInstance(Object… initargs) ，使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</p><p>它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象，并为之调用。</p><ul><li>例子：Student类：共六个方法</li></ul><pre><code>    package fanshe;    public class Student {        //---------------构造方法-------------------        //（默认的构造方法）        Student(String str){            System.out.println(&quot;(默认)的构造方法 s = &quot; + str);        }        //无参构造方法        public Student(){            System.out.println(&quot;调用了公有、无参构造方法执行了。。。&quot;);        }        //有一个参数的构造方法        public Student(char name){            System.out.println(&quot;姓名：&quot; + name);        }        //有多个参数的构造方法        public Student(String name ,int age){            System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age);//这的执行效率有问题，以后解决。        }        //受保护的构造方法        protected Student(boolean n){            System.out.println(&quot;受保护的构造方法 n = &quot; + n);        }        //私有构造方法        private Student(int age){            System.out.println(&quot;私有的构造方法   年龄：&quot;+ age);        }    }</code></pre><ul><li>测试类</li></ul><pre><code>    package fanshe;    import java.lang.reflect.Constructor;    /*     * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；     *      * 1.获取构造方法：     *         1).批量的方法：     *             public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法                public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)     *         2).获取单个的方法，并调用：     *             public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法：     *             public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；              *         3).调用构造方法：     *             Constructor--&gt;newInstance(Object... initargs)     */    public class Constructors {        public static void main(String[] args) throws Exception {            //1.加载Class对象            Class clazz = Class.forName(&quot;fanshe.Student&quot;);            //2.获取所有公有构造方法            System.out.println(&quot;**********************所有公有构造方法*********************************&quot;);            Constructor[] conArray = clazz.getConstructors();            for(Constructor c : conArray){                System.out.println(c);            }            System.out.println(&quot;************所有的构造方法(包括：私有、受保护、默认、公有)***************&quot;);            conArray = clazz.getDeclaredConstructors();            for(Constructor c : conArray){                System.out.println(c);            }            System.out.println(&quot;*****************获取公有、无参的构造方法*******************************&quot;);            Constructor con = clazz.getConstructor(null);            //1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型            //2&gt;、返回的是描述这个无参构造函数的类对象。            System.out.println(&quot;con = &quot; + con);            //调用构造方法            Object obj = con.newInstance();        //    System.out.println(&quot;obj = &quot; + obj);        //    Student stu = (Student)obj;            System.out.println(&quot;******************获取私有构造方法，并调用*******************************&quot;);            con = clazz.getDeclaredConstructor(char.class);            System.out.println(con);            //调用构造方法            con.setAccessible(true);//暴力访问(忽略掉访问修饰符)            obj = con.newInstance(&#39;男&#39;);        }    }</code></pre><ul><li>控制台输出</li></ul><pre><code>    **********************所有公有构造方法*********************************    public fanshe.Student(java.lang.String,int)    public fanshe.Student(char)    public fanshe.Student()    ************所有的构造方法(包括：私有、受保护、默认、公有)***************    private fanshe.Student(int)    protected fanshe.Student(boolean)    public fanshe.Student(java.lang.String,int)    public fanshe.Student(char)    public fanshe.Student()    fanshe.Student(java.lang.String)    *****************获取公有、无参的构造方法*******************************    con = public fanshe.Student()    调用了公有、无参构造方法执行了。。。    ******************获取私有构造方法，并调用*******************************    public fanshe.Student(char)    姓名：男</code></pre><h4 id="获取成员变量并调用"><a href="#获取成员变量并调用" class="headerlink" title="获取成员变量并调用"></a>获取成员变量并调用</h4><p>1.批量的</p><ul><li>1).Field[] getFields():获取所有的”公有字段”</li><li>2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</li></ul><p>2.获取单个的：</p><ul><li>1).Field getField(String fieldName):获取某个”公有的”字段；</li><li>2).Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</li></ul><ul><li>设置字段的值：</li></ul><pre><code>     Field --&gt; public void set(Object obj,Object value):                 参数说明：                 1.obj:要设置的字段所在的对象；                 2.value:要为字段设置的值；</code></pre><ul><li>Student类：</li></ul><pre><code>    package fanshe.field;    public class Student {        public Student(){        }        //**********字段*************//        public String name;        protected int age;        char sex;        private String phoneNum;        @Override        public String toString() {            return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex                    + &quot;, phoneNum=&quot; + phoneNum + &quot;]&quot;;        }    }</code></pre><ul><li>测试类</li></ul><pre><code>    package fanshe.field;    import java.lang.reflect.Field;    public class Fields {            public static void main(String[] args) throws Exception {                //1.获取Class对象                Class stuClass = Class.forName(&quot;fanshe.field.Student&quot;);                //2.获取字段                System.out.println(&quot;************获取所有公有的字段********************&quot;);                Field[] fieldArray = stuClass.getFields();                for(Field f : fieldArray){                    System.out.println(f);                }                System.out.println(&quot;************获取所有的字段(包括私有、受保护、默认的)********************&quot;);                fieldArray = stuClass.getDeclaredFields();                for(Field f : fieldArray){                    System.out.println(f);                }                System.out.println(&quot;*************获取公有字段**并调用***********************************&quot;);                Field f = stuClass.getField(&quot;name&quot;);                System.out.println(f);                //获取一个对象                Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student();                //为字段设置值                f.set(obj, &quot;刘德华&quot;);//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;                //验证                Student stu = (Student)obj;                System.out.println(&quot;验证姓名：&quot; + stu.name);                System.out.println(&quot;**************获取私有字段****并调用********************************&quot;);                f = stuClass.getDeclaredField(&quot;phoneNum&quot;);                System.out.println(f);                f.setAccessible(true);//暴力反射，解除私有限定                f.set(obj, &quot;18888889999&quot;);                System.out.println(&quot;验证电话：&quot; + stu);            }        }</code></pre><ul><li>控制台输出</li></ul><pre><code>    ************获取所有公有的字段********************    public java.lang.String fanshe.field.Student.name    ************获取所有的字段(包括私有、受保护、默认的)********************    public java.lang.String fanshe.field.Student.name    protected int fanshe.field.Student.age    char fanshe.field.Student.sex    private java.lang.String fanshe.field.Student.phoneNum    *************获取公有字段**并调用***********************************    public java.lang.String fanshe.field.Student.name    验证姓名：刘德华    **************获取私有字段****并调用********************************    private java.lang.String fanshe.field.Student.phoneNum    验证电话：Student [name=刘德华, age=0, sex=</code></pre><h4 id="获取成员方法并调用"><a href="#获取成员方法并调用" class="headerlink" title="获取成员方法并调用"></a>获取成员方法并调用</h4><p>1.批量的：<br>Method[] getMethods():获取所有”公有方法”；（包含了父类的方法也包含Object类）<br>public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</p><p>2.获取单个的：</p><ul><li>Method getMethod(String name,Class&lt;?&gt;… parameterTypes):</li><li>public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes)</li></ul><pre><code>    参数：    name : 方法名；    Class ... : 形参的Class类型对象</code></pre><ul><li>调用方法：</li></ul><pre><code>    Method --&gt; public Object invoke(Object obj,Object... args):                参数说明：                obj : 要调用方法的对象；                args:调用方式时所传递的实参；</code></pre><ul><li>Student类</li></ul><pre><code>    package fanshe.method;    public class Student {        //**************成员方法***************//        public void show1(String s){            System.out.println(&quot;调用了：公有的，String参数的show1(): s = &quot; + s);        }        protected void show2(){            System.out.println(&quot;调用了：受保护的，无参的show2()&quot;);        }        void show3(){            System.out.println(&quot;调用了：默认的，无参的show3()&quot;);        }        private String show4(int age){            System.out.println(&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot; + age);            return &quot;abcd&quot;;        }    }</code></pre><ul><li>测试类</li></ul><pre><code>    package fanshe.method;    import java.lang.reflect.Method;    public class MethodClass {        public static void main(String[] args) throws Exception {            //1.获取Class对象            Class stuClass = Class.forName(&quot;fanshe.method.Student&quot;);            //2.获取所有公有方法            System.out.println(&quot;***************获取所有的”公有“方法*******************&quot;);            stuClass.getMethods();            Method[] methodArray = stuClass.getMethods();            for(Method m : methodArray){                System.out.println(m);            }            System.out.println(&quot;***************获取所有的方法，包括私有的*******************&quot;);            methodArray = stuClass.getDeclaredMethods();            for(Method m : methodArray){                System.out.println(m);            }            System.out.println(&quot;***************获取公有的show1()方法*******************&quot;);            Method m = stuClass.getMethod(&quot;show1&quot;, String.class);            System.out.println(m);            //实例化一个Student对象            Object obj = stuClass.getConstructor().newInstance();            m.invoke(obj, &quot;刘德华&quot;);            System.out.println(&quot;***************获取私有的show4()方法******************&quot;);            m = stuClass.getDeclaredMethod(&quot;show4&quot;, int.class);            System.out.println(m);            m.setAccessible(true);//解除私有限定            Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参            System.out.println(&quot;返回值：&quot; + result);            }    }</code></pre><ul><li>控制台输出</li></ul><pre><code>    ***************获取所有的”公有“方法*******************    public void fanshe.method.Student.show1(java.lang.String)    public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException    public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException    public final void java.lang.Object.wait() throws java.lang.InterruptedException    public boolean java.lang.Object.equals(java.lang.Object)    public java.lang.String java.lang.Object.toString()    public native int java.lang.Object.hashCode()    public final native java.lang.Class java.lang.Object.getClass()    public final native void java.lang.Object.notify()    public final native void java.lang.Object.notifyAll()    ***************获取所有的方法，包括私有的*******************    public void fanshe.method.Student.show1(java.lang.String)    private java.lang.String fanshe.method.Student.show4(int)    protected void fanshe.method.Student.show2()    void fanshe.method.Student.show3()    ***************获取公有的show1()方法*******************    public void fanshe.method.Student.show1(java.lang.String)    调用了：公有的，String参数的show1(): s = 刘德华    ***************获取私有的show4()方法******************    private java.lang.String fanshe.method.Student.show4(int)    调用了，私有的，并且有返回值的，int参数的show4(): age = 20    返回值：abcd</code></pre><h4 id="反射main方法"><a href="#反射main方法" class="headerlink" title="反射main方法"></a>反射main方法</h4><ul><li>Student类</li></ul><pre><code>    package fanshe.main;    public class Student {        public static void main(String[] args) {            System.out.println(&quot;main方法执行了。。。&quot;);        }    }</code></pre><ul><li>测试类</li></ul><pre><code>    package fanshe.main;    import java.lang.reflect.Method;    /**     * 获取Student类的main方法、不要与当前的main方法搞混了     */    public class Main {        public static void main(String[] args) {            try {                //1、获取Student对象的字节码                Class clazz = Class.forName(&quot;fanshe.main.Student&quot;);                //2、获取main方法                 Method methodMain = clazz.getMethod(&quot;main&quot;, String[].class);//第一个参数：方法名称，第二个参数：方法形参的类型，                //3、调用main方法                // methodMain.invoke(null, new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;});                 //第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数                 //这里拆的时候将  new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;} 拆成3个对象。。。所以需要将它强转。                 methodMain.invoke(null, (Object)new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;});//方式一                // methodMain.invoke(null, new Object[]{new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}});//方式二                        } catch (Exception e) {                e.printStackTrace();            }        }    }</code></pre><ul><li>控制台输出</li></ul><pre><code>    main方法执行了。。。</code></pre><h4 id="反射方法的其他使用–通过反射越过泛型检查："><a href="#反射方法的其他使用–通过反射越过泛型检查：" class="headerlink" title="反射方法的其他使用–通过反射越过泛型检查："></a>反射方法的其他使用–通过反射越过泛型检查：</h4><p>泛型用在编译期，编译过后泛型擦除（消失掉），所以是可以通过反射越过泛型检查的</p><ul><li>测试类：</li></ul><pre><code>    import java.lang.reflect.Method;    import java.util.ArrayList;    /*     * 通过反射越过泛型检查     * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？     */    public class Demo {        public static void main(String[] args) throws Exception{            ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;();            strList.add(&quot;aaa&quot;);            strList.add(&quot;bbb&quot;);        //    strList.add(100);            //获取ArrayList的Class对象，反向的调用add()方法，添加数据            Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象            //获取add()方法            Method m = listClass.getMethod(&quot;add&quot;, Object.class);            //调用add()方法            m.invoke(strList, 100);            //遍历集合            for(Object obj : strList){                System.out.println(obj);            }        }    }</code></pre><ul><li>控制台输出</li></ul><pre><code>    aaa    bbb    100</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2020/07/07/mian-shi-shu-ju-ku/"/>
      <url>/2020/07/07/mian-shi-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这些都是面试的时候常被问到的一些数据库方面的问题</li></ul><h3 id="如何设计一个关系型数据库"><a href="#如何设计一个关系型数据库" class="headerlink" title="如何设计一个关系型数据库"></a>如何设计一个关系型数据库</h3><h4 id="首先将数据库设计成两大部分"><a href="#首先将数据库设计成两大部分" class="headerlink" title="首先将数据库设计成两大部分"></a>首先将数据库设计成两大部分</h4><ul><li>存储部分：该部分类似于一个文件系统，将数据持久化到存储设备中</li><li>程序实例部分：对存储进行逻辑化的管理</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/43.png" alt=""></p><h4 id="程序实例部分"><a href="#程序实例部分" class="headerlink" title="程序实例部分"></a>程序实例部分</h4><ul><li>存储管理模块：数据的逻辑关系转换成物理的存储关系</li><li>缓存机制：优化执行效率</li><li>sql解析：用于将sql语句解析</li><li>日志管理：记录操作</li><li>权限划分：进行多用户管理</li><li>灾难机制：灾难恢复模块</li><li>索引管理：优化查询效率</li><li>锁管理：让数据库支持并发操作</li></ul><h4 id="提高执行效率的方法"><a href="#提高执行效率的方法" class="headerlink" title="提高执行效率的方法"></a>提高执行效率的方法</h4><p>减少IO、缓存、淘汰机制 </p><ul><li>尽可能减少IO</li><li>一次性读取多行（块，或者页）：这些块或者页中的一部分，可能并不是我们本次所要使用的，而是将其取出存放在缓存中，根据将要使用的行周边这些行业极有可能被使用的经验，缓存的非本次使用数据，也能起到优化效率的作用。</li><li>缓存不宜过大，并且需要有相应的缓存淘汰机制</li></ul><h3 id="数据库的三范式是什么"><a href="#数据库的三范式是什么" class="headerlink" title="数据库的三范式是什么"></a>数据库的三范式是什么</h3><p>数据库第一、第二、第三范式的理解。</p><p>第一范式，是指没有重复的列， 表示数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p><p>第二范式，是指属性完全依赖主键， 要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。</p><p>第三范式，是要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。 也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。</p><h3 id="char-和-varchar-的区别是什么？"><a href="#char-和-varchar-的区别是什么？" class="headerlink" title="char 和 varchar 的区别是什么？"></a>char 和 varchar 的区别是什么？</h3><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p><p>char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p><p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p><p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p><h3 id="说一下-mysql-常用的引擎？"><a href="#说一下-mysql-常用的引擎？" class="headerlink" title="说一下 mysql 常用的引擎？"></a>说一下 mysql 常用的引擎？</h3><p>InnoDB 引擎：MySQL 的5.5之后的默认引擎，InnoDB 引擎提供了对数据库事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p><p>MyISAM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p><h3 id="Myisam和InnoDB的区别⭐"><a href="#Myisam和InnoDB的区别⭐" class="headerlink" title="Myisam和InnoDB的区别⭐"></a>Myisam和InnoDB的区别⭐</h3><ul><li>是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁，适合高并发操作。</li><li>是否支持外键： MyISAM不支持，而InnoDB支持</li><li>是否支持事务：MyISAM不支持，而InnoDB支持</li><li>缓存：MyISAM只缓存索引，InnoDB缓存索引和真实数据，所以对内存要求高</li><li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li></ul><h3 id="如何定位并优化慢查询sql"><a href="#如何定位并优化慢查询sql" class="headerlink" title="如何定位并优化慢查询sql"></a>如何定位并优化慢查询sql</h3><p>具体场景具体分析，这里是大概思路</p><ul><li>根据慢日志来定位慢sql</li><li>通过explain来分析慢sql</li><li>修改sql或者尽量让sql走索引</li></ul><h3 id="SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。"><a href="#SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。" class="headerlink" title="SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。"></a>SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。</h3><p>SQL优化步骤一般是：</p><ul><li>通过show status命令了解各种SQL的执行频率</li><li>定位执行效率较低的SQL语句</li><li>通过EXPLAIN分析较低SQL的执行计划</li><li>通过show profile分析SQL</li><li>通过trace分析优化器如何选择执行计划</li><li>确定问题并采取相应的优化措施</li></ul><p>执行计划是SQL在数据库执行时的表现情况，通常用于SQL性能分析、优化等场景。在MySQL中使用explain关键字来查看。</p><h2 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h2><h3 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h3><ul><li>当我们没有使用索引的时候是如何查询数据的呢？答案是全表扫描，把所有的数据都查询出来缓存，然后进行轮询，但是这个只适用于数据量小的表，当我们表中的数据量非常大的时候进行全表扫描那将变得非常慢。此时我们建立索引就可以优化我们的查询速度</li></ul><h3 id="什么样的信息可以建立索引"><a href="#什么样的信息可以建立索引" class="headerlink" title="什么样的信息可以建立索引"></a>什么样的信息可以建立索引</h3><ul><li>主键，唯一键和普通键都可，只要能让数据有一定区分性的字段。</li></ul><h3 id="密集索引和稀疏索引的区别"><a href="#密集索引和稀疏索引的区别" class="headerlink" title="密集索引和稀疏索引的区别"></a>密集索引和稀疏索引的区别</h3><h3 id="索引是建立的越多越好吗"><a href="#索引是建立的越多越好吗" class="headerlink" title="索引是建立的越多越好吗"></a>索引是建立的越多越好吗</h3><p>当然不是</p><ul><li>数据量小的表不需要建立索引，建立会增加额外的开销</li><li>数据变更需要维护索引，因此更多的索引意味着更高的维护成本</li><li>更多的索引意味着也需要更多的空间</li></ul><h3 id="mysql-索引是怎么实现的？"><a href="#mysql-索引是怎么实现的？" class="headerlink" title="mysql 索引是怎么实现的？"></a>mysql 索引是怎么实现的？</h3><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的 。</p><h3 id="MySQL的索引原理"><a href="#MySQL的索引原理" class="headerlink" title="MySQL的索引原理"></a>MySQL的索引原理</h3><p>mysql索引采用的数据结构主要时B+-Tree，Hash，平衡二叉树</p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><ul><li>从理论上来说二叉查找树的时间复杂度为O(logn)，查找速度和比较次数都是最少的，但为什么不用二叉查找树呢</li><li>因为我们要考虑磁盘IO的影响，每查询下一个节点都会进行一次IO，所以我们要减少IO的次数，对于树来说，IO次数就是树的高度，所以我们要把树变得矮胖，b树和b+树就是这样的树</li></ul><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小</p><p>定义：</p><ul><li>根节点至少包含两个孩子</li><li>树中每个节点最多包含有m个孩子（m&gt;=2）</li><li>除根节点和叶节点外，其他每个节点都因包含ceil(m/2)个孩子（向上取整）</li><li>所有的叶子节点都位于同一层</li><li>k个关键字把节点拆成k+1段，分别指向k+1个儿子，同时满足查找树的大小关系</li></ul><p>关键字：假设每个非终端结点中包含n个关键字信息</p><ul><li>Ki(i=1…n)为关键字，且关键字按顺序升序排序k(i-1)&lt;k(i)</li><li>非叶子结点的关键字个数=儿子数-1；</li><li>非叶子节点的指针：p[1],p[2],…,p[M];其中p[1]指向关键字小于k[1]的子树，p[M]指向关键字大于k[M-1]的子树，其他p[i]指向关键字属于(k[i-1],k[i])的子树</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/44.png" alt=""></p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+-Tree"></a>B+-Tree</h3><p>b+树，是b树的一种变体，查询性能更好。m阶的b+树的特征：</p><p>b+树其定义基本与b树相同，除了：</p><ul><li>非叶子节点的子树指针与关键字个数相同</li><li>非叶子节点的子树指针p[i],指向关键字值[k[i],k[i+1])</li><li>非叶子节点仅用来保存索引，所有数据都保存在叶子节点中（b树是每个关键字都保存数据）</li><li>所有叶子节点都有一个链指针指向下一个叶子节点</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/45.png" alt=""></p><h4 id="b-树相比于b树的查询优势"><a href="#b-树相比于b树的查询优势" class="headerlink" title="b+树相比于b树的查询优势"></a>b+树相比于b树的查询优势</h4><ul><li>b+树中间不保存数据，只保存索引，所以磁盘页可以保存更多节点元素，更“矮胖”</li><li>b+树查询必须找到叶子节点，b树只要匹配到即可不用管元素位置，所以b+树更加稳定（并不慢）</li><li>对于查找范围来说b+树只需遍历叶子节点链表即可，b树却需要重复的进行中序遍历</li></ul><h4 id="b-树更加适合用于做存储索引"><a href="#b-树更加适合用于做存储索引" class="headerlink" title="b+树更加适合用于做存储索引"></a>b+树更加适合用于做存储索引</h4><ul><li>B+树的磁盘读写代价更低</li><li>B+树的查询效率更加稳定</li><li>B+树更加有利于对数据库的扫描</li></ul><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>缺点：</p><ul><li>仅仅只能满足”=”,”IN”,不能使用范围查询</li><li>无法被用来避免数据的排序操作</li><li>不能利用部分索引键来查询</li><li>不能避免表扫描</li><li>遇到大量Hash值相等的情况后性能就不一定比B+-Tree索引高 </li></ul><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><h4 id="如何写SQL能够有效地使用到复合索引"><a href="#如何写SQL能够有效地使用到复合索引" class="headerlink" title="如何写SQL能够有效地使用到复合索引"></a>如何写SQL能够有效地使用到复合索引</h4><p>复合索引也叫组合索引和联合索引，用户可以在多个列上建立索引,这种索引叫做复合索引。复合索引在数据库操作期间所需的开销更小,可以代替多个单一索引。</p><ul><li>创建复合索引：CREATE INDEX columnId ON table1(col1,col2,col3) ;</li><li>使用复合索引：select * from table1 where col1= A and col2= B and col3 = C</li><li>对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高。</li><li>复合索引可以用到多个where条件查询下，比如查询年龄是12和性别是男的所有学生。这样避免了多一次的排序操作。</li></ul><h4 id="联合索引具有最左匹配原则，即最左优先"><a href="#联合索引具有最左匹配原则，即最左优先" class="headerlink" title="联合索引具有最左匹配原则，即最左优先"></a>联合索引具有最左匹配原则，即最左优先</h4><p>比如，我们建立了一个2列的联合索引(col1,col2),实际上已经建立了两个联合索引(col1)、(col1,col2），解释如下：</p><ul><li>B+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了（这种情况下无法使用联合索引）。</li></ul><p>联合索引的意义在于：</p><ul><li>一个顶三个。建了一个(a,b,c)的复合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，因为每多一个索引，都会增加写操作的开销和磁盘空间的开销。</li><li>作为覆盖索引。同样的有复合索引（a,b,c），如果有如下的sql: select a,b,c from table where a=1 and b = 1。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。</li><li>索引列越多，通过索引筛选出的数据越少。</li></ul><h3 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h3><h4 id="聚集索引和非聚集索引的区别"><a href="#聚集索引和非聚集索引的区别" class="headerlink" title="聚集索引和非聚集索引的区别"></a>聚集索引和非聚集索引的区别</h4><ul><li>非聚集索引也称之为辅助索引。聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的数据。聚集索引叶子节点存放的即为整张表的行记录数据；而辅助索引叶子节点除了包含键值以外，还包含了一个书签（bookmark），该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。 所以，聚集索引一般比辅助索引体积大</li><li>由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。在多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上只能找到数据。聚集索引的好处在于，它对于主键的排序查找和范围查找速度都非常快，叶子节点的数据就是用户所要查询的数据。需要注意的是（InnoDB）：<ul><li>如果一个主键被定义了，那么这个主键就是作为聚集索引。</li><li>如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引。</li><li>如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。</li><li>非主键索引存储相关键位和其对应的主键值，包含两次查找（一次是查找非主键索引自身，另一次查找主键索引也就是聚集索引的主键）</li></ul></li></ul><p>另外，切记的是，聚集索引的存储并不是物理上连续的，而是逻辑上连续的。 这其中有两点：</p><ul><li>每个表的数据页通过双向链表链接，页按照主键的顺序排序；</li><li>每个页的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</li></ul><p>辅助索引的存在并不影响数据在聚集索引的组织，所以每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引（也就是聚集索引）的主键，然后在通过主键索引来找到一个完整的行记录。</p><p>以上说的都是InnoDB存储引擎场景下，而对于MyISAM引擎，索引文件和数据文件是分离的，索引文件仅保存数据记录的地址，具体不细究</p><h3 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h3><ul><li>普通索引（INDEX），最基本的索引，没有任何的约束。INDEX index_name(name)</li><li>唯一索引（UNIQUE），与普通索引类似，但索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法与普通索引类似 UNIQUE index_name(name)</li><li>全文索引（FULLTEXT）,MyISAM表全系支持，InnoDB 1.2.x后支持。FULLTEXT(content)</li><li>主键索引（PRIMARY KEY）,特殊的唯一索引，不允许有空值，每张表只能有一个</li><li>复合索引，将多个列组合在一起创建索引，可以覆盖多个列</li></ul><h3 id="索引如何优化"><a href="#索引如何优化" class="headerlink" title="索引如何优化"></a>索引如何优化</h3><ul><li>非空字段not null，mysql很难对空值进行查询优化</li><li>区分度高，离散度大，作为索引尽量不要有大量相同值</li><li>索引值的长度不能太长（比较耗费时间）</li></ul><h2 id="锁模块"><a href="#锁模块" class="headerlink" title="锁模块"></a>锁模块</h2><h3 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h3><ul><li>按锁的粒度划分，分为表级锁，行级锁和页级锁（不常用）</li><li>按锁级别分类，分为共享锁（S）和排它锁（X）</li><li>按加锁方式划分，分为自动锁（进行增删改查时mysql自动加上的锁），显式锁（主动加的锁lock in share mode和for update）</li><li>按操作划分，可分为DML锁（增删改查）和DDL锁（改变表结构）</li><li>按使用方式划分，分为乐观锁和悲观锁</li></ul><h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><p>这两种锁的说法，主要是对“是否真正在数据库层面加锁”进行讨论。</p><p>悲观锁（Pessimistic Locking）</p><p>悲观锁假定当前事务操纵数据资源时，肯定还会有其他事务同时访问该数据资源，为了避免当前事务的操作受到干扰，先锁定资源。悲观锁需使用数据库的锁机制实现，如使用行级排他锁或表级排它锁。</p><p>乐观锁（Optimistic Locking）</p><p>乐观锁假定当前事务操纵数据资源时，不会有其他事务同时访问该数据资源，因此不在数据库层次上的锁定。乐观锁使用由程序逻辑控制的技术来避免可能出现的并发问题。</p><p>唯一能够同时保持高并发和高可伸缩性的方法就是使用带版本检查的乐观锁。</p><p>乐观锁不能解决脏读的问题，因此仍需要数据库至少启用“读已提交”的事务隔离级别。</p><h3 id="说一下乐观锁和悲观锁"><a href="#说一下乐观锁和悲观锁" class="headerlink" title="说一下乐观锁和悲观锁"></a>说一下乐观锁和悲观锁</h3><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</p><p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><p>（如SVN、GIT提交代码就是这样的）</p><p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p><p>一般是 where id=XX for update 来实现 （一般银行转账、工单审批）</p><p>优缺点：</p><p>乐观锁：性能高、重试失败成本不高建议乐观</p><p>悲观锁：性能低，但安全，失败成本高建议悲观，使用不当有死锁风险</p><h3 id="多版本并发控制-MVCC-⭐"><a href="#多版本并发控制-MVCC-⭐" class="headerlink" title="多版本并发控制(MVCC)⭐"></a>多版本并发控制(MVCC)⭐</h3><p>(Multi-Version Concurrency Control)</p><p>可以认为MVCC是行级锁的一个变种，innoDB采用了乐观锁的策略，在每行记录后保存两个隐藏列来实现，这两个列保存了行的版本号信息，每开启一个新事务，版本号自动更新，事务开始时刻的版本号作为事务的版本号。用来和查询到的记录所带的版本号进行比较来判断。</p><h3 id="MyISAM和InnoDB在锁方面之间的区别"><a href="#MyISAM和InnoDB在锁方面之间的区别" class="headerlink" title="MyISAM和InnoDB在锁方面之间的区别"></a>MyISAM和InnoDB在锁方面之间的区别</h3><ul><li>MyISAM用的是表级锁，不支持行级锁</li><li>InnoDB默用的是行级锁，也支持表级锁</li></ul><h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><ul><li>读锁是共享锁，写锁是排他锁</li></ul><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><ul><li>共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。</li></ul><p>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。</p><h4 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h4><ul><li>排他锁（X锁）：用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。</li></ul><p>如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</p><p>我们在操作数据库的时候，可能会由于并发问题而引起的数据的不一致性（数据冲突）</p><h4 id="如何对查询操作上排他锁"><a href="#如何对查询操作上排他锁" class="headerlink" title="如何对查询操作上排他锁"></a>如何对查询操作上排他锁</h4><ul><li>排他锁主要用于数据增删改操作，那么可以对查询表的操作上排他锁吗，当然是可以的，但是上了排他锁之后就不能上其他锁了，只需在查询语句后面加上for update 就可以上一个排他锁</li></ul><pre><code>    select * from person_info_myisam where id between 1 and 2000000 for update;</code></pre><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul><li>为什么在查询大量数据的时候进行增删改操作会很慢(像上读锁后上写锁)<ul><li>因为在进行大量数据查询的时候MyISAM会给表加上一个表级别读锁，而对数据表进行增删改的时候会给表加上一个表级别的写锁，当读锁未被释放的时候，另一个session想对同一张表加上写锁，它就会阻塞，直到所有的读锁都被释放</li></ul></li></ul><ul><li>给表上一个读锁（手动）</li></ul><pre><code>    lock tables person_info_myisam read;    unlock tables;</code></pre><h4 id="MyISAM适用场景"><a href="#MyISAM适用场景" class="headerlink" title="MyISAM适用场景"></a>MyISAM适用场景</h4><ul><li>频繁执行全表count语句(保存了表的行数值，不需要全表扫描)</li><li>对数据增删改的频率不高（增删改要锁表），查询非常频繁</li><li>没有事务</li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li>InnoDB的上锁机制是二段锁<ul><li>何为二段锁，在一个事务操作中，分为加锁阶段和解锁阶段，且所有的加锁操作在解锁操作之前</li><li>当对记录进行更新操作或者select for update(X锁)、lock in share mode(S锁)时，会对记录进行加锁</li><li>解锁，在一个事务中，只有在commit或者rollback时，才是解锁阶段</li></ul></li><li>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</li><li>行级锁和表级锁：当sql语句用到索引的时候InnoDB用的是行级锁，当sql语句没有用到索引的时候是用表级锁把整张表锁住</li></ul><pre><code>    共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE    排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE</code></pre><h4 id="InnoDB适用场景"><a href="#InnoDB适用场景" class="headerlink" title="InnoDB适用场景"></a>InnoDB适用场景</h4><ul><li>数据增删改查都相当频繁（不需要锁住整张表）</li><li>可靠性要求比较高，要求支持事务</li></ul><h3 id="数据库的ACID是什么。"><a href="#数据库的ACID是什么。" class="headerlink" title="数据库的ACID是什么。"></a>数据库的ACID是什么。</h3><p>数据库系统引入事务的主要目的在于，事务会把数据库从一种一致性状态转换为另一种一致状态。</p><p>数据库事务具有以下4个基本特征，也就是著名的ACID。</p><ul><li>Atomic（原子性）：事务中包含的操作被看作是一个整体的业务单元，这个业务单元中的操作要么全部成功，要么全部失败，不会出现部分失败、部分成功的场景。</li><li>Consistency（一致性）：事务在完成时，必须使所有的数据都保持一致状态，在数据库中所有的修改都基于事务，保证了数据的完整性。</li><li>Isolation（隔离性）：数据库定义了隔离级别的概念，通过它的选择，可以在不同程度上压制丢失更新的发生。</li><li>Durability（持久性）：事务结束后，所有的数据会固化到一个地方，如保存到磁盘中，即使断电重启后也可以提供给应用程序访问。</li></ul><h3 id="数据库隔离级别有哪些，各自的含义是什么，MySQL默认的隔离级别是多少。"><a href="#数据库隔离级别有哪些，各自的含义是什么，MySQL默认的隔离级别是多少。" class="headerlink" title="数据库隔离级别有哪些，各自的含义是什么，MySQL默认的隔离级别是多少。"></a>数据库隔离级别有哪些，各自的含义是什么，MySQL默认的隔离级别是多少。</h3><p>隔离级别有四种。</p><ul><li>未提交读：是最低的隔离级别，其含义是允许一个事务读取另外一个事务没有提交的数据。会出现脏读。</li><li>读写提交：是指一个事务只能读取另一个事务已经提交的数据，不能读取未提交的数据。克服了脏读，但会出现不可重复读现象。</li><li>可重复读：克服读写提交中出现的不可重复读现象。但会出现幻读现象。</li><li>串行化：数据库中最高的隔离级别，她会要求所有的SQL都会按照顺序执行，这样就可以克服上述隔离级别出现的各种问题，所以它能完全保证数据的一致性。</li></ul><p>MySQL默认的隔离级别是可重复读。</p><h3 id="数据库的事务隔离-事务隔离级别"><a href="#数据库的事务隔离-事务隔离级别" class="headerlink" title="数据库的事务隔离/事务隔离级别"></a>数据库的事务隔离/事务隔离级别</h3><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。（从小到大）</p><p>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</p><p>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</p><p>REPEATABLE-READ：可重复读，mysql默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</p><p>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p><p>在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决是不彻底的。 通过next key lock解决了幻读的问题。</p><ul><li>Record lock：单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li></ul><ul><li>查询事务隔离级别</li></ul><pre><code>    select @@tx_isolation;</code></pre><ul><li>设置事务隔离级别(这里设置成未提交读)</li></ul><pre><code>    set session transaction isolation level read uncommitted;</code></pre><ul><li>开启事务</li></ul><pre><code>    start transaction;</code></pre><ul><li>事务回滚</li></ul><pre><code>    rollback;</code></pre><h4 id="事务引发的问题以及如何避免"><a href="#事务引发的问题以及如何避免" class="headerlink" title="事务引发的问题以及如何避免"></a>事务引发的问题以及如何避免</h4><p>更新丢失：mysql所有事务隔离级别在数据库层面上都可以避免</p><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。READ-COMMITTED事务隔离级别以上可以避免</p><p>不可重复读 ：是指在一个事务内，多次读同一数据数据发生了变化。REPEATABLE-READ事务隔离级别以上可以避免</p><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。SERIALIZABLE事务隔离级别以上可以避免</p><h4 id="幻读与不可重复读的区别"><a href="#幻读与不可重复读的区别" class="headerlink" title="幻读与不可重复读的区别"></a>幻读与不可重复读的区别</h4><ul><li>不可重复读的重点是修改:<br>同样的条件, 你读取过的数据, 再次读取出来发现值不一样了</li></ul><ul><li>幻读的重点在于新增或者删除<br>同样的条件, 第1次和第2次读出来的记录数不一样</li></ul><h3 id="什么是幻读。"><a href="#什么是幻读。" class="headerlink" title="什么是幻读。"></a>什么是幻读。</h3><p>幻读是指在同一个事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。</p><p>事务A读取与搜索条件相匹配的若干行，事务B以插入或删除行等方式来修改事务A的结果集，然后再提交，就会发生幻读。例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</p><p>在默认的事务隔离级别下，即REPEATABLE READ（可重复读）下，InnoDB存储引擎采用Next-Key Locking机制来避免幻读。</p><h3 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h3><ul><li>当前读：select…lock in share mode, select…for update</li><li>当前读：update,insert,delete</li><li>快照读：不加锁的非阻塞读，select</li></ul><ul><li>当前读：加锁的增删改查语句，无论什么锁，因为读取的是当前最新版本，还要保证并发事务不能修改当前记录，对读取记录加锁。</li><li>快照读：可能读取到的数据不是最新版本而是历史版本。</li><li>read committed级别下。当前读与快照读读取的版本一样。</li><li>repeatable read 级别下，当前读返回的是数据的最新版本，快照读返回的可能数据未修改前的版本也可能是最新的数据版本。因为在RR级别下，事务调用快照读的时机很重要，创建快照的时机决定了读取的版本。</li></ul><ul><li>先更新数据再查询数据</li></ul><p>例： update 数据 版本一 –》版本二</p><p>当前读 —。版本二</p><p>快照读—- 版本二</p><ul><li>快照读—-。版本一数据更新前先调用快照读查询数据后，再更新数据，快照度查询可能会导致数据未获取到最新版本。</li></ul><p>update 数据 版本一 –》版本二</p><p>当前读 —。版本二</p><p>快照读—- 版本一</p><h3 id="InnoDB在RR隔离级别下是如何实现幻读问题的解决的呢？"><a href="#InnoDB在RR隔离级别下是如何实现幻读问题的解决的呢？" class="headerlink" title="InnoDB在RR隔离级别下是如何实现幻读问题的解决的呢？"></a>InnoDB在RR隔离级别下是如何实现幻读问题的解决的呢？</h3><ul><li>表象：快照读（非阻塞读），伪MVCC</li><li>底层：next-key（行锁+Gap锁）<ul><li>a.    在RU、RC隔离级别下不存在Gap锁，所以在RU、RC隔离级别下无法解决幻读；在RR、Serializable隔离级别下都实现了Gap锁，所以解决了幻读现象。</li><li>b. 在RR隔离级别下，如果删、改、查语句的where条件走的是主键索引或者唯一索引<ul><li>i. where条件全部命中，则给该记录加上记录锁。</li><li>ii. where条件不全部命中，则给该记录周围加上Gap锁。</li><li>iii. 加上记录锁或者是Gap锁都是为了防止RR隔离级别下发生幻读现象。</li></ul></li><li>c. 在RR隔离级别下，如果删、改、查语句的where条件没有走索引或者是非唯一索引或非主键索引<br>在当前读where条件如果没有走非唯一索引或者没有走索引，则会使用Gap锁锁住当前记录的Gap，防止幻读的发生</li></ul></li></ul><h3 id="InnoDB中非阻塞读（快照读）底层是怎么实现的？"><a href="#InnoDB中非阻塞读（快照读）底层是怎么实现的？" class="headerlink" title="InnoDB中非阻塞读（快照读）底层是怎么实现的？"></a>InnoDB中非阻塞读（快照读）底层是怎么实现的？</h3><ul><li>记录中存储的隐藏列DB_TRX_ID、DB_ROW_ID、DB_ROLL_ID<ul><li>DB_TRX_ID：最后一次修改本行记录的事务ID</li><li>DB_ROLL_PTR：回滚指针，指向这条记录上的一个版本(存储于rollback segment中)</li><li>DB_ROW_ID：隐含的自增ID，如果数据表没有主键，InnoDB会自动DB_ROW_ID产生一个聚簇索引</li></ul></li><li>undo日志根据上述隐藏列来进行记录数据回滚（版本回滚）</li><li>review机制</li></ul><h3 id="数据库会死锁吗，举一个死锁的例子"><a href="#数据库会死锁吗，举一个死锁的例子" class="headerlink" title="数据库会死锁吗，举一个死锁的例子"></a>数据库会死锁吗，举一个死锁的例子</h3><ul><li>数据库会出现死锁，死锁是两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种相互等待的现象</li><li>举个例子，一个用户A访问表A（锁住了表A），然后访问表B；另一个用户B访问表B（锁住了表B），然后访问表A。这时用户A因为用户B已经锁住了表B，它必须等待用户B进行下一步释放表B，同时用户B需要等待用户A释放表A才能继续，死锁产生了</li></ul><h3 id="解决死锁的办法"><a href="#解决死锁的办法" class="headerlink" title="解决死锁的办法"></a>解决死锁的办法</h3><ul><li>解决死锁最简单的方法就是不要有等待，把所有等待都转换成回滚，并且事务重新开启，但是此方法可能会导致并发性能降低，甚至一个事务都开启不了，所以此方法不适用</li><li>解决死锁的另一个简单方法就是设置超时时间，两个事务在同时等待时，当某一个等待时间超过阈值，其中一个事务进行回滚，另一个事务就能继续进行</li><li>除了超时时间外，当前的数据库还都普遍采用wait-for graph（等待图），来进行死锁检测，这是一种更为主动的死锁检测方法，InnoDB存储引擎中也采用这种方式</li></ul><h2 id="关键语法"><a href="#关键语法" class="headerlink" title="关键语法"></a>关键语法</h2><ul><li>GROUP BY</li><li>HAVING</li><li>统计相关：COUNT,SUM,MAX,MIN,AVG</li></ul><h3 id="三张表"><a href="#三张表" class="headerlink" title="三张表"></a>三张表</h3><ul><li>student表：student_id,name,age,sex</li><li>score表：student_id,course_id,score</li><li>course表：course_id,name</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/46.png" alt=""></p><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><ul><li>满足SELECT子句中的列名必须为分组列或列函数</li><li>列函数对于group by子句定义的每个组各返回一个结果</li><li>GROUP BY我们可以先从字面上来理解，GROUP表示分组，BY后面写字段名，就表示根据哪个字段进行分组</li><li>GROUP BY必须得配合聚合函数来用，分组之后你可以计数（COUNT），求和（SUM），求平均数（AVG）等。</li></ul><h4 id="常见的聚合函数"><a href="#常见的聚合函数" class="headerlink" title="常见的聚合函数"></a>常见的聚合函数</h4><ul><li>count() 计数</li><li>sum() 求和</li><li>avg() 平均数</li><li>max() 最大值</li><li>min() 最小值</li></ul><h4 id="MySQL中Distinct与Group-by的区别。"><a href="#MySQL中Distinct与Group-by的区别。" class="headerlink" title="MySQL中Distinct与Group by的区别。"></a>MySQL中Distinct与Group by的区别。</h4><p>distinct简单来说就是用来去重的，而group by的设计目的则是用来聚合统计的，两者在能够实现的功能上有些相同之处。</p><p>单纯的去重操作使用distinct，速度是快于group by的。</p><h4 id="语法例子"><a href="#语法例子" class="headerlink" title="语法例子"></a>语法例子</h4><ul><li>查询所有同学的学号，选课数和总成绩</li></ul><pre><code>    select student_id,count(course_id),sum(score)    from score    group by student_id</code></pre><ul><li>查询所有同学的学号，姓名，选课数和总成绩</li></ul><pre><code>    select s.student_id,stu.name,count(s.course_id),sum(s.score)    from score s,student stu    where stu.student_id = s.student_id    group by student_id</code></pre><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><ul><li>通常与group by子句一起使用</li><li>where过滤行，having过滤组</li><li>出现在同一sql的顺序：where&gt;group by&gt;having</li></ul><h4 id="语法例子-1"><a href="#语法例子-1" class="headerlink" title="语法例子"></a>语法例子</h4><ul><li>查询平均成绩大于60分的同学的学号和平均成绩</li></ul><pre><code>    select student_id,avg(score)    from score    group by student_id    having avg(score) &gt; 60</code></pre><ul><li>查询学号为1的学生成绩情况</li></ul><pre><code>    #如果省略了group by，那么where的作用就和having是一样的    select * from score where stuent_id = 1    或者    select * from score having student_id = 1</code></pre><ul><li>查询没有学所有课的同学的学号和姓名</li></ul><pre><code>    select stu.student_id,stu.name    from score s,student stu    where s.student_id = stu.student_id    group by s.student_id    having count(*) &lt; {select count(*) form course}</code></pre><h3 id="where与having的区别"><a href="#where与having的区别" class="headerlink" title="where与having的区别"></a>where与having的区别</h3><ul><li>用的地方不一样</li></ul><p>where可以用于select、update、delete和insert into values(select * from table where ..)语句中。</p><p>having只能用于select语句中</p><ul><li>执行的顺序不一样</li></ul><p>where的搜索条件是在执行语句进行分组之前应用</p><p>having的搜索条件是在分组条件后执行的</p><p>即如果where和having一起用时，where会先执行，having后执行</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css样式积累</title>
      <link href="/2020/07/03/css-yang-shi-ji-lei/"/>
      <url>/2020/07/03/css-yang-shi-ji-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="css样式积累"><a href="#css样式积累" class="headerlink" title="css样式积累"></a>css样式积累</h2><ul><li>图标的样式设置一般用span标签</li></ul><pre><code>    /*        背景图标一般用backgroud,no-repeat为不平铺        background-size: contain；使其宽高完全填充至内容区域    */    background: url(&#39;/imgs/icon-cart-checked.png&#39;) no-repeat center;    background-size: contain;</code></pre><ul><li>鼠标移上去时切换图片，header-logo相当于相框，a标签相当于相册，存放两张图片切换（before和after）</li></ul><pre><code>    .header-logo{                        display: inline-block;                        width: 55px;                        height: 55px;                        background-color: #FF6600;                        a{                            display: inline-block;                            width: 110px;                            height: 55px;                            &amp;:before{                                content: &#39; &#39;;   //给图片留白,一定要留白占位置                                display: inline-block;                                width: 55px;                                height: 55px;                                background: url(&#39;/imgs/mi-logo.png&#39;) no-repeat center;                                background-size: contain;                                transition:margin .2s;                            }                            &amp;:after{                                content: &#39; &#39;;                                display: inline-block;                                width: 55px;                                height: 55px;                                background: url(&#39;/imgs/mi-home.png&#39;) no-repeat center;                                background-size: contain;                            }                            //鼠标移上去的时候切换图片，前面的图片向左移动55px                            &amp;:hover:before{                                margin-left: -55px;                                transition:margin .2s;  //过渡动画效果                            }                        }                    }</code></pre><ul><li>cursor: pointer;    //鼠标放上去就会出现一个小手（a标签自带这样的效果）</li><li>transition: all .5s;  //所有元素出现一个0.5s的动画效果</li></ul><h3 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h3><ul><li>scss的引入使css样式更加灵活，把需要重复使用的css样式放在scss文件中供我们调用</li><li>通过import的方式导入 ： @import “./../assets/scss/base.scss”;</li><li>既可以直接调用，又可以通过函数封装进行调用</li></ul><pre><code>    //定义    @mixin flex($fd:row,$hov:space-between,$col:center){        display: flex;        flex-direction: $fd;        align-items: $col;        justify-content: $hov;    }    //调用，可以传参，不传参就用默认值    @include flex();</code></pre><h3 id="隐藏和显示"><a href="#隐藏和显示" class="headerlink" title="隐藏和显示"></a>隐藏和显示</h3><ul><li>如何制造一个鼠标移上去就显示，不移上去就隐藏的效果,先设置高度为0，透明度为0，鼠标移上去的时候显示高度和透明度</li></ul><pre><code>    &amp;:hover {                color: $colorA;                .children {                  height: 220px;                  opacity: 1;                }              }              .children {                position: absolute;                top: 112px;                left: 0px;                width: 1226px;                border-top: 1px solid #e5e5e5;                box-shadow: 0px 7px 6px 0px rgba(0, 0, 0, 0.11);                z-index: 10;                height: 0;                opacity: 0;         //透明度为0                overflow: hidden;   //内容会被修剪，并且其余内容是不可见的。                transition: all .5s;                .product {                  float: left;                  height: 220px;                  width: 16.6%;                  font-size: 12px;                  line-height: 12px;                  text-align: center;                  position: relative;                  a {                    display: inline-block;                  }                  img {                    width: auto;                    height: 111px;                    margin-top: 26px;                  }                  .product-img {                    height: 137px;                  }                  .product-name {                    font-weight: bold; //字体加粗                    margin-top: 19px;                    margin-bottom: 8px;                    color: $colorB;                  }                  .product-price {                    color: $colorA;                  }                  &amp;:before{                      content: &#39; &#39;;                      position: absolute;                      top: 28px;                      right: 0px;                      border-right: 1px solid $colorF;                      height: 100px;                      width: 1px;                  }                  &amp;:last-child::before{                      display: none;    //最后一个before元素不显示                  }                }              }</code></pre><ul><li>还可以用block和none来显示和隐藏 block为显示 none为不显示</li></ul><pre><code>    //本来显示为隐藏，鼠标移上去的时候显示    display: none;    &amp;:hover {                background-color: $colorA;                .children {                  display: block ;                }              }</code></pre><h3 id="如何用循环显示多行多列（用多维数组）"><a href="#如何用循环显示多行多列（用多维数组）" class="headerlink" title="如何用循环显示多行多列（用多维数组）"></a>如何用循环显示多行多列（用多维数组）</h3><h4 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h4><ul><li>用ul和li标签（这些标签都有自动换行的功能）</li><li>骨架</li></ul><pre><code>    &lt;div class=&quot;children&quot;&gt;                    &lt;ul class=&quot;products&quot; v-for=&quot;(item,i) in menuList&quot; :key=&quot;i&quot;&gt;                      &lt;li class=&quot;product&quot; v-for=&quot;(sub,j) in item&quot; :key=&quot;j&quot;&gt;                        &lt;a :href=&quot;sub?&#39;/#/product/&#39;+sub.id:&#39;&#39;&quot;&gt;                          &lt;img :src=&quot;sub?sub.image:&#39;/imgs/item-box-1.png&#39;&quot; alt /&gt;                          {{sub?sub.name:'小米CC9'}}                        &lt;/a&gt;                      &lt;/li&gt;                    &lt;/ul&gt;                  &lt;/div&gt;</code></pre><ul><li>设置一个多维数组</li></ul><pre><code>    menuList: [            [              {                id: 30,                image: &quot;/imgs/item-box-1.png&quot;,                name: &quot;小米CC9&quot;              },              {                id: 31,                image: &quot;/imgs/item-box-2.png&quot;,                name: &quot;小米8青春版&quot;              },              {                id: 32,                image: &quot;/imgs/item-box-3.jpg&quot;,                name: &quot;Redmi K20 Pro&quot;              },              {                id: 33,                image: &quot;/imgs/item-box-4.jpg&quot;,                name: &quot;移动4G专区&quot;              }            ],            [0, 0, 0, 0],            [0, 0, 0, 0],            [0, 0, 0, 0],            [0, 0, 0, 0],            [0, 0, 0, 0]          ]</code></pre><ul><li>样式（注意使用flex布局，flex=1为平均分布）</li></ul><pre><code>    .children {                display: none;                width: 962px;                position: absolute;                top: -26px;                left: 264px;                background-color: $colorG;                border: 1px solid $colorH;                ul {                  display: flex;                  flex-direction: row;                  justify-content: space-between;                  height: 75px;                  li {                    height: 75px;                    line-height: 75px;                    flex: 1; //平均分布                    padding-left: 23px;                  }                  img {                    width: 42px;                    height: 35px;                    vertical-align: middle; //图片和文字居中                    margin-right: 15px;                  }                  a {                    display: inline-block;                    color: #333333;                    font-size: 14px;                  }                }              }</code></pre><h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><ul><li>用div标签，有自动换行的功能</li><li>骨架</li></ul><pre><code>    &lt;div class=&quot;list-box&quot;&gt;                &lt;div class=&quot;list&quot; v-for=&quot;(arr,i) in phoneList&quot; :key=&quot;i&quot;&gt;                  &lt;div class=&quot;item&quot; v-for=&quot;(item,j) in arr&quot; :key=&quot;j&quot;&gt;                    &lt;span :class=&quot;{&#39;new-pro&#39;:j%2==0}&quot;&gt;新品&lt;/span&gt;                    &lt;div class=&quot;item-img&quot;&gt;                      &lt;img :src=&quot;item.mainImage&quot; /&gt;                    &lt;/div&gt;                    &lt;h3&gt;{{item.name}}&lt;/h3&gt;                    &lt;div class=&quot;item-info&quot;&gt;                      &lt;p&gt;{{item.subtitle}}&lt;/p&gt;                    &lt;/div&gt;                    &lt;div class=&quot;item-price&quot;&gt;                      &lt;p @click=&quot;addCart(item.id)&quot;&gt;{{item.price}}元&lt;/p&gt;                    &lt;/div&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;</code></pre><ul><li>css样式</li></ul><pre><code>    list-box {            .list {              @include flex();              width: 986px;              margin-bottom: 14px;              &amp;:last-child {                margin-bottom: 0;              }              .item {                height: 302px;                width: 236px;                background-color: #ffffff;                text-align: center;                span {                  display: inline-block;                  width: 67px;                  height: 24px;                  line-height: 24px;                  color: #ffffff;                  //设置不同情况不同样式                  &amp;.new-pro {                    background-color: #7ecf68;                  }                  &amp;.kill-pro {                    background-color: #e82626;                  }                }                .item-img {                  img {                    width: 100%;                    height: 195px;                    display: inline-block;                  }                }                .item-info {                  color: #999999;                  margin-bottom: 10px;                  margin-top: 6px;                }                .item-price {                  cursor: pointer;                  height: 30px;                  p {                    display: inline-block;                    color: #f20a0a;                    font-size: 14px;                    font-weight: bold;                    &amp;:after {                      @include bgImg(20px, 30px, &quot;/imgs/icon-cart-hover.png&quot;);                      margin-left: 5px;                      vertical-align: middle;                      content: &quot;&quot;;                    }                  }                }              }            }          }</code></pre><h3 id="如何作一个弹框动画css样式难点"><a href="#如何作一个弹框动画css样式难点" class="headerlink" title="如何作一个弹框动画css样式难点"></a>如何作一个弹框动画css样式难点</h3><ul><li>如何是弹框一直居中，注意position和transform要搭配使用</li></ul><pre><code>    position: fixed;    //fixed固定定位，相对于浏览器    top: 40%;    left: 50%;    width: 660px;    height: auto;    transform: translate(-50%,-50%);    //往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置</code></pre><ul><li>absolute和fixed的区别<ul><li>fixed:固定定位</li><li>absolute:绝对定位</li><li>1、没有滚动条的情况下没有差异</li><li>2、在有滚动条的情况下，fixed定位不会随滚动条移动而移动，而absolute则会随滚动条移动</li></ul></li><li>放大效果 transform: scale(1.5);  //放大1.5倍</li></ul><h3 id="视频播放时需要注意的css样式"><a href="#视频播放时需要注意的css样式" class="headerlink" title="视频播放时需要注意的css样式"></a>视频播放时需要注意的css样式</h3><ul><li>object-fit: cover; //保持原有尺寸比例。宽度和高度中短的那条边跟容器大小一致，长的那条等比缩放。可能会有部分区域不可见。</li><li>outline: none; //元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用,这里的作用是去掉这条线</li></ul><h4 id="如何实现吸顶功能"><a href="#如何实现吸顶功能" class="headerlink" title="如何实现吸顶功能"></a>如何实现吸顶功能</h4><ul><li>首先我们要知道当前滚动条的高度，当滚动条的高度高于要实现吸顶功能的模块时吸顶，不然不变</li></ul><pre><code>    methods: {        initHeight() {          //获取当前滚动条所处的高度          let scrollTop =            window.pageXOffset ||            document.documentElement.scrollTop ||            document.body.scrollTop;          this.isFixed = scrollTop &gt; 151 ? true : false;        }      },</code></pre><ul><li>监听滚动条的事件</li></ul><pre><code>    mounted() {        //一个监听滚动条的事件        window.addEventListener(&quot;scroll&quot;, this.initHeight);      },</code></pre><ul><li>当退出这个页面时摧毁方法</li></ul><pre><code>    destroyed() {        window.removeEventListener(&quot;scroll&quot;, this.initHeight, false);      }</code></pre><ul><li>设置一个样式，滚动条滑动到模块以下时显示</li></ul><pre><code>    :class=&quot;{&#39;is-fixed&#39;:isFixed}&quot;    &amp;.is-fixed {    position: fixed;    top: 0;    width: 100%;    box-shadow: 0px 5px 5px $colorE; //阴影x轴横向为0，y轴竖向为5px，宽度为5px    }</code></pre><h3 id="添加浮动通用浮动样式"><a href="#添加浮动通用浮动样式" class="headerlink" title="添加浮动通用浮动样式"></a>添加浮动通用浮动样式</h3><ul><li>页面虽然可以使用flex弹性布局，但是有时候还是要用到float浮动样式，我们可以先设置定义好全局通用，要用的时候就拿来用就是了</li><li>记住使用浮动最后要记得清除浮动</li><li>clearfix 是在父组件上设置 </li></ul><pre><code>    .fl {        float: left;    }    .fr {        float: right;    }    .clearfix:before,    .clearfix:after {        content: &#39; &#39;;        display: table;    }    .clearfix:after {        clear: both;    }</code></pre><ul><li>使用</li></ul><pre><code>    &lt;div class=&quot;item-version clearfix&quot;&gt;        &lt;h2&gt;选择版本&lt;/h2&gt;        &lt;div class=&quot;phone fl&quot; :class=&quot;{&#39;checked&#39;:version==1}&quot; @click=&quot;version=1&quot;&gt;6GB+64GB 全网通&lt;/div&gt;        &lt;div class=&quot;phone fr&quot; :class=&quot;{&#39;checked&#39;:version==2}&quot; @click=&quot;version=2&quot;&gt;4GB+64GB 移动4G&lt;/div&gt;      &lt;/div&gt;</code></pre><h3 id="点击选择切换框"><a href="#点击选择切换框" class="headerlink" title="点击选择切换框"></a>点击选择切换框</h3><ul><li>在挑选货物的时候会有很多个样式供我们选则，我们可以点击切换，选择不同的版本，version默认为1，:class=”{‘checked’:version==1}”的意思就是version为1的时候才会显示这个样式</li></ul><pre><code>    &lt;div class=&quot;item-version clearfix&quot;&gt;        &lt;h2&gt;选择版本&lt;/h2&gt;        &lt;div class=&quot;phone fl&quot; :class=&quot;{&#39;checked&#39;:version==1}&quot; @click=&quot;version=1&quot;&gt;6GB+64GB 全网通&lt;/div&gt;        &lt;div class=&quot;phone fr&quot; :class=&quot;{&#39;checked&#39;:version==2}&quot; @click=&quot;version=2&quot;&gt;4GB+64GB 移动4G&lt;/div&gt;      &lt;/div&gt;</code></pre><h3 id="划线"><a href="#划线" class="headerlink" title="划线"></a>划线</h3><ul><li>如何把一行字添加删除划线</li></ul><pre><code>    text-decoration: line-through; //加一条线，划掉</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css动画效果和优化</title>
      <link href="/2020/07/03/css-dong-hua-xiao-guo-he-you-hua/"/>
      <url>/2020/07/03/css-dong-hua-xiao-guo-he-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本片笔记主要讲述了swiper轮播，图片懒加载，组件吸顶，弹框效果（包括遮罩层），animation实现动画效果，svg的使用</li></ul><h3 id="swiper"><a href="#swiper" class="headerlink" title="swiper"></a>swiper</h3><ul><li>如何实现轮播效果，swiper已经帮我们解决了，我们只需要下载vue-awesome-swiper插件</li><li>我们只暂时只需要用到里面的两个组件，直接导入就好了，还有其中的css样式也需要导入</li></ul><pre><code>    import { Swiper, SwiperSlide } from &quot;vue-awesome-swiper&quot;;    import &quot;swiper/css/swiper.css&quot;;</code></pre><h4 id="html骨架"><a href="#html骨架" class="headerlink" title="html骨架"></a>html骨架</h4><ul><li>箭头和分页器</li></ul><pre><code>    &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;swiper-button-prev&quot; slot=&quot;button-prev&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;swiper-button-next&quot; slot=&quot;button-next&quot;&gt;&lt;/div&gt;</code></pre><ul><li>应用</li></ul><pre><code>    &lt;swiper :options=&quot;swiperOptions&quot;&gt;              &lt;swiper-slide v-for=&quot;(item,index) in swiperList&quot; :key=&quot;index&quot;&gt;                &lt;a :href=&quot;&#39;/#/product/&#39; + item.id&quot;&gt;                  &lt;img :src=&quot;item.image&quot; alt /&gt;                &lt;/a&gt;              &lt;/swiper-slide&gt;              &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt;              &lt;div class=&quot;swiper-button-prev&quot; slot=&quot;button-prev&quot;&gt;&lt;/div&gt;              &lt;!--左箭头。如果放置在swiper-container外面，需要自定义样式。--&gt;              &lt;div class=&quot;swiper-button-next&quot; slot=&quot;button-next&quot;&gt;&lt;/div&gt;              &lt;!--右箭头。如果放置在swiper-container外面，需要自定义样式。--&gt;            &lt;/swiper&gt;</code></pre><h4 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h4><ul><li>想实现更多样式还得看中文文档</li></ul><pre><code>    swiperOptions: {            //环绕            loop: true,            //自动切换            autoplay: true,            //方块旋转            effect: &quot;cube&quot;,            cubeEffect: {              slideShadows: true,              shadow: true,              shadowOffset: 100,              shadowScale: 0.6            },            //分页器            pagination: {              el: &quot;.swiper-pagination&quot;,              clickable: true //点击原点可切换            },            //箭头实现切换效果            navigation: {              nextEl: &quot;.swiper-button-next&quot;,              prevEl: &quot;.swiper-button-prev&quot;            }          },</code></pre><h3 id="modal组件"><a href="#modal组件" class="headerlink" title="modal组件"></a>modal组件</h3><ul><li>实现页面弹框效果，这个东西在很多地方都能够复用所以把他设置成一个动态的组件</li><li>因为很多地方都要用这个组件，而且显示的都不一样，所以这些数据都要靠外部先设置，这里就要引入一个新的属性props相当于小程序的properties</li><li>还有把事件抛出，让外部来处理</li></ul><pre><code>    //组件自定义事件    @click=&quot;$emit(&#39;submit&#39;)&quot;    //外部处理事件    @cancel=&quot;showModal=false&quot;</code></pre><ul><li>插槽的使用</li></ul><pre><code>    //设置插槽    &lt;div class=&quot;modal-body&quot;&gt;       &lt;slot name=&quot;body&quot;&gt;标题&lt;/slot&gt;        &lt;/div&gt;    //使用插槽，需要用template包装起来    &lt;template v-slot:body&gt;            &lt;p&gt;商品添加成功！&lt;/p&gt;          &lt;/template&gt;</code></pre><h4 id="如何做出动画效果"><a href="#如何做出动画效果" class="headerlink" title="如何做出动画效果"></a>如何做出动画效果</h4><ul><li>需要在组件的最外层包裹一层，详情去vue的官网</li></ul><pre><code>    //name在写样式的时候有用    &lt;transition name=&quot;slide&quot;&gt;    &lt;/transition&gt;    //然后在样式中加入,注意顺序不能乱    &amp;.slide-enter-active{    top: 0;    }    &amp;.slide-leave-active{        top: -100%;    }    &amp;.slide-enter{        top: -100%;    }    &amp;.slide-leave-to{        top: 0;    }</code></pre><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><ul><li>当一个页面数据太多的时候，会给服务器造成很大的压力，有时候一下加载不出来，我们需要帮服务器减轻这些压力，只有在当前页面显示的先加载，其他的后加载，这时我们需要用到一个插件vue-lazyload,具体的使用方法可以去官网，这里只是用了插件的loading功能</li><li>main.js中use这个插件</li></ul><pre><code>    Vue.use(VueLazyload,{      loading: &#39;/imgs/loading-svg/loading-bars.svg&#39;     //懒加载loading动画    })</code></pre><ul><li>然后使用这个插件，把里面图片:src全换成v-lazy，注意如果是直接是图片路径的话要加单引号</li></ul><pre><code>    :src=&quot;/imgs/mix-alpha.jpg&quot;    v-lazy=&quot;&#39;/imgs/mix-alpha.jpg&#39;&quot;</code></pre><h3 id="商品详情页"><a href="#商品详情页" class="headerlink" title="商品详情页"></a>商品详情页</h3><h4 id="如何实现吸顶功能"><a href="#如何实现吸顶功能" class="headerlink" title="如何实现吸顶功能"></a>如何实现吸顶功能</h4><ul><li>首先我们要知道当前滚动条的高度，当滚动条的高度高于要实现吸顶功能的模块时吸顶，不然不变</li></ul><pre><code>    methods: {        initHeight() {          //获取当前滚动条所处的高度          let scrollTop =            window.pageXOffset ||            document.documentElement.scrollTop ||            document.body.scrollTop;          this.isFixed = scrollTop &gt; 151 ? true : false;        }      },</code></pre><ul><li>监听滚动条的事件</li></ul><pre><code>    mounted() {        //一个监听滚动条的事件        window.addEventListener(&quot;scroll&quot;, this.initHeight);      },</code></pre><ul><li>当退出这个页面时摧毁方法</li></ul><pre><code>    destroyed() {        window.removeEventListener(&quot;scroll&quot;, this.initHeight, false);      }</code></pre><ul><li>设置一个样式，滚动条滑动到模块以下时显示</li></ul><pre><code>    :class=&quot;{&#39;is-fixed&#39;:isFixed}&quot;    &amp;.is-fixed {    position: fixed;    top: 0;    width: 100%;    box-shadow: 0px 5px 5px $colorE; //阴影x轴横向为0，y轴竖向为5px，宽度为5px    }</code></pre><h3 id="视频模块"><a href="#视频模块" class="headerlink" title="视频模块"></a>视频模块</h3><ul><li>先展示视频，aotuplay是自动播放，muted是静音，两者要结合一起使用，不然可能不会自动播放，controls是显示播放控制的一些按钮</li></ul><pre><code>    &lt;video src=&quot;/imgs/product/video.mp4&quot; autoplay muted controls=&quot;controls&quot;&gt;&lt;/video&gt;</code></pre><h4 id="transition实现动画效果"><a href="#transition实现动画效果" class="headerlink" title="transition实现动画效果"></a>transition实现动画效果</h4><ul><li>我们点击视频观看和关闭时都要实现一个动画效果，还要实现一个遮罩效果，overlay就是遮罩效果</li></ul><pre><code>    &lt;div class=&quot;video-box&quot;&gt;      &lt;div class=&quot;overlay&quot; v-if=&quot;showVideo&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;video&quot; :class=&quot;{&#39;slide&#39;:showVideo}&quot;&gt;        &lt;span class=&quot;icon-close&quot; @click=&quot;offvideo&quot;&gt;&lt;/span&gt;        &lt;video src=&quot;/imgs/product/video.mp4&quot; autoplay muted controls=&quot;controls&quot;&gt;&lt;/video&gt;      &lt;/div&gt;    &lt;/div&gt;</code></pre><ul><li>用css样式来实现这个效果</li><li>遮罩层</li></ul><pre><code>    .overlay {            @include position(fixed);            background-color: $colorI;            opacity: 0.5;            z-index: 10;          }</code></pre><ul><li>video，先把它隐藏起来top:-50%，点击展示的时候top:50%，这样就实现了一个动画效果</li></ul><pre><code>    .video {            position: fixed;            top: -50%;            left: 50%;            width: 1000px;            height: 536px;            transform: translate(-50%, -50%);            z-index: 10;            transition: all 0.5s;            &amp;.slide {              top: 50%;            }            video {              width: 100%;              height: 100%;              object-fit: cover; //保持原有尺寸比例。宽度和高度中短的那条边跟容器大小一致，长的那条等比缩放。可能会有部分区域不可见。              outline: none; //元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用,这里的作用是去掉这条线            }            }</code></pre><h4 id="animation实现动画效果"><a href="#animation实现动画效果" class="headerlink" title="animation实现动画效果"></a>animation实现动画效果</h4><ul><li>设置动画名称，在video-box中</li></ul><pre><code>    @keyframes slideDown{        from{          top:-50%;          opacity:0;        }        to{          top:50%;          opacity:1;        }      }      @keyframes slideUp{        from{          top:50%;          opacity:1;        }        to{          top:-50%;          opacity:0;        }      }</code></pre><ul><li>在video中实现</li></ul><pre><code>    &amp;.slideDown{          animation:slideDown .6s linear;          top:50%;        }        &amp;.slideUp{          animation:slideUp .6s linear;        }</code></pre><ul><li>还要在html文件中设置class，不同的情况，切换不同的样式</li></ul><pre><code>    &lt;div class=&quot;video-bg&quot; @click=&quot;showSlide=&#39;slideDown&#39;&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;video-box&quot; v-show=&quot;showSlide&quot;&gt;              &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;              &lt;div class=&quot;video&quot; v-bind:class=&quot;showSlide&quot;&gt;                &lt;span class=&quot;icon-close&quot; @click=&quot;closeVideo&quot;&gt;&lt;/span&gt;                &lt;video src=&quot;/imgs/product/video.mp4&quot; muted autoplay controls=&quot;controls&quot;&gt;&lt;/video&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;</code></pre><h3 id="商品页轮播图效果"><a href="#商品页轮播图效果" class="headerlink" title="商品页轮播图效果"></a>商品页轮播图效果</h3><ul><li>跟上次做的不太一样，这次多加了一些功能</li><li>初始化</li></ul><pre><code>    &lt;swiper :options=&quot;swiperOptions&quot;&gt;              &lt;swiper-slide v-for=&quot;(item,index) in swiperList&quot; :key=&quot;index&quot;&gt;                &lt;img :src=&quot;item&quot; alt /&gt;              &lt;/swiper-slide&gt;              &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt;            &lt;/swiper&gt;</code></pre><ul><li>记住swiperOptions一定要放在data里面</li></ul><pre><code>    swiperOptions: {            autoplay: true,            slidesPerView: 3, //设置slider容器能够同时显示的slides数量            spaceBetween: 30, //在slide之间设置距离            freeMode: true, //默认为false，普通模式：slide滑动时只滑动一格，并自动贴合wrapper，设置为true则变为free模式，slide会根据惯性滑动可能不止一格且不会贴合            //分页器            pagination: {              el: &quot;.swiper-pagination&quot;,              clickable: true //点击原点可切换            }          },</code></pre><ul><li>css样式就很简单了</li></ul><pre><code>    .item-swiper {          margin: 36px auto 56px;          img {            width: 100%;  //撑满swiper-slide容器          }          }</code></pre><h3 id="svg的使用"><a href="#svg的使用" class="headerlink" title="svg的使用"></a>svg的使用</h3><h4 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h4><ul><li>放在整个大容器里面，这里的svg包含三种图片，添加，编辑和删除</li></ul><pre><code>    &lt;svg          version=&quot;1.1&quot;          xmlns=&quot;http://www.w3.org/2000/svg&quot;          xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;          style=&quot;position: absolute; width: 0px; height: 0px; overflow: hidden;&quot;        &gt;          &lt;defs&gt;            &lt;symbol id=&quot;icon-add&quot; viewBox=&quot;0 0 31 32&quot;&gt;              &lt;title&gt;add&lt;/title&gt;              &lt;path                d=&quot;M30.745 15.152h-14.382v-14.596c0-0.308-0.243-0.557-0.543-0.557s-0.543 0.249-0.543 0.557v14.596h-14.665c-0.3 0-0.543 0.249-0.543 0.557s0.243 0.557 0.543 0.557h14.665v15.177c0 0.307 0.243 0.557 0.543 0.557s0.543-0.249 0.543-0.557v-15.177h14.382c0.3 0 0.543-0.249 0.543-0.557s-0.243-0.557-0.543-0.557z&quot;                class=&quot;path1&quot;              /&gt;            &lt;/symbol&gt;            &lt;symbol id=&quot;icon-edit&quot; viewBox=&quot;0 0 32 32&quot;&gt;              &lt;title&gt;edit&lt;/title&gt;              &lt;path                d=&quot;M28.287 8.51l-4.805-4.806 0.831-0.831c0.472-0.472 1.086-0.777 1.564-0.777 0.248 0 0.452 0.082 0.622 0.253l3.143 3.144c0.539 0.54 0.133 1.529-0.524 2.186l-0.831 0.831zM26.805 9.992l-1.138 1.138-4.805-4.806 1.138-1.138 4.805 4.806zM24.186 12.612l-14.758 14.762-4.805-4.806 14.758-14.762 4.805 4.806zM7.379 28.288l-4.892 1.224 1.223-4.894 3.669 3.67zM31.123 4.011l-3.143-3.144c-0.567-0.567-1.294-0.867-2.103-0.867-1.036 0-2.174 0.52-3.045 1.391l-20.429 20.436c-0.135 0.134-0.23 0.302-0.276 0.487l-2.095 8.385c-0.089 0.355 0.017 0.736 0.276 0.995 0.198 0.198 0.461 0.307 0.741 0.307 0.085 0 0.171-0.010 0.254-0.031l8.381-2.096c0.185-0.047 0.354-0.142 0.487-0.276l20.43-20.436c1.409-1.41 2.042-3.632 0.524-5.15v0z&quot;                class=&quot;path1&quot;              /&gt;            &lt;/symbol&gt;            &lt;symbol id=&quot;icon-del&quot; viewBox=&quot;0 0 32 32&quot;&gt;              &lt;title&gt;delete&lt;/title&gt;              &lt;path                d=&quot;M11.355 4.129v-2.065h9.29v2.065h-9.29zM6.194 29.935v-23.742h19.613v23.742h-19.613zM30.968 4.129h-8.258v-3.097c0-0.569-0.463-1.032-1.032-1.032h-11.355c-0.569 0-1.032 0.463-1.032 1.032v3.097h-8.258c-0.569 0-1.032 0.463-1.032 1.032s0.463 1.032 1.032 1.032h3.097v24.774c0 0.569 0.463 1.032 1.032 1.032h21.677c0.569 0 1.032-0.463 1.032-1.032v-24.774h3.097c0.569 0 1.032-0.463 1.032-1.032s-0.463-1.032-1.032-1.032v0z&quot;                class=&quot;path1&quot;              /&gt;              &lt;path                d=&quot;M10.323 9.806c-0.569 0-1.032 0.463-1.032 1.032v14.452c0 0.569 0.463 1.032 1.032 1.032s1.032-0.463 1.032-1.032v-14.452c0-0.569-0.463-1.032-1.032-1.032z&quot;                class=&quot;path2&quot;              /&gt;              &lt;path                d=&quot;M16 9.806c-0.569 0-1.032 0.463-1.032 1.032v14.452c0 0.569 0.463 1.032 1.032 1.032s1.032-0.463 1.032-1.032v-14.452c0-0.569-0.463-1.032-1.032-1.032z&quot;                class=&quot;path3&quot;              /&gt;              &lt;path                d=&quot;M21.677 9.806c-0.569 0-1.032 0.463-1.032 1.032v14.452c0 0.569 0.463 1.032 1.032 1.032s1.032-0.463 1.032-1.032v-14.452c0-0.569-0.463-1.032-1.032-1.032z&quot;                class=&quot;path4&quot;              /&gt;            &lt;/symbol&gt;          &lt;/defs&gt;        &lt;/svg&gt;</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>这里把它包含在一个a标签里，实际上可以防御任何标签，相当于一张图片，当然也可以调整样式</li></ul><pre><code>    &lt;a href=&quot;javascript:;&quot; class=&quot;fr&quot; @click=&quot;editAddr(item)&quot;&gt;        &lt;svg class=&quot;icon&quot;&gt;            &lt;use xlink:href=&quot;#icon-edit&quot; /&gt;        &lt;/svg&gt;    &lt;/a&gt;</code></pre><ul><li>样式</li></ul><pre><code>    fill: $colorA; //XML-SVG专属样式，把颜色填充进去</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/06/29/mian-shi-ji-suan-ji-wang-luo-zhi-shi/"/>
      <url>/2020/06/29/mian-shi-ji-suan-ji-wang-luo-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>此文章用来记录面试中计算机网络的一些核心问题</li></ul><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><ul><li>第一次：客户端向服务端发送SYN包(SYN=1，seq=j),此时进入SYN_SEND状态，等待服务器确认</li><li>第二次：服务端收到SYN包后，必须确认(ACK=1,ack=j+1),然后同时发送一个SYN包(SYN=1,seq=k)，发送完毕后等待客户端确认，进入SYN_RCVD状态</li><li>第三次：客户端收到服务端发送的SYN包和ACK包，进行确认，向服务端发送ACK包(ACK=1,ack=k+1),发送完毕后客户端进入ESTABLISHED 状态，当服务端接收到这个包时，服务端也进入ESTABLISHED 状态，完成三次握手，即可以进行数据传输</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/40.png" alt=""></p><h4 id="为什么-TCP-连接需要三次握手，两次不可以么，为什么？"><a href="#为什么-TCP-连接需要三次握手，两次不可以么，为什么？" class="headerlink" title="为什么 TCP 连接需要三次握手，两次不可以么，为什么？"></a>为什么 TCP 连接需要三次握手，两次不可以么，为什么？</h4><p>为了防止服务器开启一些无用的连接增加服务器开销以及以及防止已经失效的连接请求报文段又传送到了服务端，因而产生错误</p><ul><li>为了防止服务器开启一些无用的请求连接增加服务器开销<ul><li>如果没有第三次握手，服务端直接创建这个连接并且返回SYN,ACK,Seq等数据包给客户端，这些数据包因为网络传输原因丢失了，丢失之后客户端就一直没有收到来自服务端返回的数据包</li><li>服务器端是不知道客户端有没有接收到服务器端返回的信息的，这样没有给服务器端一个创建还是关闭连接端口的请求，服务器端的端口就一直开着，</li><li>客户端可能设置了一个超时时间，当超过了这个时间就会重新发送连接请求，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。那么服务器端上没有接收到请求数据的上一个端口就一直开着，长此以往，这样的端口多了，就会造成服务器端开销的严重浪费</li></ul></li><li>为了防止已经失效的请求报文段突然又传送到了服务端造成错误<ul><li>客户端发送的连接请求报文段并未丢失，而是因为某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间点才到达服务端</li><li>如果没有三次握手，服务端直接确认连接，由于此时客户端并没有发送建立连接的请求，所以不理会服务端，也不与它通信。而此时服务端还在一直等待客户端的请求，就白白浪费了一定的资源</li></ul></li></ul><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p>主要流程为：</p><ul><li>第一次挥手(FIN=1，seq=a)，发送完毕后，客户端进入 FIN_WAIT_1 状态。</li><li>第二次挥手(ACK=1，ACKnum=a+1)，发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态。</li><li>第三次挥手(FIN=1，seq=b)，发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</li><li>第四次挥手(ACK=1，ACKnum=b+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 FIN ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/41.png" alt=""></p><ul><li>为什么需要四次挥手：因为TCP连接是全双工的网络协议，允许同时通信的双方同时进行数据的收发，同样也允许收发两个方向的连接被独立关闭，以避免client数据发送完毕，向server发送FIN关闭连接，而server还有发送到client的数据没有发送完毕的情况。所以关闭TCP连接需要进行四次握手，每次关闭一个方向上的连接需要FIN和ACK两次握手。</li></ul><ul><li>握手过程如果只有两次，可能会出现已失效的连接请求报文突然又传送到了服务端，因而产生错误。</li></ul><ul><li>在三次握手过程中，为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。</li></ul><h4 id="TIME-WAIT和CLOSE-WAIT的区别。"><a href="#TIME-WAIT和CLOSE-WAIT的区别。" class="headerlink" title="TIME_WAIT和CLOSE_WAIT的区别。"></a>TIME_WAIT和CLOSE_WAIT的区别。</h4><p>TIME_WAIT表示主动关闭，CLOSE_WAIT表示被动关闭。</p><p>TCP协议规定，对于已经建立的连接，网络双方要进行四次挥手才能断开连接，如果缺少了其中某个步骤，将会使连接处于假死状态，连接本身占用的资源不会被释放。网络服务器程序要同时管理大量连接，所以很有必要保证无用连接完全断开，否则大量僵死的连接会浪费许多服务器资源。在众多TCP状态中，最值得注意的状态有两个：CLOSE_WAIT和TIME_WAIT。</p><ul><li>TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。一方面是为了把原来的连接里面的重复数据包都已经在网络中消逝。避免老的连接的数据影响新建立的连接（新老连接的IP和端口号相同，新的被称为老的连接到化身）。 另一方面， 假如客户端回复的ACK丢失，服务端会重发FIN，客户端此时还能接收到FIN，还能再回复一个ACK（此时time_wait会重新计时）（MSL是指一个包的最大存活时间，一般是两分钟。）</li><li>另一种对于TIME_WAIT的解释：如果没有TIME_WEIT这个等待，释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的 TCP 报文可能与新 TCP 连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的 TCP 连接的活跃报文全部死翘翘，2MSL 时间可以满足这个需求（尽管非常保守）！</li><li>CLOSE_WAIT是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。</li></ul><h3 id="为什么“握手”是三次，“挥手”却要四次？"><a href="#为什么“握手”是三次，“挥手”却要四次？" class="headerlink" title="为什么“握手”是三次，“挥手”却要四次？"></a>为什么“握手”是三次，“挥手”却要四次？</h3><p>TCP建立连接时之所以只需要”三次握手”，是因为在第二次”握手”过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。</p><p>即SYN建立连接报文与ACK确认接收报文是在同一次”握手”当中传输的，所以”三次握手”不多也不少，正好让双方明确彼此信息互通。</p><p>TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。为何建立连接时一起传输，释放连接时却要分开传输？</p><ul><li>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。</li><li>释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。</li></ul><p>所以是“三次握手”，“四次挥手”。</p><h3 id="为什么客户端在TIME-WAIT阶段要等2MSL"><a href="#为什么客户端在TIME-WAIT阶段要等2MSL" class="headerlink" title="为什么客户端在TIME-WAIT阶段要等2MSL?"></a>为什么客户端在TIME-WAIT阶段要等2MSL?</h3><p>为的是确认服务器端是否收到客户端发出的ACK确认报文</p><p>当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。</p><ul><li>服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；</li></ul><ul><li><p>如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；</p></li><li><p>否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。</p></li><li><p>所以，客户端要经历时长为2MSL的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因</p></li></ul><h3 id="对于TCP连接，客户端不断进行请求链接会怎么样？"><a href="#对于TCP连接，客户端不断进行请求链接会怎么样？" class="headerlink" title="对于TCP连接，客户端不断进行请求链接会怎么样？"></a>对于TCP连接，客户端不断进行请求链接会怎么样？</h3><p>服务器端准备为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认后创建。如果此时客户端一直不确认，会造成 SYN 攻击，即：SYN 攻击，英文为 SYN Flood ，是一种典型的 DoS/DDoS 攻击。</p><ul><li>客户端向服务端发送请求连接数据包。</li><li>服务端向客户端发送确认数据包。</li><li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认。</li></ul><p>这时候服务器上有大量的半连接状态，特别是源IP地址是随机的，基本可以断定是一次SYN攻击。</p><p>对于SYN攻击，只能预防，没有彻底根治的办法，除非不使用 TCP 。方法主要如下：</p><ul><li>限制同时打开SYN半链接的数目。</li><li>缩短SYN半链接的超时时间。</li><li>关闭不必要的服务。</li><li>增加半链接数据。</li><li>过滤网关防护。</li></ul><h3 id="TCP和UDP的区别。"><a href="#TCP和UDP的区别。" class="headerlink" title="TCP和UDP的区别。"></a>TCP和UDP的区别。</h3><p>TCP和UDP都属于传输层协议，它们之间的区别在于：</p><ul><li>TCP 是面向连接的；UDP 是无连接的。</li><li>TCP 是可靠的；UDP 是不可靠的。</li><li>TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多的通信模式。</li><li>TCP 是面向字节流的；UDP 是面向报文的。</li><li>TCP 有拥塞控制机制；UDP 没有拥塞控制，适合媒体通信。</li><li>TCP 首部开销(20 个字节)，比 UDP 的首部开销(8 个字节)要大。</li></ul><h3 id="TCP中RST标志位的作用。"><a href="#TCP中RST标志位的作用。" class="headerlink" title="TCP中RST标志位的作用。"></a>TCP中RST标志位的作用。</h3><p>TCP报文中一共有6个标志位，分别为：URG/ACK/PSH/RST/SYN/FIN。</p><ul><li>SYN：TCP三次握手时，如果A是发起端，则A就对服务器发送一个SYN报文，表示想要建立连接。</li><li>ACK：收到数据或者请求后发送响应时发送ACK报文。</li><li>RST：关闭异常连接。</li><li>FIN：TCP四次挥手时，表示关闭连接。</li><li>PSH：发送端需要发送一段数据，这个数据需要接收端一收到就进行向上交付。而接收端在收到PSH标志位有效的数据时，迅速将数据交付给应用层，所以PSH又叫做急迫比特。</li><li>URG：紧急指针，意思为URG位有效的数据包，是一个紧急需要处理的数据包，需要接收端在接收到之后迅速处理。</li></ul><p>RST标志位应用场景如下。</p><p>TCP正常关闭连接的时候使用FIN，但是如果是关闭异常连接，则使用RST，发送RST包。与FIN包存在两点不同：</p><ul><li>RST不必等缓冲区的包都发出去，直接就丢弃缓冲区的包去发送RST包，而FIN需要先处理完缓冲区的包才行。</li><li>接收端收到RST包之后，不需要发送ACK包进行确认，而接收端接收到FIN包的时候需要ACK包应答。</li></ul><h3 id="说说你知道的几种HTTP响应码，比如200，302和404。"><a href="#说说你知道的几种HTTP响应码，比如200，302和404。" class="headerlink" title="说说你知道的几种HTTP响应码，比如200，302和404。"></a>说说你知道的几种HTTP响应码，比如200，302和404。</h3><p>HTTP响应码主要分为五种：</p><ul><li>1XX：请求处理中，请求已被接收，正在处理。</li><li>2XX：请求成功，请求被成功处理。比如200，OK，表示客户端请求成功。</li><li>3XX：重定向，要完成请求必须进行进一步处理。比如301，Moved Permanently，永久重定向，使用域名跳转；302，Found，临时重定向，未登录的用户访问用户中心重定向到登陆界面。</li><li>4XX：客户端错误，请求不合法。比如400，Bad Request，客户端请求有语法错误，不能被服务器所理解；401，Unauthrized，请求未经授权，这个状态代码必须和WWW-Authenticate 报头域一起使用；403，Forbidden，服务器收到请求，但是拒绝提供服务；404，Not Found，请求资源不存在，输入了错误的URL。</li><li>5XX：服务器端错误，服务器不能处理合法请求。比如500，Internal Servel Error，服务器发生不可预期的错误；503，Server Unavailable，服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li></ul><h3 id="如何理解HTTP协议的无状态性。"><a href="#如何理解HTTP协议的无状态性。" class="headerlink" title="如何理解HTTP协议的无状态性。"></a>如何理解HTTP协议的无状态性。</h3><p>无状态，是指协议对于事务处理没有记忆功能。HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。无状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就很快。</p><p>无状态，更容易做服务的扩容，支撑更大的访问量。</p><h3 id="简述Http请求中get和post的区别及数据包格式。"><a href="#简述Http请求中get和post的区别及数据包格式。" class="headerlink" title="简述Http请求中get和post的区别及数据包格式。"></a>简述Http请求中get和post的区别及数据包格式。</h3><p>GET：对服务器资源的简单请求，把参数包含在URL中。</p><p>POST：用于发送包含用户提交数据的请求，通过request body传递阐述。</p><p>另外，对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><h3 id="HTTP的长连接是什么意思。"><a href="#HTTP的长连接是什么意思。" class="headerlink" title="HTTP的长连接是什么意思。"></a>HTTP的长连接是什么意思。</h3><p>HTTP1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求，此外，由于大多数网页的流量都比较小，一次TCP连接很少能通过slow-start区，不利于提高带宽利用率。</p><p>HTTP 1.1支持<strong>长连接（PersistentConnection）和请求的流水线（Pipelining）</strong>处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。例如：一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。</p><p>HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间（请求的流水线）。</p><p>在HTTP/1.0中，要建立长连接，可以在请求消息中包含Connection: Keep-Alive头域，如果服务器愿意维持这条连接，在响应消息中也会包含一个Connection: Keep-Alive的头域。同时，可以加入一些指令描述该长连接的属性，如max，timeout等。</p><h3 id="HTTPS的加密方式是什么，讲讲整个加密解密流程。"><a href="#HTTPS的加密方式是什么，讲讲整个加密解密流程。" class="headerlink" title="HTTPS的加密方式是什么，讲讲整个加密解密流程。"></a>HTTPS的加密方式是什么，讲讲整个加密解密流程。</h3><p>HTTP直接通过明文在浏览器和服务器之间传递消息，容易被监听抓取到通信内容。</p><p>HTTPS采用对称加密和非对称加密结合的方式来进行通信，HTTPS不是应用层的新协议，而是HTTP通信接口用SSL/TLS来加强加密和认证机制。</p><p>整个加密流程如下：</p><p>需要注意的是，第一次服务器向客户端传输证书的具体过程为：</p><ul><li>把公钥以及服务器的个人信息通过Hash算法生成信息摘要；</li><li>为了防止信息摘要被人调换，服务器还会用CA提供的私钥对信息摘要进行加密来形成数字签名；</li><li>最后还会把原来没Hash算法之前的个人信息以及公钥 和 数字签名合并在一起，形成数字证书。</li></ul><p>当客户端拿到这份数字证书之后，就会用CA提供的公钥来对数字证书里面的数字签名进行解密来得到信息摘要，然后对数字证书里服务器的公钥以及个人信息进行Hash得到另外一份信息摘要。最后把两份信息摘要进行对比，如果一样，则证明这个人是服务器，否则就不是。</p><p>整个的流程如下：</p><ul><li>客户端向服务器发起HTTPS请求，连接到服务器的443端口。</li><li>服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</li><li>服务器将自己的公钥发送给客户端。</li><li>客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</li><li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</li><li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</li><li>然后服务器将加密后的密文发送给客户端。</li><li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</li></ul><p>一共是两次非对称加密+一次对称加密。</p><h3 id="Session和cookie的区别。"><a href="#Session和cookie的区别。" class="headerlink" title="Session和cookie的区别。"></a>Session和cookie的区别。</h3><p>Session和cookie都是实现对话管理的方案。主要区别在于：</p><ul><li>Session在服务端，Cookie存储在客户端。</li><li>Session的运行依赖Session ID，而Session ID是存在Cookie中的，也就是说，如果浏览器禁用了Cookie，同时Session也会失效，但是，可以通过其他方式实现，比如在url参数中传递Session ID。</li><li>Tomcat中的Session是存在服务器内存中，不过也可以通过特殊的方式做持久化处理（memcache，redis），方便Session共享。另外，PHP中的Session是存在文件中的。</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</li></ul><h3 id="用户在浏览器输入一个URL并回车，这个过程涉及到哪些网络协议，请具体描述。"><a href="#用户在浏览器输入一个URL并回车，这个过程涉及到哪些网络协议，请具体描述。" class="headerlink" title="用户在浏览器输入一个URL并回车，这个过程涉及到哪些网络协议，请具体描述。"></a>用户在浏览器输入一个URL并回车，这个过程涉及到哪些网络协议，请具体描述。</h3><p>浏览器输入一个URL并回车：</p><ul><li>首先进行域名解析，浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表。若没有，则搜索操作系统的DNS缓存；若没有，则将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，本地的DNS服务器向根域名服务器发出查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</li><li>得到IP地址以后，浏览器就要与服务器建立一个HTTP连接，因此要用到HTTP协议。HTTP生成一个GET请求报文。</li><li>接下来到了传输层，选择传输协议，TCP或者UDP，TCP是可靠的传输控制协议，对HTTP请求进行封装，加入了端口号等信息。</li><li>然后到了网络层，通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址。</li><li>接下来到了数据链路层，把网络层交下来的IP数据报添加首部和尾部，封装为MAC帧，现在根据目的mac开始建立TCP连接，三次握手，接收端在收到物理层上交的比特流后，根据首尾的标记，识别帧的开始和结束，将中间的数据部分上交给网络层，然后层层向上传递到应用层。</li><li>服务器响应请求并请求客户端要的资源，传回给客户端。</li><li>断开TCP连接，浏览器对页面进行渲染呈现给客户端。</li></ul><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>七层网络模型</p><p>自上而下分别是：</p><ul><li>应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用。</li><li>表示层（数据）：主要解决用户信息的语法表示问题，如加密解密。在表示层进行代码/编码转换。</li><li>会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的。在会话层封装会话控制参数。</li><li>传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等。在传输层封装传输控制。</li><li>网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的传输。在网络层加上逻辑寻址地址。</li><li>数据链路层（帧）：将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正。在数据链路层封装基于MAC的信息。</li><li>物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等。在物理层连接到线缆系统进行实际传递。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/42.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器(centos7.7)上配置java，nginx，mysql，redis环境，并上传前端项目，运行java项目</title>
      <link href="/2020/06/24/a-li-yun-fu-wu-qi/"/>
      <url>/2020/06/24/a-li-yun-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这是我在阿里云服务器上面做环境配置时做的笔记</li></ul><h3 id="centos下安装mysql5-7"><a href="#centos下安装mysql5-7" class="headerlink" title="centos下安装mysql5.7"></a>centos下安装mysql5.7</h3><h4 id="安装mysql数据库"><a href="#安装mysql数据库" class="headerlink" title="安装mysql数据库"></a>安装mysql数据库</h4><ul><li>下载mysql源安装包:wget <a href="http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm" target="_blank" rel="noopener">http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</a></li><li>安装mysql源:yum localinstall mysql57-community-release-el7-8.noarch.rpm<br>若结尾出现complete!，则说明MySQL源安装完成</li><li>检测是否安装完成:yum repolist enabled | grep “mysql.<em>-community.</em>“</li></ul><pre><code>    //出现以下则已安装完成    mysql-connectors-community/x86_64 MySQL Connectors Community                 153    mysql-tools-community/x86_64      MySQL Tools Community                      110    mysql57-community/x86_64          MySQL 5.7 Community Server                 424</code></pre><ul><li>安装mysql:yum install mysql-community-server<br>   若结尾出现Complete!， 则MySQL安装完成</li><li>设置开启启动mysql服务:systemctl enable mysqld</li><li>查看安装的mysql版本:rpm -aq | grep -i mysql</li></ul><pre><code>    mysql57-community-release-el7-8.noarch    mysql-community-client-5.7.30-1.el7.x86_64    mysql-community-libs-5.7.30-1.el7.x86_64    mysql-community-libs-compat-5.7.30-1.el7.x86_64    mysql-community-server-5.7.30-1.el7.x86_64    mysql-community-common-5.7.30-1.el7.x86_64</code></pre><ul><li>启动MySQL服务：systemctl restart mysqld</li><li>查看mysql启动状态：service mysqld status</li><li>重启mysl：service mysqld restart</li><li>查看MySQL初始密码：grep ‘A temporary password’ /var/log/mysqld.log</li></ul><h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><ul><li>该方法先修改mysql配置文件使其可以无密码登录，让后修改密码，之后便复原配置文件</li><li>修改/etc/my.cnf ： vim /etc/my.cnf </li><li>配置文件添加skip-grant-tables</li></ul><pre><code>    [root@VM_0_8_centos ~]# vim /etc/my.cnf    # For advice on how to change settings please see    # http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html    [mysqld]    #    # Remove leading # and set to the amount of RAM for the most important data    # cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.    # innodb_buffer_pool_size = 128M    #    # Remove leading # to turn on a very important data integrity option: logging    # changes to the binary log between backups.    # log_bin    #    # Remove leading # to set options mainly useful for reporting servers.    # The server defaults are faster for transactions and fast SELECTs.    # Adjust sizes as needed, experiment to find the optimal values.    # join_buffer_size = 128M    # sort_buffer_size = 2M    # read_rnd_buffer_size = 2M    datadir=/var/lib/mysql    socket=/var/lib/mysql/mysql.sock    skip-grant-tables                       此处！！！！！！    # Disabling symbolic-links is recommended to prevent assorted security risks    symbolic-links=0</code></pre><ul><li>重启mysql ： service mysqld restart</li><li>即可免密登录，命令行输入mysql直接登录</li></ul><pre><code>    mysql</code></pre><ul><li>选择mysql数据库</li></ul><pre><code>    USE mysql;</code></pre><ul><li>然后输入下列命令重置密码，设置密码为980508 </li></ul><pre><code>    update mysql.user set authentication_string=password(&#39;980508&#39;) where user=&#39;root&#39; and Host =&#39;localhost&#39;;</code></pre><ul><li>然后修改/etc/my.cnf ： vim /etc/my.cnf 去掉加的那一行代码</li></ul><h3 id="设置远程连接"><a href="#设置远程连接" class="headerlink" title="设置远程连接"></a>设置远程连接</h3><ul><li>两种步骤选其一，优先一</li><li>方式一</li></ul><pre><code>    登录到mysql执行如下：     --创建用户（用于远程连接的用户）    GRANT ALL PRIVILEGES ON *.* TO &#39;username&#39;@&#39;%&#39; IDENTIFIED BY &#39;username&#39; WITH GRANT OPTION;    -- 刷新权限表    flush privileges;    查看mysql数据库用户：    SELECT DISTINCT CONCAT(&#39;User: &#39;&#39;&#39;,user,&#39;&#39;&#39;@&#39;&#39;&#39;,host,&#39;&#39;&#39;;&#39;) AS query FROM mysql.user;</code></pre><ul><li>方式二：修改root用户的host 为%</li></ul><pre><code>    1 .登录MySQL 后 执行  use mysql;    然后查看root用户的host   selcet user,host from user;  如果user的host 不是 % ，需要执行update user set host=&#39;%&#39; where user=&#39;root&#39;; 修改     2、修改完成后执行 flush privileges;    3、退出mysql 重启mysql服务     exit;      sercice  mysqld restart </code></pre><h3 id="各种报错解决"><a href="#各种报错解决" class="headerlink" title="各种报错解决"></a>各种报错解决</h3><ul><li>The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement解决方法</li></ul><pre><code>    错误描述：但我们设置远程连接服务时    mysql&gt; grant all on cactidb.* to dbuser@&#39;localhost&#39; identified by &#39;123&#39;;    ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement    解决方法：    先刷新一下权限表。    mysql&gt; flush privileges;    Query OK, 0 rows affected (0.01 sec)    mysql&gt; grant all on cactidb.* to dbuser@&#39;localhost&#39; identified by &#39;123&#39;;    Query OK, 0 rows affected (0.00 sec)</code></pre><ul><li>登录进去后MySQL 输入任何语句都提示You must reset your password using ALTER USER 解决方法</li></ul><pre><code>    SET PASSWORD = PASSWORD(&#39;新密码&#39;);    ALTER USER &#39;root&#39;@&#39;localhost&#39; PASSWORD EXPIRE NEVER;    FLUSH PRIVILEGES;</code></pre><ul><li>Your password does not satisfy the current policy requirements 修改mysql密码出现的错误</li></ul><pre><code>    set global validate_password_policy=0;    set global validate_password_length=1;</code></pre><ul><li>MySQL5.7更改密码时出现ERROR 1054 (42S22): Unknown column ‘password’ in ‘field list’</li></ul><pre><code>    新安装的MySQL5.7，登录时提示密码错误，安装的时候并没有更改密码，后来通过免密码登录的方式更改密码，输入update mysql.user  set password=password(&#39;root&#39;) where user=&#39;root&#39;时提示ERROR 1054 (42S22): Unknown column &#39;password&#39; in &#39;field list&#39;，原来是mysql数据库下已经没有password这个字段了，password字段改成了    authentication_string    所以更改语句替换为update mysql.user set authentication_string=password(&#39;root&#39;) where user=&#39;root&#39; ;即可</code></pre><ul><li>【mysql】ERROR 1054 (42S22): Unknown column ‘‘root‘’ in ‘where clause’</li></ul><pre><code>    今天在安装mysql的时候，前面的步骤都没有太大的问题，但是到了想要重置密码的时候出现了问题，ERROR 1054 (42S22): Unknown column &#39;‘root‘&#39; in &#39;where clause&#39;，不管如何用sql语句进行重置，它都会出现这样的提示语句，我用的语句如下：    update user set password=password(‘123456‘) where user=‘root‘;            但是死活就是报如题中的错误，然后找到了解决的方案，原来是我们在代码和sql工具中写sql语句的时候，字符串用‘’就可以被引用，但是在Xshell环境下，并没有这样的环境，Linux的命令中，似乎“”才是引用字符串的王道，所以只需要把我们想要添加的文字替换成用“”包括就可以了。    update user set password=password(&quot;123456&quot;) where user=&quot;root&quot;;    然后就可以正常登陆</code></pre><h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><ul><li>centos7.7记得搜索安装方法要搜centos7.7安装方法</li><li>下载压缩包</li></ul><p>wget <a href="https://imcfile.oss-cn-beijing.aliyuncs.com/shizhan/file/liaoshixiong/nginx-1.16.1.tar.gz" target="_blank" rel="noopener">https://imcfile.oss-cn-beijing.aliyuncs.com/shizhan/file/liaoshixiong/nginx-1.16.1.tar.gz</a></p><ul><li>查看所有下载的包文件和大小</li></ul><pre><code>    ls -alh</code></pre><ul><li>解压文件</li></ul><pre><code>    tar -zxvf nginx-1.16.1.tar.gz</code></pre><h4 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h4><ul><li>进入nginx目录</li></ul><pre><code>    cd nginx-1.16.1</code></pre><ul><li>配置一些文件</li></ul><pre><code>    //设置安装目录    ./configure --prefix=/usr/local/nginx</code></pre><ul><li>这时可能会报一个错</li></ul><pre><code>    ./configure: error: C compiler cc is not found</code></pre><ul><li>原因是缺少gcc-c++的包，下载</li></ul><pre><code>    yum -y install gcc-c++</code></pre><ul><li>此时又会报错，原因还是缺少一些包</li></ul><pre><code>    ./configure: error: the HTTP rewrite module requires the PCRE library.    You can either disable the module by using --without-http_rewrite_module    option, or install the PCRE library into the system, or build the PCRE library    statically from the source with nginx by using --with-pcre=&lt;path&gt; option.</code></pre><ul><li>我们先更新一下</li></ul><pre><code>    yum update</code></pre><ul><li>然后安装一些组件</li></ul><pre><code>    yum install -y zlib-devel openssl openssl-devel</code></pre><ul><li>此时执行将不会报错</li></ul><pre><code>    ./configure --prefix=/usr/local/nginx</code></pre><ul><li>刚刚是配置，现在输入make，make是编译</li></ul><pre><code>    make</code></pre><ul><li>make不是安装make install才是安装</li></ul><pre><code>    make install</code></pre><ul><li>此时执行nginx，然后会找不到命令，因为我们没有进到安装nginx目录</li><li>查看nginx安装目录</li></ul><pre><code>    ls /usr/local/nginx/sbin/    然后会显示nginx</code></pre><ul><li>执行</li></ul><pre><code>    /usr/local/nginx/sbin/nginx</code></pre><ul><li>但是每次这样启动太麻烦了，我们可以设置一个环境变量，让它在任何目录都可以启动</li></ul><pre><code>    //先cd到根目录    cd    //编辑.bash_profile文件    vim .bash_profile    PATH=$PATH:$HOME/bin    PATH=$PATH:/usr/local/nginx/sbin        此处加上安装的目录！！！！！    //让配置生效    source .bash_profile</code></pre><ul><li>此时直接执行nginx发现可以运行了，但是会报一个错，这是因为我们已经启动了nginx</li></ul><pre><code>    nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)    nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)    nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)    nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)    nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)    nginx: [emerg] still could not bind()</code></pre><ul><li>我们查看运行的nginx进程</li></ul><pre><code>    ps -ef |grep nginx</code></pre><ul><li>如果已经启动起来了，我们浏览器访问服务器公网ip，如果成功你将会看到</li></ul><pre><code>    Welcome to nginx!    If you see this page, the nginx web server is successfully installed and working. Further configuration is required.    For online documentation and support please refer to nginx.org.    Commercial support is available at nginx.com.    Thank you for using nginx.</code></pre><ul><li>但是失败会有两种情况，一是被阿里云服务器防火墙拦截掉了，不允许外网访问，二是nginx服务器压根就没启动，如何区别呢</li></ul><pre><code>    //这是一个测试的方法,可以用来测试nginx有没有启动，阿里云服务器防火墙虽然可以做限制，但是还是无法阻止本地服务访问，所以我们可以以此来判断    curl http://127.0.0.1    //以后调试java应用也可以用此方法调试接口</code></pre><h3 id="部署前端项目代码"><a href="#部署前端项目代码" class="headerlink" title="部署前端项目代码"></a>部署前端项目代码</h3><ul><li>前端项目文件放在/home/www/dist/目录下面</li><li>我们很多nginx服务器配置都在这个目录下面</li></ul><pre><code>    /usr/local/nginx</code></pre><ul><li>然后我们进入到/usr/local/nginx/conf目录</li><li>修改nginx.conf文件，这是我修改后的文件</li></ul><pre><code>    #user  nobody;    worker_processes  1;    #error_log  logs/error.log;    #error_log  logs/error.log  notice;    #error_log  logs/error.log  info;    #pid        logs/nginx.pid;    events {        worker_connections  1024;    }    http {        include       mime.types;        default_type  application/octet-stream;        #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;        #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;        #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;        #access_log  logs/access.log  main;        sendfile        on;        #tcp_nopush     on;        #keepalive_timeout  0;        keepalive_timeout  65;        #gzip  on;        server {            listen       80;               server_name  mi.lhz520.top;            index index.html index.htm login.html;            location ^~/api/ {              proxy_pass http://mall-pre.springboot.cn/;            }          location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$          {            root /home/www/dist/;          }          location ~ .*\.(js|html|css)?$          {            root /home/www/dist/;            expires 30d;          }            #charset koi8-r;            #access_log  logs/host.access.log  main;            location / {                root   /home/www/dist/;                index  index.html index.htm login.html;            }            #error_page  404              /404.html;            # redirect server error pages to the static page /50x.html            #            error_page   500 502 503 504  /50x.html;            location = /50x.html {                root   html;            }            # proxy the PHP scripts to Apache listening on 127.0.0.1:80            #            #location ~ \.php$ {            #    proxy_pass   http://127.0.0.1;            #}            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000            #            #location ~ \.php$ {            #    root           html;            #    fastcgi_pass   127.0.0.1:9000;            #    fastcgi_index  index.php;            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;            #    include        fastcgi_params;            #}            # deny access to .htaccess files, if Apache&#39;s document root            # concurs with nginx&#39;s one            #            #location ~ /\.ht {            #    deny  all;            #}        }        # another virtual host using mix of IP-, name-, and port-based configuration        #        #server {        #    listen       8000;        #    listen       somename:8080;        #    server_name  somename  alias  another.alias;        #    location / {        #        root   html;        #        index  index.html index.htm;        #    }        #}        # HTTPS server        #        #server {        #    listen       443 ssl;        #    server_name  localhost;        #    ssl_certificate      cert.pem;        #    ssl_certificate_key  cert.key;        #    ssl_session_cache    shared:SSL:1m;        #    ssl_session_timeout  5m;        #    ssl_ciphers  HIGH:!aNULL:!MD5;        #    ssl_prefer_server_ciphers  on;        #    location / {        #        root   html;        #        index  index.html index.htm;        #    }        #}    }</code></pre><ul><li>配置完后重启nginx</li></ul><pre><code>    nginx -s reload  ：修改配置后重新加载生效</code></pre><h3 id="部署java项目"><a href="#部署java项目" class="headerlink" title="部署java项目"></a>部署java项目</h3><ul><li>下载jdk</li></ul><pre><code>    wget https://imcfile.oss-cn-beijing.aliyuncs.com/shizhan/file/liaoshixiong/jdk-8u231-linux-x64.tar.gz</code></pre><ul><li>解压</li></ul><pre><code>    tar zxvf jdk-8u231-linux-x64.tar.gz</code></pre><ul><li>然后把解压的文件移动到/usr/local下</li></ul><pre><code>    mv jdk1.8.0_231 /usr/local/</code></pre><ul><li>cd到根目录</li></ul><pre><code>    cd</code></pre><ul><li>配置环境变量vim .bash_profile，往下加两行代码</li></ul><pre><code>    # .bash_profile    # Get the aliases and functions    if [ -f ~/.bashrc ]; then            . ~/.bashrc    fi    # User specific environment and startup programs    PATH=$PATH:$HOME/bin    PATH=$PATH:/usr/local/nginx/sbin    JAVA_HOME=/usr/local/jdk1.8.0_231       此处！！！    PATH=$PATH:$JAVA_HOME/bin               和此处！！！    export PATH</code></pre><ul><li>让配置文件生效</li></ul><pre><code>    source .bash_profile</code></pre><ul><li>查看有没有安装好，输入这些命令就可以知道有没有装好</li></ul><pre><code>    java    java -version</code></pre><ul><li>然后打包java项目</li></ul><pre><code>    mvn clean package -Dmaven.test.skip=true</code></pre><ul><li>打包完以后发现文件名很长，可以改成自己想要的名字，在pom文件中改</li></ul><pre><code>    &lt;build&gt;        &lt;finalName&gt;mall&lt;/finalName&gt;    &lt;build/&gt;</code></pre><ul><li>然后上传到服务器的/root文件夹下面</li><li>运行java程序，一定要设置好开发环境和生产环境，特别是数据库的配置</li></ul><pre><code>    //不能这样，因为这样是使用开发环境，使用的不是服务器上的数据库    java -jar mall.jar    //应该指定环境    java -jar -Dspring.profiles.avtice=prod mall.jar</code></pre><ul><li>如何后台启动java项目呢</li></ul><pre><code>    //创建配置文件，启动脚本    vim /etc/systemd/system/mall.service    //配置文件    [Unit]    Description=mall    After=syslog.target    [Service]    User=root    ExecStart=/usr/local/jdk1.8.0_231/bin/java -jar -Dspring.profiles.active=prod /root/mall.jar    [Install]    WantedBy=multi-user.target</code></pre><ul><li>然后运行</li></ul><pre><code>    systemctl start mall</code></pre><ul><li>查看有没有启动</li></ul><pre><code>    ps -ef |grep java</code></pre><ul><li>这样就已经后台启动好了，我们给它加个日志功能，修改启动脚本</li></ul><pre><code>    vim /etc/systemd/system/mall.service    [Unit]    Description=mall    After=syslog.target    [Service]    User=root    ExecStart=/usr/local/jdk1.8.0_231/bin/java -jar -Dspring.profiles.active=prod -Dlogging.path=/root/logs/ /root/mall.jar    [Install]    WantedBy=multi-user.target</code></pre><ul><li>创建文件夹，日志文件存放在里面</li></ul><pre><code>    mkdir logs</code></pre><ul><li>重启服务</li></ul><pre><code>    systemctl stop mall    systemctl start mall</code></pre><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><ul><li>下载包</li></ul><pre><code>    wget wget http://download.redis.io/releases/redis-5.0.8.tar.gz</code></pre><ul><li>解压到指定路径</li></ul><pre><code>    tar -zxvf redis-5.0.8.tar.gz -C /usr/local</code></pre><ul><li>编译</li></ul><pre><code>    cd /usr/local/redis-5.0.8    make</code></pre><ul><li>编译成功将会出现</li></ul><pre><code>    Hint: It&#39;s a good idea to run &#39;make test&#39; 😉    make[1]: Leaving directory `/usr/local/redis-5.0.8/src&#39;</code></pre><ul><li>然后执行下面命令</li></ul><pre><code>    cd /usr/local/redis-5.0.8/src    make install</code></pre><ul><li>成功</li></ul><pre><code>    Hint: It&#39;s a good idea to run &#39;make test&#39; 😉    INSTALL install    INSTALL install    INSTALL install    INSTALL install    INSTALL install</code></pre><ul><li>修改配置文件</li></ul><pre><code>    vim /usr/local/redis-5.0.8/redis.conf    protected-mode no # 关闭保护模式    daemonize yes     # 守护进程模式开启    bind 127.0.0.1  注释掉，不然远程连接不上</code></pre><ul><li>千万记住修改完配置文件后要重启，不然不会生效！！！踩了好大的坑</li></ul><pre><code>    //以下命令一起输入    /usr/local/redis-5.0.8/src/redis-server &amp;    /usr/local/redis-5.0.8/redis.conf    //或者    cd /usr/local/redis-5.0.8    ./src/redis-server  redis.conf</code></pre><ul><li>启动服务端和客户端</li></ul><pre><code>    /usr/local/redis-5.0.8/src/redis-server    /usr/local/redis-5.0.8/src/redis-cli</code></pre><ul><li>后台启动服务端</li></ul><pre><code>    /usr/local/redis-5.0.8/src/redis-server &amp;</code></pre><ul><li>查看redis进程</li></ul><pre><code>    ps -ef | grep redis</code></pre><ul><li>密码登录客户端</li></ul><pre><code>    cd /usr/local/redis-5.0.8/src    ./redis-cli -h 127.0.0.1 -p 6379 -a 980508</code></pre>]]></content>
      
      
      <categories>
          
          <category> 服务器(centos7.7) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> redis </tag>
            
            <tag> mysql </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex</title>
      <link href="/2020/06/13/vuex/"/>
      <url>/2020/06/13/vuex/</url>
      
        <content type="html"><![CDATA[<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><ul><li>VueX是适用于在Vue项目开发时使用的状态管理工具。试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步data中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。为此，Vue为这些被多个组件频繁使用的值提供了一个统一管理的工具——VueX。在具有VueX的Vue项目中，我们只需要把这些值定义在VueX中，即可在整个Vue项目的组件中使用。</li><li>通俗的来说，组件可以调用自己的data数据，但是组件与组件之间无法跨组件调用，这时vuex就显示他的作用了，vuex就像一个前端数据库，把数据存储进去，从而使所有的组件的能够使用</li></ul><h4 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h4><ul><li>npm i vuex -s</li></ul><h4 id="VueX中的核心内容"><a href="#VueX中的核心内容" class="headerlink" title="VueX中的核心内容"></a>VueX中的核心内容</h4><ul><li>state 存放状态<ul><li>state就相当与数据库的数据</li></ul></li><li>mutations state成员操作<ul><li>mutations就相当于增删改查操作</li></ul></li><li>getters 加工state成员给外界</li><li>actions 异步操作<ul><li>异步操作，提交mutations操作</li></ul></li><li>modules 模块化状态管理</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul><li>初始化store下index.js中的内容</li></ul><pre><code>    import Vue from &#39;vue&#39;;    import Vuex from &#39;vuex&#39;;    import actions from &#39;./actions&#39;    import mutations from &#39;./mutations&#39;    Vue.use(Vuex);    const state = {        username:&#39;&#39;,    //用户名        cartcount: 0    //购物车数量    }    export default new Vuex.Store({        state,        actions,        mutations    })</code></pre><ul><li>mutations</li></ul><pre><code>    //商城Vuex-mutation    export default{        saveUserName(state,username){        //改变数据            state.username = username        },        saveCartCount(state,cartcount){            state.cartcount = cartcount        }    }</code></pre><ul><li>actions</li></ul><pre><code>    //商城Vuex-action    export default{        saveUserName(context,username){        //提交            context.commit(&#39;saveUserName&#39;,username)        },        saveCartCount(context,cartcount){            context.commit(&#39;saveCartCount&#39;,cartcount)        }    }</code></pre><h5 id="将store挂载到当前项目的Vue实例当中去"><a href="#将store挂载到当前项目的Vue实例当中去" class="headerlink" title="将store挂载到当前项目的Vue实例当中去"></a>将store挂载到当前项目的Vue实例当中去</h5><ul><li>main.js,这样就可以全局调用了</li></ul><pre><code>    import store from &#39;./store/index&#39;    new Vue({      store,      router: router,      render: h =&gt; h(App),    }).$mount(&#39;#app&#39;)</code></pre><h5 id="dispatch分配actions任务"><a href="#dispatch分配actions任务" class="headerlink" title="dispatch分配actions任务"></a>dispatch分配actions任务</h5><ul><li>可以在App.vue里使用，这样全局都可以使用这个值了</li></ul><pre><code>      this.$store.dispatch(&#39;saveUserName&#39;,res.username)</code></pre><h5 id="渲染延迟"><a href="#渲染延迟" class="headerlink" title="渲染延迟"></a>渲染延迟</h5><ul><li>当我们拉取数据来渲染页面时会有延迟效果，可能渲染不出来获取的值，我们可以用computed来解决</li></ul><pre><code>    computed: {        username() {          return this.$store.state.username;        },        cartcount() {          return this.$store.state.cartcount;        }      },</code></pre><h5 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h5><ul><li>mapState辅助函数可以帮助我们引用state，与上面的效果是一样的</li></ul><pre><code> import { mapState } from &#39;vuex&#39;; computed: {      ...mapState([&#39;username&#39;, &#39;cartcount&#39;])    },</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios</title>
      <link href="/2020/06/13/axios/"/>
      <url>/2020/06/13/axios/</url>
      
        <content type="html"><![CDATA[<h2 id="axios-简介"><a href="#axios-简介" class="headerlink" title="axios 简介"></a>axios 简介</h2><ul><li><p>axios是网络请求封装的框架，axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p><ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API（本身就是一个promise结构）</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防止 CSRF/XSRF</li></ul></li><li><p>引入方式</p></li></ul><pre><code>    npm install axios</code></pre><ul><li>导入使用</li></ul><pre><code>    import axios from &#39;axios&#39;    import VueAxios from &#39;vue-axios&#39;    //VueAxios的作用是将axios框架挂载到vue实例上，这样我们在其他vue文件中使用axios就不用importer了，直接用this.axios    Vue.use(VueAxios,axios)</code></pre><h3 id="设置全局默认值"><a href="#设置全局默认值" class="headerlink" title="设置全局默认值"></a>设置全局默认值</h3><pre><code>    //根据前端跨域进行调整，`baseURL` 将自动加在 `url` 前面    axios.defaults.baseURL = &#39;/api&#39;    // axios.defaults.baseURL = env.baseURL    //设置超时时间    axios.defaults.timeout = 8000</code></pre><h3 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h3><ul><li>可以通过向 axios 传递相关配置来创建请求</li><li>axios(config)最常用的就是这个可以发送各种请求post，get都行</li></ul><pre><code>    // 发送 POST 请求    axios({      method: &#39;post&#39;,      url: &#39;/user/12345&#39;,      data: {        firstName: &#39;Fred&#39;,        lastName: &#39;Flintstone&#39;      }    });    // 发送 GET 请求（默认的方法）    axios(&#39;/user/12345&#39;);</code></pre><ul><li>为方便起见，为所有支持的请求方法提供了别名</li></ul><pre><code>    axios.request(config)    axios.get(url[, config])    axios.delete(url[, config])    axios.head(url[, config])    axios.post(url[, data[, config]])    axios.put(url[, data[, config]])    axios.patch(url[, data[, config]])</code></pre><ul><li>处理并发请求的助手函数</li></ul><pre><code>    axios.all(iterable)    axios.spread(callback)</code></pre><h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><ul><li>不带参</li></ul><pre><code>    this.axios.get(&quot;/carts&quot;).then(res =&gt; {    this.renderData(res);  });</code></pre><ul><li>带参，参数是加在尾部的如：products?pageNum=2&amp;pageSize=1&amp;categoryId=100002</li></ul><pre><code>    this.axios    .get(&quot;/products&quot;, {      params: {        categoryId: &quot;100012&quot;,        pageSize: 14      }    })    .then(res =&gt; {      res.list = res.list.slice(6, 14);      this.phoneList = [res.list.slice(0, 4), res.list.slice(4, 8)];    });</code></pre><h4 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h4><ul><li>带参数</li></ul><pre><code>    let { username, password, email } = this;  this.axios.post(&quot;/user/register&quot;, {    username,    password,    email  }).then(()=&gt;{    this.$message.success(&#39;注册成功&#39;)  });</code></pre><ul><li>不带参    </li></ul><pre><code>    //退出登陆时把名字和购物车数量设为空，弹出退出信息，userid失效    this.axios.post(&quot;/user/logout&quot;).then(() =&gt; {      this.$message.success(&#39;退出成功&#39;);      this.$cookie.set(&#39;userId&#39;, &#39;&#39;, { expires: &#39;-1&#39; });  //关闭的窗口的时候userid失效      this.$store.dispatch(&#39;saveUserName&#39;, &#39;&#39;);      this.$store.dispatch(&#39;saveCartCount&#39;, &#39;0&#39;);    })</code></pre><h4 id="put请求"><a href="#put请求" class="headerlink" title="put请求"></a>put请求</h4><ul><li>不带参</li></ul><pre><code>    let url = this.allChecked ? &quot;/carts/unSelectAll&quot; : &quot;/carts/selectAll&quot;;  this.axios.put(url).then(res =&gt; {    this.renderData(res);  });</code></pre><ul><li>带参</li></ul><pre><code>    this.axios    .put(`/carts/${item.productId}`, {      quantity,      selected    })    .then(res =&gt; {      this.renderData(res);    });</code></pre><h4 id="delete请求"><a href="#delete请求" class="headerlink" title="delete请求"></a>delete请求</h4><pre><code>this.axios.delete(`/carts/${item.productId}`).then(res =&gt; {        this.renderData(res);      })</code></pre><h3 id="自定义创建实例"><a href="#自定义创建实例" class="headerlink" title="自定义创建实例"></a>自定义创建实例</h3><pre><code>    // 使用由库提供的配置的默认值来创建实例    // 此时超时配置的默认值是 `0`    var instance = axios.create();    // 覆写库的超时默认值    // 现在，在超时前，所有请求都会等待 2.5 秒    instance.defaults.timeout = 2500;    // 为已知需要花费很长时间的请求覆写超时设置    instance.get(&#39;/longRequest&#39;, {      timeout: 5000    });</code></pre><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><ul><li>在请求或响应被 then 或 catch 处理前拦截它们。</li></ul><pre><code>    // 添加请求拦截器    axios.interceptors.request.use(function (config) {        // 在发送请求之前做些什么        return config;      }, function (error) {        // 对请求错误做些什么        return Promise.reject(error);      });    // 添加响应拦截器    axios.interceptors.response.use(function (response) {        // 对响应数据做点什么        return response;      }, function (error) {        // 对响应错误做点什么        return Promise.reject(error);      });</code></pre><ul><li>响应结构</li></ul><pre><code>    {      // `data` 由服务器提供的响应      data: {},      // `status` 来自服务器响应的 HTTP 状态码      status: 200,      // `statusText` 来自服务器响应的 HTTP 状态信息      statusText: &#39;OK&#39;,      // `headers` 服务器响应的头      headers: {},      // `config` 是为请求提供的配置信息      config: {}    }    使用 then 时，你将接收下面这样的响应：    axios.get(&#39;/user/12345&#39;)      .then(function(response) {        console.log(response.data);        console.log(response.status);        console.log(response.statusText);        console.log(response.headers);        console.log(response.config);      });</code></pre><h4 id="接口响应拦截"><a href="#接口响应拦截" class="headerlink" title="接口响应拦截"></a>接口响应拦截</h4><pre><code>    //接口错误拦截    axios.interceptors.response.use(function(response){   //拦截页面返回数据状态码      let res = response.data   //返回的数据为response.data，包括status和data      if(res.status == 0){      //状态码为0代表登陆成功        return res.data      }else if(res.status == 10){    //状态码为10代表未登陆，跳转到登陆页面        if(location.hash!=&quot;#/index&quot;){     //如果没有登录则只能访问首页          window.location.href = &quot;/#/login&quot;   //跳转到登陆页面        }        return Promise.reject()   //发生错误，promise返回拒绝值      }else{        Message.error(res.msg)        return Promise.reject()   //发生错误，promise返回拒绝值      }    },(error)=&gt;{    //拦截http请求状态码（请求发送失败）      let res = error.response      Message.error(res.data.message)      return Promise.reject()   //发生错误，promise返回拒绝值    })</code></pre><h4 id="错误拦截"><a href="#错误拦截" class="headerlink" title="错误拦截"></a>错误拦截</h4><ul><li>记住以后的交互请求功能，res最好加上一个默认值，防止请求不到数据时报错，还有记得在main.js的错误拦截处，发生错误时</li></ul><pre><code>    return Promise.reject()   //发生错误，promise返回拒绝值</code></pre><h3 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h3><ul><li>这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。</li></ul><pre><code>    {      // `url` 是用于请求的服务器 URL      url: &#39;/user&#39;,      // `method` 是创建请求时使用的方法      method: &#39;get&#39;, // 默认是 get      // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。      // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL      baseURL: &#39;https://some-domain.com/api/&#39;,      // `transformRequest` 允许在向服务器发送前，修改请求数据      // 只能用在 &#39;PUT&#39;, &#39;POST&#39; 和 &#39;PATCH&#39; 这几个请求方法      // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream      transformRequest: [function (data) {        // 对 data 进行任意转换处理        return data;      }],      // `transformResponse` 在传递给 then/catch 前，允许修改响应数据      transformResponse: [function (data) {        // 对 data 进行任意转换处理        return data;      }],      // `headers` 是即将被发送的自定义请求头      headers: {&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;},      // `params` 是即将与请求一起发送的 URL 参数      // 必须是一个无格式对象(plain object)或 URLSearchParams 对象      params: {        ID: 12345      },      // `paramsSerializer` 是一个负责 `params` 序列化的函数      // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)      paramsSerializer: function(params) {        return Qs.stringify(params, {arrayFormat: &#39;brackets&#39;})      },      // `data` 是作为请求主体被发送的数据      // 只适用于这些请求方法 &#39;PUT&#39;, &#39;POST&#39;, 和 &#39;PATCH&#39;      // 在没有设置 `transformRequest` 时，必须是以下类型之一：      // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams      // - 浏览器专属：FormData, File, Blob      // - Node 专属： Stream      data: {        firstName: &#39;Fred&#39;      },      // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)      // 如果请求超过 `timeout` 的时间，请求将被中断      timeout: 1000,      // `withCredentials` 表示跨域请求时是否需要使用凭证      withCredentials: false, // 默认的      // `adapter` 允许自定义处理请求，以使测试更轻松      // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).      adapter: function (config) {        /* ... */      },      // `auth` 表示应该使用 HTTP 基础验证，并提供凭据      // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头      auth: {        username: &#39;janedoe&#39;,        password: &#39;s00pers3cret&#39;      },      // `responseType` 表示服务器响应的数据类型，可以是 &#39;arraybuffer&#39;, &#39;blob&#39;, &#39;document&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39;      responseType: &#39;json&#39;, // 默认的      // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称      xsrfCookieName: &#39;XSRF-TOKEN&#39;, // default      // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称      xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;, // 默认的      // `onUploadProgress` 允许为上传处理进度事件      onUploadProgress: function (progressEvent) {        // 对原生进度事件的处理      },      // `onDownloadProgress` 允许为下载处理进度事件      onDownloadProgress: function (progressEvent) {        // 对原生进度事件的处理      },      // `maxContentLength` 定义允许的响应内容的最大尺寸      maxContentLength: 2000,      // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte      validateStatus: function (status) {        return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的      },      // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目      // 如果设置为0，将不会 follow 任何重定向      maxRedirects: 5, // 默认的      // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：      // `keepAlive` 默认没有启用      httpAgent: new http.Agent({ keepAlive: true }),      httpsAgent: new https.Agent({ keepAlive: true }),      // &#39;proxy&#39; 定义代理服务器的主机名称和端口      // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据      // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。      proxy: {        host: &#39;127.0.0.1&#39;,        port: 9000,        auth: : {          username: &#39;mikeymike&#39;,          password: &#39;rapunz3l&#39;        }      },      // `cancelToken` 指定用于取消请求的 cancel token      // （查看后面的 Cancellation 这节了解更多）      cancelToken: new CancelToken(function (cancel) {      })    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的引入和具体使用方法，还有服务器部署</title>
      <link href="/2020/06/12/redis/"/>
      <url>/2020/06/12/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这些都是redis的具体使用方法</li></ul><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ul><li>我们使用购物车的时候需要用到redis</li><li>这里我们用的是redis5</li></ul><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre><code>    &lt;!--        redis--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code>    spring:        redis:            host: localhost            port: 6379</code></pre><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>在方法里注入StringRedisTemplate</li></ul><pre><code>    @Autowired    private StringRedisTemplate stringRedisTemplate;</code></pre><ul><li>操作</li></ul><pre><code>    redisTemplate.opsForValue();　　//操作字符串    redisTemplate.opsForHash();　　 //操作hash    redisTemplate.opsForList();　　 //操作list    redisTemplate.opsForSet();　　  //操作set    redisTemplate.opsForZSet();　 　//操作有序set</code></pre><h3 id="StringRedisTemplate与RedisTemplate的区别"><a href="#StringRedisTemplate与RedisTemplate的区别" class="headerlink" title="StringRedisTemplate与RedisTemplate的区别"></a>StringRedisTemplate与RedisTemplate的区别</h3><ul><li>两者的关系是StringRedisTemplate继承RedisTemplate。</li><li>两者的数据是不共通的；也就是说StringRedisTemplate只能管理StringRedisTemplate里面的数据</li><li>RedisTemplate只能管RedisTemplate中的数据。</li><li>SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。</li><li>StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。</li><li>RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。</li></ul><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><ul><li>这里暂时只用到了opsForHash(操作hashmap)，更多操作方法在下面</li></ul><pre><code>    //获取对象，注意这里设置全是String类型的    HashOperations&lt;String, String, String&gt; opsForHash = stringRedisTemplate.opsForHash();    //遍历redis    private List&lt;Cart&gt; listForCart(Integer uid) {            HashOperations&lt;String, String, String&gt; opsForHash = stringRedisTemplate.opsForHash();            //redisKey            String redisKey = String.format(CART_REDIS_KEY_TEMPLATE, uid);            //获取所有键值对            Map&lt;String, String&gt; entries = opsForHash.entries(redisKey);            List&lt;Cart&gt; cartList = new ArrayList&lt;&gt;();            //遍历            for (Map.Entry&lt;String, String&gt; entry : entries.entrySet()) {                //获取值                String value = entry.getValue();                //返回的value是json格式的String类型，需要用Gson转换成Cart对象类型                cartList.add(gson.fromJson(value, Cart.class));            }            return cartList;        }    //put设置或者修改值，注意要数据类型全部转换为String类型    opsForHash.put(redisKey, String.valueOf(cart.getProductId()), gson.toJson(cart));    //delete删除值    opsForHash.delete(redisKey, hashKey);    //获取值        //获取一条值        String value = opsForHash.get(redisKey, hashKey);        //获取所有键值对        Map&lt;String, String&gt; entries = opsForHash.entries(redisKey);</code></pre><h4 id="opsForValue-操作字符串"><a href="#opsForValue-操作字符串" class="headerlink" title="opsForValue(操作字符串)"></a>opsForValue(操作字符串)</h4><pre><code>/** * @author lhz **/public class RedisString {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 新增一个字符串类型的值,key是键，value是值。 * * set(K key, V value) */public void set() {    // 存入永久数据    stringRedisTemplate.opsForValue().set(&quot;test2&quot;, &quot;1&quot;);    // 也可以向redis里存入数据和设置缓存时间    stringRedisTemplate.opsForValue().set(&quot;test1&quot;, &quot;hello redis&quot;, 1000, TimeUnit.SECONDS);}/** * 批量插入，key值存在会覆盖原值 * * multiSet(Map&lt;? extends K,? extends V&gt; map) */public void multiSet() {    Map&lt;String,String&gt; map = new HashMap&lt;&gt;(16);    map.put(&quot;testMultiSet1&quot;, &quot;value0&quot;);    map.put(&quot;testMultiSet2&quot;, &quot;value2&quot;);    stringRedisTemplate.opsForValue().multiSet(map);}/** *  批量插入，如果里面的所有key都不存在，则全部插入，返回true，如果其中一个在redis中已存在，全不插入，返回false * *  multiSetIfAbsent(Map&lt;? extends K,? extends V&gt; map) */public void multiSetIfAbsent() {    Map&lt;String,String&gt; map = new HashMap&lt;&gt;(16);    map.put(&quot;testMultiSet4&quot;, &quot;value1&quot;);    map.put(&quot;testMultiSet3&quot;, &quot;value3&quot;);    Boolean absent = stringRedisTemplate.opsForValue().multiSetIfAbsent(map);    System.out.println(absent);}/** * 如果不存在则插入，返回true为插入成功,false失败 * * setIfAbsent(K key, V value) */public void setIfAbsent() {    Boolean absent = stringRedisTemplate.opsForValue().setIfAbsent(&quot;test&quot;, &quot;hello redis&quot;);    System.out.println(absent);}/** * 获取值,key不存在返回null * * get(Object key) */public void get() {    System.out.println(stringRedisTemplate.opsForValue().get(&quot;testMultiSet1&quot;));}/** * 批量获取，key不存在返回null * * multiGet(Collection&lt;K&gt; keys) */public void multiGet() {    List&lt;String&gt; list = stringRedisTemplate.opsForValue().multiGet(Arrays.asList(&quot;test&quot;, &quot;test2&quot;));    assert list != null;    System.out.println(list.toString());}/** * 获取指定字符串的长度。 * * size(K key) */public void getLength() {    Long size = stringRedisTemplate.opsForValue().size(&quot;test&quot;);    System.out.println(size);}/** * 在原有的值基础上新增字符串到末尾。 * * append(K key, String value) */public void append() {    Integer append = stringRedisTemplate.opsForValue().append(&quot;test3&quot;, &quot;database&quot;);    System.out.println(append);}/** * 获取原来key键对应的值并重新赋新值 * * getAndSet(K key, V value) */public void getAndSet() {    String set = stringRedisTemplate.opsForValue().getAndSet(&quot;test&quot;, &quot;set test&quot;);    System.out.println(set);}/** * 获取指定key的值进行减1，如果value不是integer类型，会抛异常，如果key不存在会创建一个，默认value为0 * * decrement(k key) */public void decrement() {    stringRedisTemplate.opsForValue().decrement(&quot;test2&quot;);    stringRedisTemplate.opsForValue().decrement(&quot;test1&quot;);}/** * 获取指定key的值进行加1，如果value不是integer类型，会抛异常，如果key不存在会创建一个，默认value为0 *  * increment(k key) */public void increment() {    stringRedisTemplate.opsForValue().increment(&quot;test2&quot;);    stringRedisTemplate.opsForValue().increment(&quot;test1&quot;);}/** * 删除指定key,成功返回true，否则false *  * delete(k key) */public void delete() {    Boolean delete = stringRedisTemplate.opsForValue().getOperations().delete(&quot;test1&quot;);    System.out.println(delete);}/** * 删除多个key，返回删除key的个数 *  * delete(k ...keys) */public void deleteMulti() {    Long delete = stringRedisTemplate.opsForValue().getOperations().delete(Arrays.asList(&quot;test1&quot;, &quot;test2&quot;));    System.out.println(delete);}}</code></pre><h4 id="opsForList-操作集合"><a href="#opsForList-操作集合" class="headerlink" title="opsForList(操作集合)"></a>opsForList(操作集合)</h4><pre><code>public class RedisList {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 在变量左边添加元素值。如果key不存在会新建，添加成功返回添加后的总个数 *  * leftPush(K key, V value) */public void leftPush() {    Long aLong = stringRedisTemplate.opsForList().leftPush(&quot;list&quot;, &quot;a&quot;);    System.out.println(aLong);}/** * 向左边批量添加参数元素，如果key不存在会新建，添加成功返回添加后的总个数 *  * leftPushAll(K key, V... values) */public void leftPushAll() {    Long pushAll = stringRedisTemplate.opsForList().leftPushAll(&quot;list&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);    System.out.println(pushAll);}/** * 向集合最右边添加元素。如果key不存在会新建，添加成功返回添加后的总个数 *  * rightPush(K key, V value) */public void rightPush() {    Long aLong = stringRedisTemplate.opsForList().rightPush(&quot;list2&quot;, &quot;a&quot;);    System.out.println(aLong);}/** * 如果存在集合则添加元素。 *  * leftPushIfPresent(K key, V value) */public void leftPushIfPresent() {    Long aLong = stringRedisTemplate.opsForList().leftPushIfPresent(&quot;list&quot;, &quot;h&quot;);    System.out.println(aLong);}/** * 向右边批量添加元素。返回当前集合元素总个数 *  * rightPushAll(K key, V... values) */public void rightPushAll() {    Long aLong = stringRedisTemplate.opsForList().rightPushAll(&quot;list2&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);    System.out.println(aLong);}/** * 向已存在的集合中添加元素。返回集合总元素个数 *  * rightPushIfPresent(K key, V value) */public void rightPushIfPresent() {    Long aLong = stringRedisTemplate.opsForList().rightPushIfPresent(&quot;list&quot;, &quot;e&quot;);    System.out.println(aLong);}/** * 获取集合长度 *  * size(K key) */public void size() {    Long size = stringRedisTemplate.opsForList().size(&quot;list2&quot;);    System.out.println(size);}/** * 移除集合中的左边第一个元素。返回删除的元素，如果元素为空，该集合会自动删除 *  * leftPop(K key) */public void leftPop() {    String pop = stringRedisTemplate.opsForList().leftPop(&quot;list2&quot;);    System.out.println(pop);}/** * 移除集合中左边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。 *  * leftPop(K key, long timeout, TimeUnit unit) */public void leftPopWait() {    String pop = stringRedisTemplate.opsForList().leftPop(&quot;list2&quot;, 10, TimeUnit.SECONDS);    System.out.println(pop);}/** * 移除集合中右边的元素。返回删除的元素，如果元素为空，该集合会自动删除 *  * rightPop(K key) */public void rightPop() {    String pop = stringRedisTemplate.opsForList().rightPop(&quot;list2&quot;);    System.out.println(pop);}/** * 移除集合中右边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。 *  * rightPop(K key, long timeout, TimeUnit unit) */public void rightPopWait() {    String pop = stringRedisTemplate.opsForList().rightPop(&quot;list2&quot;, 10, TimeUnit.SECONDS);    System.out.println(pop);}/** * 移除第一个集合右边的一个元素，插入第二个集合左边插入这个元素 *  * rightPopAndLeftPush(K sourceKey, K destinationKey) */public void rightPopAndLeftPush() {    String s = stringRedisTemplate.opsForList().rightPopAndLeftPush(&quot;list2&quot;, &quot;list3&quot;);    System.out.println(s);}/** * 在集合的指定位置插入元素,如果指定位置已有元素，则覆盖，没有则新增，超过集合下标+n则会报错。 *  * set(K key, long index, V value) */public void set() {    stringRedisTemplate.opsForList().set(&quot;list2&quot;, 2, &quot;w&quot;);}/** * 从存储在键中的列表中删除等于值的元素的第一个计数事件。count&gt; 0：删除等于从左到右移动的值的第一个元素； * count&lt; 0：删除等于从右到左移动的值的第一个元素；count = 0：删除等于value的所有元素 *  * remove(K key, long count, Object value) */public void remove() {    Long remove = stringRedisTemplate.opsForList().remove(&quot;list2&quot;, 2, &quot;w&quot;);    System.out.println(remove);}/** * 截取集合元素长度，保留长度内的数据。 *  * trim(K key, long start, long end) */public void trim() {    stringRedisTemplate.opsForList().trim(&quot;list2&quot;, 0, 3);}/** * 获取集合指定位置的值。 *  * index(K key, long index) */public void index() {    Object listValue = stringRedisTemplate.opsForList().index(&quot;list2&quot;, 3);    System.out.println(listValue);}/** * 获取指定区间的值。 *  * range(K key, long start, long end) */public void range() {    List&lt;String&gt; list = stringRedisTemplate.opsForList().range(&quot;list&quot;, 0, -1);    System.out.println(list);}/** * 删除指定集合,返回true删除成功 *  * delete(K key) */public void delete() {    Boolean delete = stringRedisTemplate.opsForList().getOperations().delete(&quot;list2&quot;);    System.out.println(delete);}}</code></pre><h4 id="opsForHash-操作hashMap"><a href="#opsForHash-操作hashMap" class="headerlink" title="opsForHash(操作hashMap)"></a>opsForHash(操作hashMap)</h4><pre><code>public class RedisHash {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 新增hashMap值 *  * put(H key, HK hashKey, HV value) */public void put() {    stringRedisTemplate.opsForHash().put(&quot;hash&quot;,&quot;hash-key&quot;,&quot;hash-value&quot;);    stringRedisTemplate.opsForHash().put(&quot;hash&quot;,&quot;hash-key2&quot;,&quot;hash-value2&quot;);}/** * 以map集合的形式添加键值对 *  * putAll(H key, Map&lt;? extends HK,? extends HV&gt; m) */public void putAll() {    Map&lt;String, String&gt; map = new HashMap&lt;&gt;(16);    map.put(&quot;hash-key3&quot;, &quot;value3&quot;);    map.put(&quot;hash-key4&quot;, &quot;value4&quot;);    stringRedisTemplate.opsForHash().putAll(&quot;hash&quot;, map);}/** * 如果变量值存在，在变量中可以添加不存在的的键值对，如果变量不存在，则新增一个变量，同时将键值对添加到该变量。添加成功返回true否则返回false *  * putIfAbsent(H key, HK hashKey, HV value) */public void putIfAbsent() {    Boolean absent = stringRedisTemplate.opsForHash().putIfAbsent(&quot;hash&quot;, &quot;hash-key&quot;, &quot;value1&quot;);    Boolean absent2 = stringRedisTemplate.opsForHash().putIfAbsent(&quot;hash&quot;, &quot;hash-key5&quot;, &quot;value5&quot;);    System.out.println(absent);    System.out.println(absent2);}/** * 获取指定变量中的hashMap值。 *  * values(H Key) */public void values() {    List&lt;Object&gt; values = stringRedisTemplate.opsForHash().values(&quot;hash2&quot;);    System.out.println(values.toString());}/** * 获取变量中的键值对。 *  * entries(H key) */public void entries() {    Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(&quot;hash&quot;);    System.out.println(entries.toString());}/** * 获取变量中的指定map键是否有值,如果存在该map键则获取值，没有则返回null。 *  * get(H key, Object hashKey) */public void get() {    Object value = stringRedisTemplate.opsForHash().get(&quot;hash&quot;, &quot;hash-key&quot;);    System.out.println(value);}/** * 获取变量中的键。 *  * keys(H key) */public void keys() {    Set&lt;Object&gt; keys = stringRedisTemplate.opsForHash().keys(&quot;hash&quot;);    System.out.println(keys.toString());}/** *  获取变量的长度 *   *  size(H key) */public void size() {    Long size = stringRedisTemplate.opsForHash().size(&quot;hash&quot;);    System.out.println(size);}/** * 使变量中的键以long值的大小进行自增长。值必须为Integer类型,否则异常 *  * increment(H key, HK hashKey, long data) */public void increment() {    Long increment = stringRedisTemplate.opsForHash().increment(&quot;hash&quot;, &quot;hash-key2&quot;, 1);    System.out.println(increment);}/** * 以集合的方式获取变量中的值。 *  * multiGet(H key, Collection&lt;HK&gt; hashKeys) */public void multiGet() {    List&lt;Object&gt; values = stringRedisTemplate.opsForHash().multiGet(&quot;hash&quot;, Arrays.asList(&quot;hash-key&quot;, &quot;hash-key2&quot;));    System.out.println(values.toString());}/** * 匹配获取键值对，ScanOptions.NONE为获取全部键对，ScanOptions.scanOptions().match(&quot;hash-key2&quot;).build()匹配获取键位map1的键值对,不能模糊匹配。 *  * scan(H key, ScanOptions options) */public void scan() {    Cursor&lt;Map.Entry&lt;Object, Object&gt;&gt; scan = stringRedisTemplate.opsForHash().scan(&quot;hash&quot;, ScanOptions.NONE);    while (scan.hasNext()) {        Map.Entry&lt;Object, Object&gt; next = scan.next();        System.out.println(next.getKey() + &quot;----&gt;&quot; + next.getValue());    }}/** * 删除变量中的键值对，可以传入多个参数，删除多个键值对。返回删除成功数量 *  * delete(H key, Object... hashKeys) */public void delete() {    Long delete = stringRedisTemplate.opsForHash().delete(&quot;hash&quot;, &quot;hash-key&quot;, &quot;hash-key1&quot;);    System.out.println(delete);}}</code></pre><h4 id="opsForSet-操作有序set集合"><a href="#opsForSet-操作有序set集合" class="headerlink" title="opsForSet(操作有序set集合)"></a>opsForSet(操作有序set集合)</h4><pre><code>public class RedisSet {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 向变量中批量添加值。返回添加的数量 * * add(K key, V... values) */public void add() {    Long add = stringRedisTemplate.opsForSet().add(&quot;set&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);    System.out.println(add);}/** * 获取变量的值 * * members(K key) */public void members() {    Set&lt;String&gt; set = stringRedisTemplate.opsForSet().members(&quot;set&quot;);    System.out.println(set);}/** * 获取变量中值得长度 * * size(k key) */public void size() {    Long size = stringRedisTemplate.opsForSet().size(&quot;set&quot;);    System.out.println(size);}/** * 随机获取变量中的某个元素 * * randomMember(k key) */public void randomMember() {    String member = stringRedisTemplate.opsForSet().randomMember(&quot;set&quot;);    System.out.println(member);}/** * 随机获取变量中指定个数的元素 * * randomMembers(k key, long count) */public void randomMembers() {    List&lt;String&gt; members = stringRedisTemplate.opsForSet().randomMembers(&quot;set&quot;, 2);    System.out.println(members);}/** * 检查给定的元素是否在变量中,true为存在 * * isMember(k key, object value) */public void isMember() {    Boolean member = stringRedisTemplate.opsForSet().isMember(&quot;set&quot;, &quot;b&quot;);    System.out.println(member);}/** * 转义变量的元素值到另一个变量中 * * move(k key, v value, k targetKey) */public void move() {    Boolean move = stringRedisTemplate.opsForSet().move(&quot;set&quot;, &quot;b&quot;, &quot;set2&quot;);    System.out.println(move);}/** * 弹出变量中的元素。当元素全部弹完,变量也会删除 * * pop(k key) */public void pop() {    String pop = stringRedisTemplate.opsForSet().pop(&quot;set&quot;);    System.out.println(pop);}/** * 批量删除变量中的元素,返回删除的数量 * * remove(k key, v ...values) */public void remove() {    Long remove = stringRedisTemplate.opsForSet().remove(&quot;set2&quot;, &quot;b&quot;);    System.out.println(remove);}/** * 匹配获取键值对，ScanOptions.NONE为获取全部键值对；ScanOptions.scanOptions().match(&quot;C&quot;).build()匹配获取键位map1的键值对,不能模糊匹配。 * * scan(K key, ScanOptions options) */public void scan() {    Cursor&lt;String&gt; set = stringRedisTemplate.opsForSet().scan(&quot;set&quot;, ScanOptions.NONE);    while (set.hasNext()) {        String next = set.next();        System.out.println(next);    }}/** * 通过集合求差值。 * * difference(k key, k otherKey) */public void difference() {    Set&lt;String&gt; difference = stringRedisTemplate.opsForSet().difference(&quot;set&quot;, &quot;set2&quot;);    System.out.println(difference);}/** * 将求出来的差值元素保存 * * differenceAndStore(K key, K otherKey, K targetKey) */public void differenceAndStore() {    Long aLong = stringRedisTemplate.opsForSet().differenceAndStore(&quot;set&quot;, &quot;set2&quot;, &quot;set3&quot;);    System.out.println(aLong);}/** * 获取去重的随机元素 * * distinctRandomMembers(K key, long count) */public void distinctRandomMembers() {    Set&lt;String&gt; set = stringRedisTemplate.opsForSet().distinctRandomMembers(&quot;set&quot;, 2);    System.out.println(set);}/** * 获取两个变量中的交集 * * intersect(K key, K otherKey) */public void intersect() {    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(&quot;set&quot;, &quot;set2&quot;);    System.out.println(intersect);}/** * 获取2个变量交集后保存到最后一个变量上。 * * intersectAndStore(K key, K otherKey, K targetKey) */public void intersectAndStore() {    Long aLong = stringRedisTemplate.opsForSet().intersectAndStore(&quot;set&quot;, &quot;set2&quot;, &quot;set3&quot;);    System.out.println(aLong);}/** * 获取两个变量的合集 * * union(K key, K otherKey) */public void union() {    Set&lt;String&gt; union = stringRedisTemplate.opsForSet().union(&quot;set&quot;, &quot;set2&quot;);    System.out.println(union);}/** * 获取两个变量合集后保存到另一个变量中 * * unionAndStore(K key, K otherKey, K targetKey) */public void unionAndStore() {    Long aLong = stringRedisTemplate.opsForSet().unionAndStore(&quot;set&quot;, &quot;set2&quot;, &quot;set3&quot;);    System.out.println(aLong);}}</code></pre><h4 id="opsForZset（操作有序set集合）"><a href="#opsForZset（操作有序set集合）" class="headerlink" title="opsForZset（操作有序set集合）"></a>opsForZset（操作有序set集合）</h4><pre><code>public class RedisZSet {    @Resource    private StringRedisTemplate stringRedisTemplate;/** * 添加元素到变量中同时指定元素的分值。 * * add(K key, V value, double score) */public void add() {    Boolean add = stringRedisTemplate.opsForZSet().add(&quot;zset&quot;, &quot;a&quot;, 1);    System.out.println(add);}/** * 通过TypedTuple方式新增数据。 * * add(K key, Set&lt;ZSetOperations.TypedTuple&lt;V&gt;&gt; tuples) */public void addByTypedTuple() {    ZSetOperations.TypedTuple&lt;String&gt; typedTuple1 = new DefaultTypedTuple&lt;&gt;(&quot;E&quot;, 2.0);    ZSetOperations.TypedTuple&lt;String&gt; typedTuple2 = new DefaultTypedTuple&lt;&gt;(&quot;F&quot;, 3.0);    ZSetOperations.TypedTuple&lt;String&gt; typedTuple3 = new DefaultTypedTuple&lt;&gt;(&quot;G&quot;, 5.0);    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTupleSet = new HashSet&lt;&gt;();    typedTupleSet.add(typedTuple1);    typedTupleSet.add(typedTuple2);    typedTupleSet.add(typedTuple3);    Long zset = stringRedisTemplate.opsForZSet().add(&quot;zset&quot;, typedTupleSet);    System.out.println(zset);}/** * 获取指定区间的元素 * * range(k key, long start, long end) */public void range() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().range(&quot;zset&quot;, 0, -1);    System.out.println(zset);}/** * 用于获取满足非score的排序取值。这个排序只有在有相同分数的情况下才能使用，如果有不同的分数则返回值不确定。 * * rangeByLex(K key, RedisZSetCommands.Range range) */public void rangeByLex() {    Set&lt;String&gt; rangeByLex = stringRedisTemplate.opsForZSet().rangeByLex(&quot;zset&quot;, RedisZSetCommands.Range.range().lt(&quot;E&quot;));    System.out.println(rangeByLex);}/** * 用于获取满足非score的设置下标开始的长度排序取值。 * * rangeByLex(k key, range range, limit limit) */public void rangeByLexAndLimit() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().rangeByLex(&quot;zset&quot;, RedisZSetCommands.Range.range().lt(&quot;E&quot;),            RedisZSetCommands.Limit.limit().offset(1).count(2));    System.out.println(zset);}/** * 根据设置的score获取区间值。 * * rangeByScore(K key, double min, double max) */public void rangeByScore() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().rangeByScore(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 获取RedisZSetCommands.Tuples的区间值。 * * rangeWithScores(K key, long start, long end) */public void rangeWithScores() {    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zset = stringRedisTemplate.opsForZSet().rangeWithScores(&quot;zset&quot;, 1, 3);    assert zset != null;    for (ZSetOperations.TypedTuple&lt;String&gt; next : zset) {        String value = next.getValue();        Double score = next.getScore();        System.out.println(value + &quot;--&gt;&quot; + score);    }}/** * 获取区间值的个数。 * * count(k key, double min, double max) */public void count() {    Long zset = stringRedisTemplate.opsForZSet().count(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 获取变量中指定元素的索引,下标开始为0 * * rank(k key, object o) */public void rank() {    Long rank = stringRedisTemplate.opsForZSet().rank(&quot;zset&quot;, &quot;a&quot;);    System.out.println(rank);}/** * 匹配获取键值对，ScanOptions.NONE为获取全部键值对；ScanOptions.scanOptions().match(&quot;C&quot;).build()匹配获取键位map1的键值对,不能模糊匹配。 * * scan(K key, ScanOptions options) */public void scan() {    Cursor&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zset = stringRedisTemplate.opsForZSet().scan(&quot;zset&quot;, ScanOptions.NONE);    while (zset.hasNext()) {        ZSetOperations.TypedTuple&lt;String&gt; next = zset.next();        System.out.println(next.getValue() + &quot;--&gt;&quot; + next.getScore());    }}/** * 获取指定元素的分值 * * score(k key, object o) */public void score() {    Double score = stringRedisTemplate.opsForZSet().score(&quot;zset&quot;, &quot;a&quot;);    System.out.println(score);}/** * 获取变量中元素的个数 * * zCard(k key) */public void zCard() {    Long zset = stringRedisTemplate.opsForZSet().zCard(&quot;zset&quot;);    System.out.println(zset);}/** * 修改变量中元素的分值 * * incrementScore(K key, V value, double delta) */public void incrementScore() {    Double score = stringRedisTemplate.opsForZSet().incrementScore(&quot;zset&quot;, &quot;a&quot;, 2);    System.out.println(score);}/** * 索引倒序排列指定区间的元素 * * reverseRange(K key, long start, long end) */public void reverseRange() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().reverseRange(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 倒序排列指定分值区间的元素 * * reverseRangeByScore(K key, double min, double max) */public void reverseRangeByScore() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().reverseRangeByScore(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 倒序排序获取RedisZSetCommands.Tuples的分值区间值 * * reverseRangeByScore(K key, double min, double max, long offset, long count) */public void reverseRangeByScoreLength() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().reverseRangeByScore(&quot;zset&quot;, 1, 3, 1, 2);    System.out.println(zset);}/** * 倒序排序获取RedisZSetCommands.Tuples的分值区间值。 * * reverseRangeByScoreWithScores(K key, double min, double max) */public void reverseRangeByScoreWithScores() {    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zset = stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(&quot;zset&quot;, 1, 5);    assert zset != null;    zset.iterator().forEachRemaining(e-&gt; System.out.println(e.getValue() + &quot;---&gt;&quot; + e.getScore()));}/** * 获取倒序排列的索引值 * * reverseRank(k key, object o) */public void reverseRank() {    Long aLong = stringRedisTemplate.opsForZSet().reverseRank(&quot;zset&quot;, &quot;a&quot;);    System.out.println(aLong);}/** * 获取2个变量的交集存放到第3个变量里面。 * * intersectAndStore(K key, K otherKey, K destKey) */public void intersectAndStore() {    Long aLong = stringRedisTemplate.opsForZSet().intersectAndStore(&quot;zset&quot;, &quot;zset2&quot;, &quot;zset3&quot;);    System.out.println(aLong);}/** * 获取2个变量的合集存放到第3个变量里面。 返回操作的数量 * * unionAndStore(K key, K otherKey, K destKey) */public void unionAndStore() {    Long aLong = stringRedisTemplate.opsForZSet().unionAndStore(&quot;zset&quot;, &quot;zset2&quot;, &quot;zset3&quot;);    System.out.println(aLong);}/** * 批量移除元素根据元素值。返回删除的元素数量 * * remove(K key, Object... values) */public void remove() {    Long remove = stringRedisTemplate.opsForZSet().remove(&quot;zset&quot;, &quot;a&quot;, &quot;b&quot;);    System.out.println(remove);}/** * 根据分值移除区间元素。返回删除的数量 * * removeRangeByScore(k key, double min, double max) */public void removeRangeByScore() {    Long zset = stringRedisTemplate.opsForZSet().removeRangeByScore(&quot;zset&quot;, 1, 3);    System.out.println(zset);}/** * 根据索引值移除区间元素。返回移除的元素集合 * * removeRange(K key, long start, long end) */public void removeRange() {    Set&lt;String&gt; zset = stringRedisTemplate.opsForZSet().reverseRange(&quot;zset&quot;, 0, 4);    System.out.println(zset);}}</code></pre><h3 id="阿里云服务器上部署redis-centos7-7"><a href="#阿里云服务器上部署redis-centos7-7" class="headerlink" title="阿里云服务器上部署redis(centos7.7)"></a>阿里云服务器上部署redis(centos7.7)</h3><ul><li>下载包</li></ul><pre><code>    wget wget http://download.redis.io/releases/redis-5.0.8.tar.gz</code></pre><ul><li>解压到指定路径</li></ul><pre><code>    tar -zxvf redis-5.0.8.tar.gz -C /usr/local</code></pre><ul><li>编译</li></ul><pre><code>    cd /usr/local/redis-5.0.8    make</code></pre><ul><li>编译成功将会出现</li></ul><pre><code>    Hint: It&#39;s a good idea to run &#39;make test&#39; 😉    make[1]: Leaving directory `/usr/local/redis-5.0.8/src&#39;</code></pre><ul><li>然后执行下面命令</li></ul><pre><code>    cd /usr/local/redis-5.0.8/src    make install</code></pre><ul><li>成功</li></ul><pre><code>    Hint: It&#39;s a good idea to run &#39;make test&#39; 😉    INSTALL install    INSTALL install    INSTALL install    INSTALL install    INSTALL install</code></pre><ul><li>修改配置文件</li></ul><pre><code>    vim /usr/local/redis-5.0.8/redis.conf    protected-mode no # 关闭保护模式    daemonize yes     # 守护进程模式开启    bind 127.0.0.1  注释掉，不然远程连接不上</code></pre><ul><li>千万记住修改完配置文件后要重启，不然不会生效！！！踩了好大的坑</li></ul><pre><code>    //以下命令一起输入    /usr/local/redis-5.0.8/src/redis-server &amp;    /usr/local/redis-5.0.8/redis.conf</code></pre><ul><li>启动服务端和客户端</li></ul><pre><code>    /usr/local/redis-5.0.8/src/redis-server    /usr/local/redis-5.0.8/src/redis-cli</code></pre><ul><li>后台启动服务端</li></ul><pre><code>    /usr/local/redis-5.0.8/src/redis-server &amp;</code></pre><ul><li>查看redis进程</li></ul><pre><code>    ps -ef | grep redis</code></pre><ul><li>密码登录客户端</li></ul><pre><code>    cd /usr/local/redis-5.0.8/src    ./redis-cli -h 127.0.0.1 -p 6379 -a 980508</code></pre><ul><li>然后就用redis可视化工具测试远程连接，记住要用密码连接</li></ul>]]></content>
      
      
      <categories>
          
          <category> nosql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router路由</title>
      <link href="/2020/06/05/vue-router/"/>
      <url>/2020/06/05/vue-router/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌，对于一个vue开发的spa单页面而言，路由的重要性不言而喻</p><h2 id="vue-router是什么"><a href="#vue-router是什么" class="headerlink" title="vue-router是什么"></a>vue-router是什么</h2><ul><li>这里的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。再通俗的说，vue-router就是WebApp的链接路径管理系统。<br>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。</li><li>至于我们为啥不能用a标签，这是因为用Vue做的都是单页应用（当你的项目准备打包时，运行npm run build时，就会生成dist文件夹，这里面只有静态资源和一个index.html页面），所以你写的<a></a>标签是不起作用的，你必须使用vue-router来进行管理。</li></ul><h2 id="vue-router使用方式"><a href="#vue-router使用方式" class="headerlink" title="vue-router使用方式"></a>vue-router使用方式</h2><ul><li>下载 </li></ul><pre><code>    npm i vue-router --save</code></pre><ul><li>创建router.js文件</li></ul><pre><code>import Router from &#39;vue-router&#39; //导入插件Vue.use(Router);    //安装插件</code></pre><ul><li>创建路由对象并配置路由规则 let router = new VueRouter({routes:[{path:’/home’,component:Home}]});</li></ul><pre><code>    export default new Router({        routes: [    //配置路由，这里是个数组            {       //每一个链接都是一个对象                path: &#39;/&#39;,  //链接路径                name: &#39;home&#39;,   //路由名称                redirect: &#39;/index&#39;,     //重定向                component: Home,    //对应的组件模板                children: [        //子路由                {                    path: &#39;product/:id&#39;,    // /:id表示动态路由 动态传id                    name: &#39;product&#39;,                    component: Product,                },                ]            },        ]    })</code></pre><ul><li>动态路由的取值：this.$route.params.id</li><li>在main.js中引入 router.js</li><li>将其路由对象传递给main.js中Vue的实例，options中加入 router:router</li><li>在app.vue中留坑 <router-view></router-view></li></ul><pre><code>    //app.vue中    &lt;template&gt;        &lt;div&gt;            &lt;!-- 留坑，非常重要 --&gt;            &lt;router-view&gt;&lt;/router-view&gt;        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default {            data(){                return {}            }        }    &lt;/script&gt;</code></pre><h2 id="使用路由模块来实现页面跳转的方式"><a href="#使用路由模块来实现页面跳转的方式" class="headerlink" title="使用路由模块来实现页面跳转的方式"></a>使用路由模块来实现页面跳转的方式</h2><ul><li>1：直接修改地址栏</li><li>2：this.$router.push(‘路由地址’)</li><li>3：<router-link to="路由地址"></router-link></li></ul><h3 id="路由携带参数跳转页面"><a href="#路由携带参数跳转页面" class="headerlink" title="路由携带参数跳转页面"></a>路由携带参数跳转页面</h3><h4 id="使用Query实现路由传参（url中显示参数）"><a href="#使用Query实现路由传参（url中显示参数）" class="headerlink" title="使用Query实现路由传参（url中显示参数）"></a>使用Query实现路由传参（url中显示参数）</h4><pre><code>    //携带参数跳转到订单支付页面    this.$router.push({      path:&#39;/order/pay&#39;,    //路由路径      query:{        orderNo : res.orderNo   //携带参数      }    })</code></pre><ul><li>跳转过去url是携带参数的</li></ul><pre><code>    http://localhost:8080/#/order/pay?orderNo=1589864016971</code></pre><ul><li>获取参数</li></ul><pre><code>    this.$route.query.orderNo</code></pre><h3 id="params传参（url中不显示参数）"><a href="#params传参（url中不显示参数）" class="headerlink" title="params传参（url中不显示参数）"></a>params传参（url中不显示参数）</h3><ul><li>注意：上述这种利用params不显示url传参的方式会导致在刷新页面的时候，传递的值会丢失,这个可以用来判断是从哪个页面跳转过来</li></ul><pre><code>    this.$router.push({        name: &#39;index&#39;,        params:{          from: &#39;login&#39;        }      });</code></pre><ul><li>获取参数</li></ul><pre><code>    this.$route.params.from</code></pre><ul><li>判断</li></ul><pre><code>    //只有从登陆页面跳转过来的时候才会获取购物车数量    if (this.$route.params.from &amp;&amp; this.$route.params.from == &#39;login&#39;) {        this.getCartCount();    }</code></pre><h2 id="路由懒加载vue-router"><a href="#路由懒加载vue-router" class="headerlink" title="路由懒加载vue-router"></a>路由懒加载vue-router</h2><h3 id="什么是懒加载？"><a href="#什么是懒加载？" class="headerlink" title="什么是懒加载？"></a>什么是懒加载？</h3><ul><li>懒加载也就是延迟加载或者按需加载，即在需要的时候进行加载。</li></ul><h3 id="为什么在Vue路由中使用懒加载？"><a href="#为什么在Vue路由中使用懒加载？" class="headerlink" title="为什么在Vue路由中使用懒加载？"></a>为什么在Vue路由中使用懒加载？</h3><ul><li>像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，时间过长，会出啊先长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时；</li><li>简单的说就是：进入首页不用一次加载过多资源造成用时过长；</li></ul><h3 id="如何实现懒加载"><a href="#如何实现懒加载" class="headerlink" title="如何实现懒加载"></a>如何实现懒加载</h3><ul><li>方案一： 在路由文件中使用 reslove=&gt;require([“./pages/HelloWorld.vue”],reslove) 来引入页面模板；</li></ul><pre><code>    export default new Router({        routes: [    //配置路由，这里是个数组            {       //每一个链接都是一个对象                path: &#39;/&#39;,  //链接路径                name: &#39;home&#39;,   //路由名称                redirect: &#39;/index&#39;,     //重定向                component: Home,    //对应的组件模板                children: [        //子路由                    {                        path: &#39;product/:id&#39;,        //动态路由 /:表示动态传id                        name: &#39;product&#39;,                        component: resolve =&gt; require([&#39;./pages/product.vue&#39;], resolve),                    },                    {                        path: &#39;detail/:id&#39;,                        name: &#39;detail&#39;,                        component: resolve =&gt; require([&#39;./pages/detail.vue&#39;], resolve),                    }                ]            ]        })</code></pre><ul><li>方案二：在路由文件中使用  ()=&gt;import(“../components/HelloWorld.vue”) 来引入组件模版；</li><li>但是这个方案用的是es7的语法，可能需要下载一个插件</li></ul><pre><code>    npm install @babel/plugin-syntax-dynamic-import    export default new Router({        routes: [    //配置路由，这里是个数组            {       //每一个链接都是一个对象                path: &#39;/&#39;,  //链接路径                name: &#39;home&#39;,   //路由名称                redirect: &#39;/index&#39;,     //重定向                component: Home,    //对应的组件模板                children: [        //子路由                    {                        path: &#39;product/:id&#39;,        //动态路由 /:表示动态传id                        name: &#39;product&#39;,                        component: () =&gt; import(&#39;./pages/product.vue&#39;)                    },                    {                        path: &#39;detail/:id&#39;,                        name: &#39;detail&#39;,                        component: () =&gt; import(&#39;./pages/detail.vue&#39;)                    }                ]            ]        })</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis三剑客</title>
      <link href="/2020/05/23/mybatis-san-jian-ke/"/>
      <url>/2020/05/23/mybatis-san-jian-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>mybatis用起来非常方便，但是每次都要写实体类，接口，mapping映射文件又显得有些麻烦，那么有没有帮我们生成这些生成这些文件的东西呢，当然有，那就是mybatis三剑客的其中之一mybatis-generator，当然还有两个可以帮助我们是使用mybatis的插件就在后面慢慢介绍</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>Mabatis三剑客分别是：mybatis-generator、mybatis-plugin、mybatis-pagehelper</li></ul><h2 id="一-mybatis-generator"><a href="#一-mybatis-generator" class="headerlink" title="一. mybatis-generator"></a>一. mybatis-generator</h2><ul><li>根据我们的数据库自动生成pojo、dao和xml文件<br>pojo里面放的是跟数据库字段一一对应的对象、dao层是接口，供service使用，xml是这个dao层接口的实现，sql语句都写在xml里</li><li>原理就是连接数据库，获取表机构，生成文件</li><li>如图生成这三个文件<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/39.png" alt=""></li></ul><ul><li>首先引入配置文件，这里用的是1.3.7版本</li></ul><pre><code>    &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.7&lt;/version&gt;            &lt;!--                如果存在文件就不会在生成，只会覆盖--&gt;            &lt;configuration&gt;                &lt;overwrite&gt;true&lt;/overwrite&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;</code></pre><ul><li>然后在main包的resource文件夹下添加文件generatorConfig.xml,如图</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/38.png" alt=""></p><h3 id="generatorConfig-xml详解"><a href="#generatorConfig-xml详解" class="headerlink" title="generatorConfig.xml详解"></a>generatorConfig.xml详解</h3><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;!DOCTYPE generatorConfiguration      PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;    &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;    &lt;!-- 配置生成器 --&gt;    &lt;generatorConfiguration&gt;    &lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用${propertyKey}的方式来引用配置项        resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties                url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.        注意，两个属性只能选址一个;        另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用    &lt;properties resource=&quot;&quot; url=&quot;&quot; /&gt;     --&gt;     &lt;!-- 在MBG工作的时候，需要额外加载的依赖包         location属性指明加载jar/zip包的全路径    &lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&gt;      --&gt;    &lt;!--         context:生成一组对象的环境         id:必选，上下文id，用于在生成错误时提示        defaultModelType:指定生成对象的样式            1，conditional：类似hierarchical；            2，flat：所有内容（主键，blob）等全部生成在一个对象中；            3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)        targetRuntime:            1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；            2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；        introspectedColumnImpl：类全限定名，用于扩展MBG    --&gt;    &lt;context id=&quot;mysql&quot; defaultModelType=&quot;hierarchical&quot; targetRuntime=&quot;MyBatis3Simple&quot; &gt;        &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；            一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖         --&gt;        &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;false&quot;/&gt;        &lt;!-- 生成的Java文件的编码 --&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;!-- 格式化java代码 --&gt;        &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;        &lt;!-- 格式化XML代码 --&gt;        &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;        &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;!-- 必须要有的，使用这个配置链接数据库            @TODO:是否可以扩展         --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:///pss&quot; userId=&quot;root&quot; password=&quot;admin&quot;&gt;            &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;        &lt;/jdbcConnection&gt;        &lt;!-- java类型处理器             用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；            注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型；         --&gt;        &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt;            &lt;!--                 true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型                false：默认,                    scale&gt;0;length&gt;18：使用BigDecimal;                    scale=0;length[10,18]：使用Long；                    scale=0;length[5,9]：使用Integer；                    scale=0;length&lt;5：使用Short；             --&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- java模型创建器，是必须要的元素            负责：1，key类（见context的defaultModelType）；2，java类；3，查询类            targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；            targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录         --&gt;        &lt;javaModelGenerator targetPackage=&quot;com._520it.mybatis.domain&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;!--  for MyBatis3/MyBatis3Simple                自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；             --&gt;            &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;!-- for MyBatis3 / MyBatis3Simple                是否创建一个不可变的类，如果为true，                那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类             --&gt;            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;            &lt;!-- 设置一个根对象，                如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项                注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：                    1，属性名相同，类型相同，有相同的getter/setter方法；             --&gt;            &lt;property name=&quot;rootClass&quot; value=&quot;com._520it.mybatis.domain.BaseDomain&quot;/&gt;            &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- 生成SQL map的XML文件生成器，            注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），                或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置            targetPackage/targetProject:同javaModelGenerator         --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口             targetPackage/targetProject:同javaModelGenerator            type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：                1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；                2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；                3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；            注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER        --&gt;        &lt;javaClientGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; type=&quot;ANNOTATEDMAPPER&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查            &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;             --&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素            选择的table会生成一下文件：            1，SQL map文件            2，生成一个主键类；            3，除了BLOB和主键的其他字段的类；            4，包含BLOB的类；            5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；            6，Mapper接口（可选）            tableName（必要）：要生成对象的表名；            注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会                根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：                1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；                2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；                3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；                4，否则，使用指定的大小写格式查询；            另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；            这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式；            可选：            1，schema：数据库的schema；            2，catalog：数据库的catalog；            3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName            4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；            5，enableInsert（默认true）：指定是否生成insert语句；            6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；            7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；            8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；            9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；            10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；            11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；            12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；            13，modelType：参考context元素的defaultModelType，相当于覆盖；            14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）            15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性            注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；         --&gt;        &lt;table tableName=&quot;userinfo&quot; &gt;            &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;            &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;            &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt;            &lt;property name=&quot;ignoreQualifiersAtRuntime&quot; value=&quot;false&quot;/&gt;            &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;            &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;            &lt;property name=&quot;modelOnly&quot; value=&quot;false&quot;/&gt;            &lt;!-- 参考 javaModelGenerator 的 rootClass 属性             &lt;property name=&quot;rootClass&quot; value=&quot;&quot;/&gt;             --&gt;            &lt;!-- 参考javaClientGenerator 的  rootInterface 属性            &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;            --&gt;            &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog             &lt;property name=&quot;runtimeCatalog&quot; value=&quot;&quot;/&gt;            --&gt;            &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema             &lt;property name=&quot;runtimeSchema&quot; value=&quot;&quot;/&gt;            --&gt;            &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename             &lt;property name=&quot;runtimeTableName&quot; value=&quot;&quot;/&gt;            --&gt;            &lt;!-- 注意，该属性只针对MyBatis3Simple有用；                如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；             --&gt;            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;age desc,username asc&quot;/&gt;            &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;            &lt;!-- generatedKey用于生成生成主键的方法，                如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选                column:主键的列名；                sqlStatement：要生成的selectKey语句，有以下可选项：                    Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()                    DB2       :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()                    DB2_MF    :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1                    Derby      :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()                    HSQLDB      :相当于selectKey的SQL为：CALL IDENTITY()                    Informix  :相当于selectKey的SQL为：select dbinfo(&#39;sqlca.sqlerrd1&#39;) from systables where tabid=1                    MySql      :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()                    SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()                    SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY                    JDBC      :相当于在生成的insert元素上添加useGeneratedKeys=&quot;true&quot;和keyProperty属性            &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot;/&gt;             --&gt;            &lt;!--                 该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，                比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；                那么就可以设置searchString为&quot;^CUST_&quot;，并使用空白替换，那么生成的Customer对象中的属性名称就不是                custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；                注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，                如果使用了columnOverride元素，该属性无效；            &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt;             --&gt;             &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；                 column:要重新设置的列名；                 注意，一个table元素中可以有多个columnOverride元素哈~              --&gt;             &lt;columnOverride column=&quot;username&quot;&gt;                 &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;                 &lt;property name=&quot;property&quot; value=&quot;userName&quot;/&gt;                 &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名                 &lt;property name=&quot;javaType&quot; value=&quot;&quot;/&gt;                  --&gt;                 &lt;!-- jdbcType用于指定该列的JDBC类型                  &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;                  --&gt;                 &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名                     注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler                     只会生成类似：where id = #{id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler}的参数描述                 &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;                 --&gt;                 &lt;!-- 参考table元素的delimitAllColumns配置，默认为false                 &lt;property name=&quot;delimitedColumnName&quot; value=&quot;&quot;/&gt;                  --&gt;             &lt;/columnOverride&gt;             &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现                  column:指定要忽略的列的名字；                 delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false                 注意，一个table元素中可以有多个ignoreColumn元素             &lt;ignoreColumn column=&quot;deptId&quot; delimitedColumnName=&quot;&quot;/&gt;             --&gt;        &lt;/table&gt;    &lt;/context&gt;    &lt;/generatorConfiguration&gt;</code></pre><h3 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h3><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;!DOCTYPE generatorConfiguration            PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;            &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;    &lt;generatorConfiguration&gt;        &lt;!--    windows下路径, 如D:/downloads/xxx.jar--&gt;        &lt;classPathEntry location=&quot;D:/downloads/mybatis/mysql-connector-java-5.1.6.jar&quot; /&gt;        &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;            &lt;!--        不再追加xml内容--&gt;            &lt;plugin type=&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot; /&gt;            &lt;commentGenerator&gt;                &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;            &lt;/commentGenerator&gt;            &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                            connectionURL=&quot;jdbc:mysql://192.168.206.131:3307/mimall?characterEncoding=utf-8&quot;                            userId=&quot;root&quot;                            password=&quot;123456&quot;&gt;            &lt;/jdbcConnection&gt;            &lt;javaTypeResolver &gt;                &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;            &lt;/javaTypeResolver&gt;            &lt;javaModelGenerator targetPackage=&quot;com.imooc.mimall.pojo&quot; targetProject=&quot;src/main/java&quot;&gt;                &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;                &lt;!--            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;--&gt;            &lt;/javaModelGenerator&gt;            &lt;sqlMapGenerator targetPackage=&quot;mappers&quot;  targetProject=&quot;src/main/resources&quot;&gt;                &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;            &lt;/sqlMapGenerator&gt;            &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.imooc.mimall.dao&quot;  targetProject=&quot;src/main/java&quot;&gt;                &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;            &lt;/javaClientGenerator&gt;            &lt;table tableName=&quot;mall_order&quot; domainObjectName=&quot;Order&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;/&gt;            &lt;table tableName=&quot;mall_order_item&quot; domainObjectName=&quot;OrderItem&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;/&gt;            &lt;table tableName=&quot;mall_user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;/&gt;        &lt;/context&gt;    &lt;/generatorConfiguration&gt;</code></pre><h3 id="运行代码生成文件"><a href="#运行代码生成文件" class="headerlink" title="运行代码生成文件"></a>运行代码生成文件</h3><ul><li>配置完成后只需打开终端运行此命令就能生成文件</li></ul><pre><code>    mvn mybatis-generator:generate</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>generatorConfig.xml默认配置中是生成Example类的相关内容，如果不需要Example类，只需要将enableCountByExample、enableCountByExample、enableDeleteByExample、enableSelectByExample设置为true或者去掉这些配置。</li></ul><h2 id="二、Mybatis-plugin插件"><a href="#二、Mybatis-plugin插件" class="headerlink" title="二、Mybatis-plugin插件"></a>二、Mybatis-plugin插件</h2><ul><li>提供Mapper接口与配置文件中对应SQL的导航</li><li>编辑XML文件时自动补全</li><li>自动检查Mapper XML文件中ID冲突</li><li>自动检查Mapper XML文件中错误的属性值</li><li>等等</li></ul><h3 id="Free-Mybatis-plugin插件"><a href="#Free-Mybatis-plugin插件" class="headerlink" title="Free-Mybatis-plugin插件"></a>Free-Mybatis-plugin插件</h3><ul><li>因为Mybatis-plugin插件现在收费了，我们找到一个免费的替代版本</li><li>只需下载插件就行</li><li>我们暂时用到的功能是追踪dao接口和mapper文件里xml的一个插件</li><li>效果：点击dao可以追踪到xml，，同理点击xml的sql右边小箭头，可以追踪到dao方法</li></ul><h2 id="三、Mybatis-pageHelper"><a href="#三、Mybatis-pageHelper" class="headerlink" title="三、Mybatis-pageHelper"></a>三、Mybatis-pageHelper</h2><ul><li>Mybatis-pageHelper是使数据实现分页效果的插件</li></ul><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>    &lt;!--        mybatis分页器--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;        &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.2.13&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>在方法中使用</li></ul><pre><code>    //使用mybatis分页器，pageNum表示第几页，pageSize表示每页的条数    PageHelper.startPage(pageNum,pageSize);    //返回值赋值成productVo类型    List&lt;Product&gt; productList = productMapper.selectByCategoryIdSet(categoryIdSet);    List&lt;ProductVo&gt; productVoList = productList.stream()            .map(e -&gt; {                ProductVo productVo = new ProductVo();                BeanUtils.copyProperties(e, productVo);                return productVo;            })            .collect(Collectors.toList());    PageInfo pageInfo = new PageInfo&lt;&gt;(productList);    //所有查到的数据    pageInfo.setList(productVoList);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis的使用</title>
      <link href="/2020/05/22/mybatis/"/>
      <url>/2020/05/22/mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这是我学习Mybatis做的一些笔记，包括XML和注解两种方法,注解方法只需了解会用就行，XML要熟悉使用</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>Mybatis是一个基于Java的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录</li></ul><h2 id="导入依赖和配置"><a href="#导入依赖和配置" class="headerlink" title="导入依赖和配置"></a>导入依赖和配置</h2><ul><li>依赖，这里我们用的是2.1.0版本</li></ul><pre><code>    &lt;!--        Mybatis--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;2.1.0&lt;/version&gt;            &lt;/dependency&gt;    &lt;!--        数据库--&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                &lt;scope&gt;runtime&lt;/scope&gt;            &lt;/dependency&gt;</code></pre><ul><li>配置</li></ul><pre><code>    spring:      datasource:        password: 123456        username: root        url: jdbc:mysql://192.168.206.131:3307/mimall?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8        driver-class-name: com.mysql.cj.jdbc.Driver    mybatis:      configuration:        map-underscore-to-camel-case: true    #驼峰命名法</code></pre><h2 id="使用Mybatis"><a href="#使用Mybatis" class="headerlink" title="使用Mybatis"></a>使用Mybatis</h2><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><ul><li>新建两个文件如图</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/36.png" alt=""></p><ul><li>Category是对应数据库表设置的实体类</li><li>这里可以使用一个插件免于生成get set toString方法</li><li>导入依赖和下载插件lombok（记住要去下载插件）</li></ul><pre><code>    &lt;!--        lombok插件，自动生成get set方法和toStringFangfa--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;/dependency&gt;</code></pre><ul><li>Category</li></ul><pre><code>    @Data       //自动生成get set toString方法    public class Category {        private Integer id;        private Integer parentId;        private String name;        private Integer status;        private Integer sortOrder;        private Date createTime;        private Date updateTime;    }</code></pre><ul><li>CategoryMapper是对数据库进行增删改查的接口</li><li>需要在接口前写上@Mapper注解</li></ul><pre><code>    @Mapper    public interface CategoryMapper {        @Select(&quot;select * from mall_category where id = #{id}&quot;)        Category findById(@Param(&quot;id&quot;) Integer id);    }</code></pre><ul><li>但是每个注解前都写@Mapper注解就太麻烦了，可以在主类前写上@MapperScan(basePackages = “com.imooc.mimall.dao”)</li></ul><pre><code>    @MapperScan(basePackages = &quot;com.imooc.mimall.dao&quot;)    @SpringBootApplication    public class MimallApplication {        public static void main(String[] args) {            SpringApplication.run(MimallApplication.class, args);        }    }</code></pre><ul><li>测试</li></ul><pre><code>    @Autowired    private CategoryMapper categoryMapper;    @Test    public void findById() {        Category category = categoryMapper.findById(100001);        System.out.println(category.toString());    }</code></pre><h3 id="XML方式"><a href="#XML方式" class="headerlink" title="XML方式"></a>XML方式</h3><ul><li>生成xml文件如图</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/37.png" alt=""></p><ul><li>namespace：增删改查接口所在包</li><li>sql中id是对数据库操作时公共的字段，可以提取出来</li><li>select中id是接口的名字，resultType是对应数据库的类的所在包</li></ul><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;    &lt;!DOCTYPE mapper            PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;            &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;    &lt;mapper namespace=&quot;com.imooc.mimall.dao.CategoryMapper&quot;&gt;    &lt;!--    公共的字段--&gt;        &lt;sql id=&quot;Base_Column_List&quot;&gt;            id, parent_id, name, status, sort_order, create_time, update_time        &lt;/sql&gt;        &lt;select id=&quot;queryById&quot; resultType=&quot;com.imooc.mimall.pojo.Category&quot;&gt;            select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from mall_category where id = #{id}        &lt;/select&gt;    &lt;/mapper&gt;</code></pre><ul><li>CategoryMapper中加入接口，注意不要写sql语句了，xml中写了，对比注解</li></ul><pre><code>    //@Mapper    public interface CategoryMapper {        @Select(&quot;select * from mall_category where id = #{id}&quot;)        Category findById(@Param(&quot;id&quot;) Integer id);        Category queryById(Integer id);    }</code></pre><ul><li>这样就可以用了吗，还是会报错，因为我们yml中没配置mappers中xml所在包，所以无法使用</li></ul><pre><code>    mybatis:      configuration:        map-underscore-to-camel-case: true    #驼峰命名法      mapper-locations: classpath:mappers/*.xml  #使用xml时导入mappers包</code></pre><ul><li>测试和注解方式一摸一样</li></ul><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><ul><li>foreach元素的属性主要有item，index，collection，open，separator，close。<ul><li>item：集合中元素迭代时的别名，该参数为必选。</li><li>index：在list和数组中,index是元素的序号，在map中，index是元素的key，该参数可选</li><li>open：foreach代码的开始符号，一般是(和close=”)”合用。常用在in(),values()时。该参数可选</li><li>separator：元素之间的分隔符，例如在in()的时候，separator=”,”会自动在元素中间用“,“隔开，避免手动输入逗号导致sql错误，如in(1,2,)这样。该参数可选。</li><li>close: foreach代码的关闭符号，一般是)和open=”(“合用。常用在in(),values()时。该参数可选。</li><li>collection: 要做foreach的对象，作为入参时，List对象默认用”list”代替作为键，数组对象有”array”代替作为键，Map对象没有默认的键。当然在作为入参时可以使用@Param(“keyName”)来设置键，设置keyName后，list,array将会失效。 除了入参这种情况外，还有一种作为参数对象的某个字段的时候。举个例子：如果User有属性List ids。入参是User对象，那么这个collection = “ids”.如果User有属性Ids ids;其中Ids是个对象，Ids有个属性List id;入参是User对象，那么collection = “ids.id”</li></ul></li><li>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况： <ul><li>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list .</li><li>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array .</li><li>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key.</li></ul></li></ul><h5 id="mapper接口"><a href="#mapper接口" class="headerlink" title="mapper接口"></a>mapper接口</h5><ul><li>建立增删改查操作时当传入参数为一个集合或者列表时，例如，注意要加上注解@Param</li></ul><pre><code>    List&lt;Product&gt; selectByCategoryIdSet(@Param(&quot;categoryIdSet&quot;) Set&lt;Integer&gt; categoryIdSet);</code></pre><h5 id="xml文件"><a href="#xml文件" class="headerlink" title="xml文件"></a>xml文件</h5><ul><li>这是查询category_id是否在集合内，是就返回</li></ul><pre><code>    &lt;select id=&quot;selectByCategoryIdSet&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select        &lt;include refid=&quot;Base_Column_List&quot;/&gt;        from mall_product        where status = 1        &lt;if test=&quot;categoryIdSet.size() &gt; 0&quot;&gt;            and category_id in            &lt;foreach collection=&quot;categoryIdSet&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;                #{item}            &lt;/foreach&gt;        &lt;/if&gt;    &lt;/select&gt;</code></pre><h4 id="Param注解"><a href="#Param注解" class="headerlink" title="@Param注解"></a>@Param注解</h4><h5 id="使用场景一"><a href="#使用场景一" class="headerlink" title="使用场景一"></a>使用场景一</h5><ul><li>注解单一属性，当传入参数不止一个时使用</li><li>dao层示例</li></ul><pre><code>    int deleteByIdAndUid(@Param(&quot;shippingId&quot;) Integer shippingId,@Param(&quot;userId&quot;) Integer userId);</code></pre><ul><li>xml映射对应示例</li></ul><pre><code>    &lt;delete id=&quot;deleteByIdAndUid&quot; parameterType=&quot;map&quot;&gt;        delete from mall_shipping        where id = #{shippingId,jdbcType=INTEGER}        and user_id = #{userId,jdbcType=INTEGER}      &lt;/delete&gt;</code></pre><p>注意：采用#{}的方式把@Param注解括号内的参数进行引用（括号内参数对应的是形参如 userId对应的是userId）；</p><h5 id="使用场景二"><a href="#使用场景二" class="headerlink" title="使用场景二"></a>使用场景二</h5><ul><li>@Param注解JavaBean对象，当传入参数为一个对象时使用</li><li>dao层示例</li></ul><pre><code>    List&lt;Shipping&gt; selectByIdSet(@Param(&quot;idSet&quot;) Set&lt;Integer&gt; idSet);</code></pre><ul><li>xml映射对应示例</li></ul><pre><code>    &lt;select id=&quot;selectByIdSet&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select        &lt;include refid=&quot;Base_Column_List&quot;/&gt;        from mall_shipping        &lt;where&gt;            &lt;if test=&quot;idSet.size() &gt; 0&quot;&gt;                id in                &lt;foreach collection=&quot;idSet&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;                    #{item}                &lt;/foreach&gt;            &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><h3 id="插入数据获取不到自动生成主键问题"><a href="#插入数据获取不到自动生成主键问题" class="headerlink" title="插入数据获取不到自动生成主键问题"></a>插入数据获取不到自动生成主键问题</h3><ul><li>Springboot中 Mybatis 配置文件 Mapper参数</li><li>useGeneratedKeys=“true” keyProperty=“id”</li><li>useGeneratedKeys设置为 true 时，表示如果插入的表id以自增列为主键，则允许 JDBC 支持自动生成主键，并可将自动生成的主键id返回。</li><li>useGeneratedKeys参数只针对 insert 语句生效，默认为 false；</li><li>dao层示例</li></ul><pre><code>    int insertSelective(Shipping record);</code></pre><ul><li>xml映射文件</li></ul><pre><code>    &lt;!--    允许生成的主键返回--&gt;    &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.imooc.mimall.pojo.Shipping&quot; useGeneratedKeys=&quot;true&quot;                keyProperty=&quot;id&quot;&gt;            insert into mall_shipping            &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;                &lt;if test=&quot;id != null&quot;&gt;                    id,                &lt;/if&gt;                &lt;if test=&quot;userId != null&quot;&gt;                    user_id,                &lt;/if&gt;                &lt;if test=&quot;receiverName != null&quot;&gt;                    receiver_name,                &lt;/if&gt;                &lt;if test=&quot;receiverPhone != null&quot;&gt;                    receiver_phone,                &lt;/if&gt;                &lt;if test=&quot;receiverMobile != null&quot;&gt;                    receiver_mobile,                &lt;/if&gt;                &lt;if test=&quot;receiverProvince != null&quot;&gt;                    receiver_province,                &lt;/if&gt;                &lt;if test=&quot;receiverCity != null&quot;&gt;                    receiver_city,                &lt;/if&gt;                &lt;if test=&quot;receiverDistrict != null&quot;&gt;                    receiver_district,                &lt;/if&gt;                &lt;if test=&quot;receiverAddress != null&quot;&gt;                    receiver_address,                &lt;/if&gt;                &lt;if test=&quot;receiverZip != null&quot;&gt;                    receiver_zip,                &lt;/if&gt;                &lt;if test=&quot;createTime != null&quot;&gt;                    create_time,                &lt;/if&gt;                &lt;if test=&quot;updateTime != null&quot;&gt;                    update_time,                &lt;/if&gt;            &lt;/trim&gt;            &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;                &lt;if test=&quot;id != null&quot;&gt;                    #{id,jdbcType=INTEGER},                &lt;/if&gt;                &lt;if test=&quot;userId != null&quot;&gt;                    #{userId,jdbcType=INTEGER},                &lt;/if&gt;                &lt;if test=&quot;receiverName != null&quot;&gt;                    #{receiverName,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverPhone != null&quot;&gt;                    #{receiverPhone,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverMobile != null&quot;&gt;                    #{receiverMobile,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverProvince != null&quot;&gt;                    #{receiverProvince,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverCity != null&quot;&gt;                    #{receiverCity,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverDistrict != null&quot;&gt;                    #{receiverDistrict,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverAddress != null&quot;&gt;                    #{receiverAddress,jdbcType=VARCHAR},                &lt;/if&gt;                &lt;if test=&quot;receiverZip != null&quot;&gt;                    #{receiverZip,jdbcType=VARCHAR},                &lt;/if&gt;            &lt;/trim&gt;        &lt;/insert&gt;</code></pre><h3 id="dao层传入参数为List时"><a href="#dao层传入参数为List时" class="headerlink" title="dao层传入参数为List时"></a>dao层传入参数为List时</h3><ul><li>List中的数据而且还是对象</li><li>dao层示例</li></ul><pre><code>    int batchInsert(@Param(&quot;orderItemList&quot;) List&lt;OrderItem&gt; orderItemList);</code></pre><ul><li>xml映射文件对应示例，因为List中是对象，要一个个获取属性要用#{item.xxx},注意外面的大括号不能丢</li></ul><pre><code>    &lt;insert id=&quot;batchInsert&quot; parameterType=&quot;list&quot;&gt;        insert into mall_order_item (user_id, order_no,        product_id, product_name, product_image,        current_unit_price, quantity, total_price)        values        &lt;foreach collection=&quot;orderItemList&quot; index=&quot;index&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt;            (            #{item.userId},            #{item.orderNo},            #{item.productId},            #{item.productName},            #{item.productImage},            #{item.currentUnitPrice},            #{item.quantity},            #{item.totalPrice}            )        &lt;/foreach&gt;    &lt;/insert&gt;</code></pre><h3 id="dao层传入参数为Set时"><a href="#dao层传入参数为Set时" class="headerlink" title="dao层传入参数为Set时"></a>dao层传入参数为Set时</h3><ul><li>dao层示例</li></ul><pre><code>    List&lt;OrderItem&gt; selectByOrderNoSet(@Param(&quot;orderNoSet&quot;) Set&lt;Long&gt; orderNoSet);</code></pre><ul><li>xml映射文件对应示例，因为set里面不是对象，所以直接获取item就好了，这里用到了open和close</li></ul><pre><code>    &lt;select id=&quot;selectByOrderNoSet&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select        &lt;include refid=&quot;Base_Column_List&quot;/&gt;        from mall_order_item        &lt;where&gt;            &lt;if test=&quot;orderNoSet.size() &gt; 0&quot;&gt;                order_no in                &lt;foreach collection=&quot;orderNoSet&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;                    #{item}                &lt;/foreach&gt;            &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;</code></pre><h3 id="List转Map"><a href="#List转Map" class="headerlink" title="List转Map"></a>List转Map</h3><ul><li>Map value值为对象</li></ul><pre><code>    //获取所有商品    List&lt;Product&gt; products = productMapper.selectByProductIdSet(productIdSet);    //把商品转换成一个map，这样就可以不经数据库查到数据，用到Collectors.toMap()方法    Map&lt;Integer, Product&gt; map = products.stream()            .collect(Collectors.toMap(Product::getId, product -&gt; product));</code></pre><ul><li>Map value为List,List中也是对象</li></ul><pre><code>    List&lt;OrderItem&gt; orderItemList = orderItemMapper.selectByOrderNoSet(orderNoSet);    //list转map，这里因为value是一个List，所以要用到groupingBy    Map&lt;Long, List&lt;OrderItem&gt;&gt; orderItemMap = orderItemList.stream()            .collect(Collectors.groupingBy(OrderItem::getOrderNo));</code></pre><h3 id="List转Set"><a href="#List转Set" class="headerlink" title="List转Set"></a>List转Set</h3><pre><code>    List&lt;Order&gt; orderList = orderMapper.selectByUid(uid);    Set&lt;Integer&gt; shippingIdSet = orderList.stream()            .map(Order::getShippingId)            .collect(Collectors.toSet());</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分页加载，点击按钮加载更多和滚动加载</title>
      <link href="/2020/05/18/fen-ye/"/>
      <url>/2020/05/18/fen-ye/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>如果返回的数据比较少，那么我们放在一个页面没什么问题，但是请求回来的数据比较多，放在一个页面就会用户体验比较差，我们需要把他分开</li><li>这里有三种方法，分页，点击按钮加载更多，和滚动加载更多</li><li>前两种方法是用element-ui的组件，滚动加载则是用一个插件vue-infinite-scroll</li></ul><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><pre><code>    getOrderList() {          this.loading = true       //加载loading          this.axios            .get(&quot;/orders&quot;,{              params:{                pageSize: 5,        //每页跳蛛                pageNum:this.pageNum    //当前页数              }            })            .then(res =&gt; {              this.loading = false;              this.list = res.list;     //当前页面数据              this.total = res.total;   //总条数            })            .catch(() =&gt; {              this.loading = false;            });</code></pre><h3 id="Pagination组件"><a href="#Pagination组件" class="headerlink" title="Pagination组件"></a>Pagination组件</h3><ul><li>做一个应用不可能一个页面都能把所有数据加载完，所以我们要实现分页效果，一页只实现少量的数据，可以分很多页</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>注意，这是一个组件，要在components中引入，这里的语法可能不太好理解，Pagination.name就相当于<el-pagination></el-pagination>，这个是在html中引入的组件</p><pre><code>  import { Pagination } from &quot;element-ui&quot;;  components: {      [Pagination.name]: Pagination    }</code></pre></li></ul><pre><code>     &lt;el-pagination class=&quot;pagination&quot; :pageSize=&quot;pageSize&quot; background layout=&quot;prev, pager, next&quot; :total=&quot;total&quot; @current-change=&quot;handelchange&quot;&gt;&lt;/el-pagination&gt;</code></pre><ul><li><p>这里面的组件包含很多属性，pageSize就是页面的大小可以包含几条数据，total表示总数据，注意属性的调用可能有驼峰命名法，比如文档中调用属性page-size会出错，你要改成pageSize</p></li><li><p>current-change是事件名称，page页改变的时候会触发，回调参数是当前页数</p><pre><code>   //点击触发事件，会有一个回调参数，这个回调参数就是当前的页数      handelchange(pageNum){        this.pageNum = pageNum        this.getOrderList()      }</code></pre></li></ul><h2 id="加载更多"><a href="#加载更多" class="headerlink" title="加载更多"></a>加载更多</h2><h3 id="Button组件"><a href="#Button组件" class="headerlink" title="Button组件"></a>Button组件</h3><ul><li>点击Button组件会加载更多数据</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li><p>组件的loading属性是显示加载loading的，需要动态绑定，在加载时显示，加载完成后关闭，绑定到getOrderList</p><pre><code>  import { Button } from &quot;element-ui&quot;;  components: {      [Button.name]: Button,    }  &lt;el-button type=&quot;primary&quot; :loading=&quot;loading&quot; @click=&quot;loadMore&quot;&gt;加载更多&lt;/el-button&gt;</code></pre></li><li><p>loadMore事件是加载更多</p><pre><code>  loadMore(){        this.pageNum++    //每点击一次页数加1        this.getOrderList()      }</code></pre></li><li><p>我们发现返回的数据没有拼接，只有请求的到数据，我们要把它拼接</p><pre><code>  this.list = this.list.concat(res.list);   //把返回的数据拼接到一起</code></pre></li></ul><h2 id="滚动加载"><a href="#滚动加载" class="headerlink" title="滚动加载"></a>滚动加载</h2><ul><li>开发中总会遇到这种下拉加载的设计方案，Vue实现下拉加载最佳方案自然是使用vue-infinite-scroll来实现。接下来我们一起看下它的配置及使用方式。</li></ul><h3 id="首先我们先了解下他的配置参数："><a href="#首先我们先了解下他的配置参数：" class="headerlink" title="首先我们先了解下他的配置参数："></a>首先我们先了解下他的配置参数：</h3><ul><li>v-infinite-scroll=”loadMore”表示回调函数是loadMore</li><li>infinite-scroll-disabled=”busy”表示由变量busy决定是否执行loadMore，false则执行loadMore，true则不执行，注意，busy表示繁忙，繁忙的时候是不执行的。</li><li>infinite-scroll-distance=”10”这里10决定了页面滚动到离页尾多少像素的时候触发回调函数，10是像素值。一般情况下会在页尾做一个几十像素高的“正在加载中…”，这样的话，可以把这个div的高度设为infinite-scroll-distance的值即可。</li><li>infinite-scroll-immediate-check 默认值为true，该指令表示，应该在绑定后立即检查busy的值和是否滚动到底。假如你的初始内容高度不够，不足以填满可滚动的容器的话，你应设为true，这样会立即执行一次loadMore，会帮你填充一些初始内容。</li><li>infinite-scroll-listen-for-event 当事件在Vue实例中发出时，无限滚动将再次检查。</li><li>infinite-scroll-throttle-delay 检查busy的值的时间间隔，默认值是200，因为vue-infinite-scroll的基础原理是，vue-infinite-scroll会循环检查busy的值，以及是否滚动到底，只有当：busy为false且滚动到底，回调函数才会执行</li></ul><h3 id="安装vue-infinite-scroll"><a href="#安装vue-infinite-scroll" class="headerlink" title="安装vue-infinite-scroll"></a>安装vue-infinite-scroll</h3><pre><code>    npm install vue-infinite-scroll --save</code></pre><h3 id="引入-vue-infinite-scroll"><a href="#引入-vue-infinite-scroll" class="headerlink" title="引入 vue-infinite-scroll"></a>引入 vue-infinite-scroll</h3><ul><li><p>全局引入</p><pre><code>  // register globally（全局引入，在main.js中引入）  import infiniteScroll from &#39;vue-infinite-scroll&#39;  Vue.use(infiniteScroll)</code></pre></li><li><p>局部引入</p><pre><code>  // or for a single instance  import infiniteScroll from &#39;vue-infinite-scroll&#39;  new Vue({    directives: {infiniteScroll}  })</code></pre></li></ul><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><ul><li><p>首先需要引用插件，上面步骤，然后使用，img是加载动画，需要绑定一个loading动态加载</p><pre><code>      &lt;div              v-show=&quot;loading&quot;              v-infinite-scroll=&quot;loadMore&quot;              infinite-scroll-disabled=&quot;busy&quot;              infinite-scroll-distance=&quot;410&quot;            &gt;            &lt;img src=&quot;/imgs/loading-svg/loading-spinning-bubbles.svg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;          &lt;/div&gt;</code></pre></li></ul><ul><li><p>触发事件，下拉都一定程度就会触发</p><pre><code>          loadMore(){        this.busy = true      //触发事件后busy繁忙        setTimeout(()=&gt;{      //防止频繁触发事件，设置0.5秒延迟          this.pageNum++          this.getList()        },500)      },      getList() {        this.loading = true        this.axios          .get(&quot;/orders&quot;, {            params: {              pageSize: 5,              pageNum: this.pageNum            }          })          .then(res =&gt; {            this.list = this.list.concat(res.list);   //拼接            if(res.hasNextPage){                  this.busy = false            }else{              this.busy = true  //如果没有下一页，就禁止掉，下拉将没用，动画也不再显示              this.loading = false            }          })      },</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> element-ui，vue-infinite-scroll </category>
          
      </categories>
      
      
        <tags>
            
            <tag> element-ui </tag>
            
            <tag> vue </tag>
            
            <tag> vue-infinite-scroll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商支付（微信支付和支付宝支付）前端</title>
      <link href="/2020/05/17/dian-shang-zhi-fu/"/>
      <url>/2020/05/17/dian-shang-zhi-fu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>做一个电商平台，那么最必不可少的步骤就是支付了，我们这里只介绍两种最主流的支付方法，微信支付和支付宝支付，众所周知考虑到支付安全等因素，支付要做的大部分事情都是后端承担的，前端只需要做少部分事情与后端对接就可以了，这里我们暂时只讲前端与后端对接的支付功能</li></ul><h2 id="订单页面"><a href="#订单页面" class="headerlink" title="订单页面"></a>订单页面</h2><ul><li>这个页面前期已开发好，暂时只讲支付功能，这个页面的开发就没写出来了。点击微信支付则弹出微信支付框，点击支付宝则跳转到支付宝支付页面（这个相对更安全）</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/31.png" alt=""></p><h2 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h2><ul><li>点击触发事件，携带支付订单号跳转到支付宝页面</li></ul><pre><code>    paySubmit(payment) {          //payment等于1就是支付宝支付，2就是微信支付          if (payment == 1) {            this.payment = 1;            window.open(&quot;/#/order/alipay?orderId=&quot; + this.orderNo, &quot;_blank&quot;); //携带订单号跳转到支付宝支付页面（新页面）          }        }</code></pre><ul><li>alipay页面，调用接口，返回一堆html源码</li><li>我们需要用v-html把他渲染出来，它是一个form表单，我们还需要提交他document.forms[0].submit()，然后就会跳转到支付宝支付页面</li></ul><pre><code>    &lt;template&gt;        &lt;div class=&quot;ali-pay&quot;&gt;            &lt;order-header title=&quot;订单支付&quot;&gt;                &lt;template v-slot:tips&gt;                    &lt;span&gt;请谨防钓鱼链接或诈骗电话，了解更多&lt;/span&gt;                &lt;/template&gt;            &lt;/order-header&gt;            &lt;loading v-if=&quot;loading&quot;&gt;&lt;/loading&gt;            &lt;div class=&quot;form&quot; v-html=&quot;content&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        import OrderHeader from &#39;./../components/OrderHeader&#39;;        import Loading from &#39;./../components/Loading&#39;;        export default {            name: &#39;alipay&#39;,            data() {                return {                    orderId: this.$route.query.orderId,      //订单号                    content: &#39;&#39;,     //支付宝页面html源码                    loading: true   //是否展示loading                }            },            components: {                OrderHeader,                Loading            },            mounted() {                //调用支付宝接口                this.submitPay()            },            methods: {                submitPay() {                    this.axios.post(&#39;/pay&#39;, {                        orderId: this.orderId,                        orderName: &#39;Vue小米高仿商城&#39;,                        amount: 0.01,                        payType: 1,                    }).then((res) =&gt; {                        this.content = res.content                        setTimeout(()=&gt;{                            document.forms[0].submit();     //提交第一个表单数据，跳转到支付宝页面                        },100)                    })                }            },        }    &lt;/script&gt;</code></pre><h3 id="中转页面"><a href="#中转页面" class="headerlink" title="中转页面"></a>中转页面</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/32.png" alt=""></p><h3 id="支付页面"><a href="#支付页面" class="headerlink" title="支付页面"></a>支付页面</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/33.png" alt=""></p><h2 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h2><ul><li>微信支付和支付宝支付调用的接口差不多，只不过微信返回的之一串二维码生成的代码，我们需要解析它</li></ul><h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><ul><li>qrcode是一个可以把代码生成二维码的插件，可以用来生成微信支付二维码</li></ul><pre><code>    cnpm install qrcode --save</code></pre><h3 id="插件的基本使用方法"><a href="#插件的基本使用方法" class="headerlink" title="插件的基本使用方法"></a>插件的基本使用方法</h3><pre><code>    import QRCode from &quot;qrcode&quot;;    QRCode.toDataURL(content)                  .then(url =&gt; {                    console.log(url)    //成功生成二维码                  })                  .catch((err) =&gt; {                    console.log(err)    //失败                  });</code></pre><h3 id="调用接口生成二维码"><a href="#调用接口生成二维码" class="headerlink" title="调用接口生成二维码"></a>调用接口生成二维码</h3><pre><code>    paySubmit(payment) {    if (payment == 2) {            this.payment = 2;            this.axios              .post(&quot;/pay&quot;, {                orderId: this.orderNo,                orderName: &quot;Vue高仿小米商城&quot;,                amount: 0.01,                payType: 2              })              .then(res =&gt; {                  //通过插件生成微信支付二维码                QRCode.toDataURL(res.content)                  .then(url =&gt; {                    this.showPay = true;                    this.payImg = url;                    this.loopOrderState()                  })                  .catch(() =&gt; {                    this.$message.error(&#39;二维码生成失败，请稍后重试&#39;)                  });              });          }        }</code></pre><h3 id="微信支付弹框"><a href="#微信支付弹框" class="headerlink" title="微信支付弹框"></a>微信支付弹框</h3><ul><li>是先做好，点击微信支付则弹出</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/34.png" alt=""></p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><ul><li>我们这里要做的功能是用户扫码之后就会跳转到订单列表，我们要怎么才能知道用户是否已经支付了呢，这里我们一秒轮询一次支付状态，直到用户已经支付，则关闭轮询，跳转到订单列表页面</li></ul><pre><code>    //轮询当前支付状态        loopOrderState(){          //setInterval和setTimeout不一样，这个只要不关闭会一直轮询，setTimeout则只会执行一次          this.T = setInterval(()=&gt;{            this.axios.get(`/orders/${this.orderNo}`).then((res)=&gt;{            if(res.status == 20){              clearInterval(this.T)   //关闭轮询              this.gotoOrderList()            }          })          },1000)        }</code></pre><ul><li>点击关闭微信支付页面，为了更好的用户体验，会弹出一个弹框，让用户自己选择有没有支付（怕网络延迟，支付成功不跳转），当然这里也要关闭轮询</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/lhzjoker/cdn/source/imgs/35.png" alt=""></p><h3 id="支付完成"><a href="#支付完成" class="headerlink" title="支付完成"></a>支付完成</h3><ul><li>支付完成之后我们还要干嘛呢，就是再次点击微信支付，因为订单已经没有了，就会报一个错，这里我们要提醒用户已经支付，到main.js中去配置,这里的错误是http请求状态码错误，跟返回数据状态码错误不一样</li><li>这里是接口调用失败，http状态码为500，没有返回response数据，所以需要在error里处理</li></ul><pre><code>    //接口错误拦截    axios.interceptors.response.use(function(response){   //拦截页面返回数据状态码      let res = response.data      if(res.status == 0){      //状态码为0代表登陆成功        return res.data      }else if(response.status == 10){    //状态码为10代表未登陆，跳转到登陆页面        if(location.hash!=&#39;#/index&#39;){     //如果没有登录则只能访问首页          window.location.href = &#39;/#/login&#39;   //跳转到登陆页面        }        return Promise.reject()   //发生错误，promise返回拒绝值      }else{        Message.error(res.msg)        return Promise.reject()   //发生错误，promise返回拒绝值      }    },(error)=&gt;{    //拦截http请求状态码（请求发送失败）      let res = error.response      Message.error(res.data.message)      return Promise.reject()   //发生错误，promise返回拒绝值    })</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-cli脚手架</title>
      <link href="/2020/05/13/vue-cli/"/>
      <url>/2020/05/13/vue-cli/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这是我学习vue一段时间后，上手脚手架，做的一些笔记</li></ul><h2 id="什么是脚手架"><a href="#什么是脚手架" class="headerlink" title="什么是脚手架"></a>什么是脚手架</h2><ul><li>vue-cli4.0安装及应用生成，vue-cli4.0是一个脚手架，作用是创建一个初始化的Vue项目，一个很方便的东西，很多东西都封装好了，我们只需要用就行了，约定大于配置</li></ul><h2 id="安装和环境搭建"><a href="#安装和环境搭建" class="headerlink" title="安装和环境搭建"></a>安装和环境搭建</h2><ul><li>安装vue-cli：cnpm i -g @vue/cli（一般会下载最新版本）</li><li>创建项目：vue create + 项目名</li><li>默认babel，eslint自动安装</li></ul><h2 id="vue-cli的使用"><a href="#vue-cli的使用" class="headerlink" title="vue-cli的使用"></a>vue-cli的使用</h2><ul><li>进入文件，启动：cnpm run serve</li><li>使用脚手架的界面ui功能：vue ui，这是脚手架内置的一套可视化的系统，（vue项目管理器，需要导入项目，或者创建项目）</li><li>安装一些依赖插件：axios，vue-router，vuex（这些插件的使用后面会说到）</li></ul><h2 id="脚手架目录结构解析"><a href="#脚手架目录结构解析" class="headerlink" title="脚手架目录结构解析"></a>脚手架目录结构解析</h2><pre><code>    public --- 存放一些公共资源，比如大图片等    resource --- 一些打包的资源，供我们使用    .gitignore --- git忽略配置文件    package-lock.json --- 项目包管控文件    package.json --- 项目配置    README.md --- 项目说明书    dist --- 打包后的项目    src --- 源码目录        |- api --- 承载整个项目的api请求        |- assets --- 存放web中引用的图片 媒体资源        |- components --- 存放可复用组件，你可以在任意页面中复用这些组件        |- util --- 一些公共的方法        |- store --- vuex        |- App.vue --- 是项目入口文件        |- main.js --- 根逻辑，页面加载首先会加载这份js文件。        |- router.js --- 路由文件        |- pages --- 页面</code></pre><h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><h3 id="Vue文件解析"><a href="#Vue文件解析" class="headerlink" title="Vue文件解析"></a>Vue文件解析</h3><ul><li>vue文件初始化一般是template模板包裹一层div来写骨架，然后就是script写逻辑，style写样式</li></ul><pre><code>    &lt;template&gt;        &lt;div&gt;            orderList        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default{            name: &#39;order-list&#39;,        }    &lt;/script&gt;    &lt;style&gt;    &lt;/style&gt;</code></pre><h3 id="watch-和-computed的-简析"><a href="#watch-和-computed的-简析" class="headerlink" title="watch 和 computed的 简析"></a>watch 和 computed的 简析</h3><ul><li>vue提供了2个动态监测data的函数，一个是watch，一个是computed。</li><li>watch： 主要监测已经存在的data，处理data变化后的钩子</li><li>computed： 处理一个已存在的data，返回一个data</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/26.png" alt=""></p><h3 id="vue中引入组件以及父子组件的数据交互"><a href="#vue中引入组件以及父子组件的数据交互" class="headerlink" title="vue中引入组件以及父子组件的数据交互"></a>vue中引入组件以及父子组件的数据交互</h3><ul><li>关于组件，任意vue文件你都可以看做一个组件。在项目中我们一般使用的应该都是单文件组件，单文件组件与页面结构无异，是具有完整功能的一个模块。比如一个评论框，你就可以剥离成一个组件，在任意页面文件中引入这个组件。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/27.png" alt=""></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/28.png" alt=""></p><h3 id="vue过滤器"><a href="#vue过滤器" class="headerlink" title="vue过滤器"></a>vue过滤器</h3><ul><li>在有一些业务场景需要对数据进行一些转换，比如后端图片地址的前缀匹配，这个时候filters就派上大用场了。看个例子感受一下。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/29.png" alt=""></p><h3 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h3><ul><li>路由对于spa应用的重要性不言而喻，整个应用的页面关系都是通过路由定义的。我们先来看看一个路由文件大致是什么样子</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/30.png" alt=""></p><h3 id="可监测的全局变量——vuex"><a href="#可监测的全局变量——vuex" class="headerlink" title="可监测的全局变量——vuex"></a>可监测的全局变量——vuex</h3><ul><li>项目开发中，往往我们会有一些全局变量，但是正常全局变量，vue是不能监测的，这个时候vuex就派上用场了。</li></ul><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><ul><li>VueX是适用于在Vue项目开发时使用的状态管理工具。试想一下，如果在一个项目开发中频繁的使用组件传参的方式来同步data中的值，一旦项目变得很庞大，管理和维护这些值将是相当棘手的工作。为此，Vue为这些被多个组件频繁使用的值提供了一个统一管理的工具——VueX。在具有VueX的Vue项目中，我们只需要把这些值定义在VueX中，即可在整个Vue项目的组件中使用。</li><li>通俗的来说，组件可以调用自己的data数据，但是组件与组件之间无法跨组件调用，这时vuex就显示他的作用了，vuex就像一个前端数据库，把数据存储进去，从而使所有的组件的能够使用</li></ul><h4 id="VueX中的核心内容"><a href="#VueX中的核心内容" class="headerlink" title="VueX中的核心内容"></a>VueX中的核心内容</h4><ul><li>state 存放状态<ul><li>state就相当与数据库的数据</li></ul></li><li>mutations state成员操作<ul><li>mutations就相当于增删改查操作</li></ul></li><li>getters 加工state成员给外界</li><li>actions 异步操作<ul><li>异步操作，提交mutations操作</li></ul></li><li>modules 模块化状态管理</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>    npm install vuex --save    安装好vuex后，我们先新建一个store文件夹，存放vuex相关文件</code></pre><h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><pre><code>    import Vue from &#39;vue&#39;;    import Vuex from &#39;vuex&#39;;    import actions from &#39;./actions&#39;    import mutations from &#39;./mutations&#39;    Vue.use(Vuex);    const state = {        username:&#39;&#39;,    //用户名        cartcount: 0    //购物车数量    }    export default new Vuex.Store({        state,        actions,        mutations    })  </code></pre><h4 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h4><pre><code>    //商城Vuex-mutation    export default{        saveUserName(state,username){        //改变数据            state.username = username        },        saveCartCount(state,cartcount){            state.cartcount = cartcount        }    }</code></pre><h4 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h4><pre><code>    //商城Vuex-action    export default{        saveUserName(context,username){        //提交            context.commit(&#39;saveUserName&#39;,username)        },        saveCartCount(context,cartcount){            context.commit(&#39;saveCartCount&#39;,cartcount)        }    }</code></pre><h4 id="将store挂载到当前项目的Vue实例当中去"><a href="#将store挂载到当前项目的Vue实例当中去" class="headerlink" title="将store挂载到当前项目的Vue实例当中去"></a>将store挂载到当前项目的Vue实例当中去</h4><ul><li>main.js,这样就可以全局调用了</li></ul><pre><code>    import store from &#39;./store/index&#39;    new Vue({      store,      router: router,      render: h =&gt; h(App),    }).$mount(&#39;#app&#39;)</code></pre><h4 id="dispatch分配actions任务"><a href="#dispatch分配actions任务" class="headerlink" title="dispatch分配actions任务"></a>dispatch分配actions任务</h4><ul><li>可以在App.vue里使用，这样全局都可以使用这个值了</li></ul><pre><code>      this.$store.dispatch(&#39;saveUserName&#39;,res.username)</code></pre><h4 id="渲染延迟"><a href="#渲染延迟" class="headerlink" title="渲染延迟"></a>渲染延迟</h4><ul><li>当我们拉取数据来渲染页面时会有延迟效果，可能渲染不出来获取的值，我们可以用computed来解决</li></ul><pre><code>    computed: {        username() {          return this.$store.state.username;        },        cartcount() {          return this.$store.state.cartcount;        }      },</code></pre><h4 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h4><ul><li>mapState辅助函数可以帮助我们引用state，与上面的效果是一样的</li></ul><pre><code> import { mapState } from &#39;vuex&#39;; computed: {      ...mapState([&#39;username&#39;, &#39;cartcount&#39;])    },</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习vue的时候，做的一些笔记</title>
      <link href="/2020/05/12/vue/"/>
      <url>/2020/05/12/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本文主要讲述学习vue时的一些指令</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是vue"><a href="#什么是vue" class="headerlink" title="什么是vue"></a>什么是vue</h3><ul><li>Vue (读音 /vjuː/，类似于 <strong>view) 是一套用于构建用户界面的渐进式框架</strong></li><li>vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合</li></ul><h3 id="安装和环境搭建"><a href="#安装和环境搭建" class="headerlink" title="安装和环境搭建"></a>安装和环境搭建</h3><ul><li>这里建议新手去看vue.js的官方文档，熟悉之后可以上手vue-cli脚手架</li></ul><h2 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h2><ul><li>MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel</li><li>m model<ul><li>数据层 Vue 中 数据层 都放在 data 里面</li></ul></li><li>v view 视图<ul><li>Vue 中 view 即 我们的HTML页面</li></ul></li><li>vm （view-model） 控制器 将数据和视图层建立联系<ul><li>vm 即 Vue 的实例 就是 vm</li></ul></li></ul><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul><li>本质就是自定义属性</li><li>Vue中指定都是以 v- 开头</li></ul><h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><ul><li>防止页面加载时出现闪烁问题</li></ul><pre><code>    &lt;html&gt;     &lt;style type=&quot;text/css&quot;&gt;      /*         1、通过属性选择器 选择到 带有属性 v-cloak的标签  让他隐藏     */      [v-cloak]{        /* 元素隐藏    */        display: none;      }      &lt;/style&gt;    &lt;body&gt;      &lt;div id=&quot;app&quot;&gt;        &lt;!-- 2、 让带有插值 语法的   添加 v-cloak 属性              在 数据渲染完场之后，v-cloak 属性会被自动去除，             v-cloak一旦移除也就是没有这个属性了  属性选择器就选择不到该标签             也就是对应的标签会变为可见        --&gt;        &lt;div  v-cloak  &gt;{{msg}}&lt;/div&gt;      &lt;/div&gt;      &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;      &lt;script type=&quot;text/javascript&quot;&gt;        var vm = new Vue({          //  el   指定元素 id 是 app 的元素            el: &#39;#app&#39;,          //  data  里面存储的是数据          data: {            msg: &#39;Hello Vue&#39;          }        });    &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><ul><li>v-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题</li><li>如果数据中有HTML标签会将html标签一并输出</li><li>注意：此处为单向绑定，数据对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值</li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;        &lt;!--              注意:在指令中不要写插值语法  直接写对应的变量名称             在 v-text 中 赋值的时候不要在写 插值语法            一般属性中不加 {{}}  直接写 对应 的数据名         --&gt;        &lt;p v-text=&quot;msg&quot;&gt;&lt;/p&gt;        &lt;p&gt;            &lt;!-- Vue  中只有在标签的 内容中 才用插值语法 --&gt;            {{msg}}        &lt;/p&gt;    &lt;/div&gt;    &lt;script&gt;        new Vue({            el: &#39;#app&#39;,            data: {                msg: &#39;Hello Vue.js&#39;            }        });    &lt;/script&gt;</code></pre><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><ul><li><p>用法和v-text 相似 但是他可以将HTML片段填充到标签中</p></li><li><p>可能有安全问题, 一般只在可信任内容上使用 v-html，永不用在用户提交的内容上</p></li><li><p>它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。</p></li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;    　　&lt;p v-html=&quot;html&quot;&gt;&lt;/p&gt; &lt;!-- 输出：html标签在渲染的时候被解析 --&gt;        &lt;p&gt;{{message}}&lt;/p&gt; &lt;!-- 输出：&lt;span&gt;通过双括号绑定&lt;/span&gt; --&gt;    　　&lt;p v-text=&quot;text&quot;&gt;&lt;/p&gt; &lt;!-- 输出：&lt;span&gt;html标签在渲染的时候被源码输出&lt;/span&gt; --&gt;    &lt;/div&gt;    &lt;script&gt;    　　let app = new Vue({    　　el: &quot;#app&quot;,    　　data: {    　　　　message: &quot;&lt;span&gt;通过双括号绑定&lt;/span&gt;&quot;,    　　　　html: &quot;&lt;span&gt;html标签在渲染的时候被解析&lt;/span&gt;&quot;,    　　　　text: &quot;&lt;span&gt;html标签在渲染的时候被源码输出&lt;/span&gt;&quot;,    　　}     });    &lt;/script&gt;</code></pre><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><ul><li>显示原始信息跳过编译过程</li><li>跳过这个元素和它的子元素的编译过程。</li><li>一些静态的内容不需要编译加这个指令可以加快渲染</li></ul><pre><code>    &lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;        &lt;!--  显示的是{{ this will not be compiled }}  --&gt;    &lt;span v-pre&gt;{{msg}}&lt;/span&gt;       &lt;!--   即使data里面定义了msg这里仍然是显示的{{msg}}  --&gt;    &lt;script&gt;        new Vue({            el: &#39;#app&#39;,            data: {                msg: &#39;Hello Vue.js&#39;            }        });    &lt;/script&gt;</code></pre><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><ul><li>执行一次性的插值【当数据改变时，插值处的内容不会继续更新】</li></ul><pre><code>      &lt;!-- 即使data里面定义了msg 后期我们修改了 仍然显示的是第一次data里面存储的数据即 Hello Vue.js  --&gt;         &lt;span v-once&gt;{{ msg}}&lt;/span&gt;        &lt;script&gt;        new Vue({            el: &#39;#app&#39;,            data: {                msg: &#39;Hello Vue.js&#39;            }        });    &lt;/script&gt;</code></pre><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul><li>v-model是一个指令，限制在input、select、textarea、components中使用</li><li>双向数据绑定：当数据发生变化的时候，视图也就发生变化<br>当视图发生变化的时候，数据也会跟着同步变化</li></ul><pre><code>     &lt;div id=&quot;app&quot;&gt;          &lt;div&gt;{{msg}}&lt;/div&gt;          &lt;div&gt;              当输入框中内容改变的时候，  页面上的msg  会自动更新            &lt;input type=&quot;text&quot; v-model=&#39;msg&#39;&gt;          &lt;/div&gt;      &lt;/div&gt;</code></pre><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul><li>用来绑定事件的</li><li>形式如：v-on:click 缩写为 @click;</li></ul><pre><code>        &lt;div id=&quot;app&quot;&gt;            &lt;div&gt;{{num}}&lt;/div&gt;            &lt;div&gt;                &lt;!-- 如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数 --&gt;                &lt;button v-on:click=&#39;handle1&#39;&gt;点击1&lt;/button&gt;                &lt;!-- 2、如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，                     并且事件对象的名称必须是$event                 --&gt;                &lt;button v-on:click=&#39;handle2(123, 456, $event)&#39;&gt;点击2&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var vm = new Vue({                el: &#39;#app&#39;,                data: {                    num: 0                },                methods: {                    handle1: function(event) {                        console.log(event.target.innerHTML)                    },                    handle2: function(p, p1, event) {                        console.log(p, p1)                        console.log(event.target.innerHTML)                        this.num++;                    }                }            });        &lt;/script&gt;</code></pre><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ul><li>在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。</li><li>Vue 不推荐我们操作DOM 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符</li><li>修饰符是由点开头的指令后缀来表示的</li></ul><pre><code>    &lt;!-- 阻止单击事件继续传播 --&gt;    &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;    &lt;!-- 提交事件不再重载页面 --&gt;    &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;    &lt;!-- 修饰符可以串联   即阻止冒泡也阻止默认事件 --&gt;    &lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;    &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;    &lt;!-- 即事件不是从内部元素触发的 --&gt;    &lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;    使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</code></pre><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><ul><li>在做项目中有时会用到键盘事件，在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符</li></ul><pre><code>    &lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;    &lt;input v-on:keyup.13=&quot;submit&quot;&gt;    &lt;!-- -当点击enter 时调用 `vm.submit()` --&gt;    &lt;input v-on:keyup.enter=&quot;submit&quot;&gt;    &lt;!--当点击enter或者space时  时调用 `vm.alertMe()`   --&gt;    &lt;input type=&quot;text&quot; v-on:keyup.enter.space=&quot;alertMe&quot; &gt;    常用的按键修饰符    .enter =&gt;    enter键    .tab =&gt; tab键    .delete (捕获“删除”和“退格”按键) =&gt;  删除键    .esc =&gt; 取消键    .space =&gt;  空格键    .up =&gt;  上    .down =&gt;  下    .left =&gt;  左    .right =&gt;  右    &lt;script&gt;        var vm = new Vue({            el:&quot;#app&quot;,            methods: {                  submit:function(){},                  alertMe:function(){},            }        })    &lt;/script&gt;</code></pre><h3 id="自定义按键修饰符别名"><a href="#自定义按键修饰符别名" class="headerlink" title="自定义按键修饰符别名"></a>自定义按键修饰符别名</h3><ul><li>在Vue中可以通过config.keyCodes自定义按键修饰符别名</li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;        预先定义了keycode 116（即F5）的别名为f5，因此在文字输入框中按下F5，会触发prompt方法        &lt;input type=&quot;text&quot; v-on:keydown.f5=&quot;prompt()&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        Vue.config.keyCodes.f5 = 116;        let app = new Vue({            el: &#39;#app&#39;,            methods: {                prompt: function() {                    alert(&#39;我是 F5！&#39;);                }            }        });    &lt;/script&gt;</code></pre><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul><li>v-bind 指令被用来响应地更新 HTML 属性</li><li>v-bind:href 可以缩写为 :href;</li></ul><pre><code>    &lt;!-- 绑定一个属性 --&gt;    &lt;img v-bind:src=&quot;imageSrc&quot;&gt;    &lt;!-- 缩写 --&gt;    &lt;img :src=&quot;imageSrc&quot;&gt;</code></pre><h4 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h4><ul><li>我们可以给v-bind:class 一个对象，以动态地切换class。</li><li>注意：v-bind:class指令可以与普通的class特性共存</li></ul><pre><code>    1、 v-bind 中支持绑定一个对象         如果绑定的是一个对象 则 键为 对应的类名  值 为对应data中的数据     &lt;!--         HTML最终渲染为 &lt;ul class=&quot;box textColor textSize&quot;&gt;&lt;/ul&gt;        注意：            textColor，textSize  对应的渲染到页面上的CSS类名                isColor，isSize  对应vue data中的数据  如果为true 则对应的类名 渲染到页面上             当 isColor 和 isSize 变化时，class列表将相应的更新，            例如，将isSize改成false，            class列表将变为 &lt;ul class=&quot;box textColor&quot;&gt;&lt;/ul&gt;    --&gt;    &lt;ul class=&quot;box&quot; v-bind:class=&quot;{textColor:isColor, textSize:isSize}&quot;&gt;        &lt;li&gt;学习Vue&lt;/li&gt;        &lt;li&gt;学习Node&lt;/li&gt;        &lt;li&gt;学习React&lt;/li&gt;    &lt;/ul&gt;      &lt;div v-bind:style=&quot;{color:activeColor,fontSize:activeSize}&quot;&gt;对象语法&lt;/div&gt;    &lt;sript&gt;    var vm= new Vue({        el:&#39;.box&#39;,        data:{            isColor:true,            isSize:true，            activeColor:&quot;red&quot;,            activeSize:&quot;25px&quot;,        }    })    &lt;/sript&gt;    &lt;style&gt;        .box{            border:1px dashed #f0f;        }        .textColor{            color:#f00;            background-color:#eef;        }        .textSize{            font-size:30px;            font-weight:bold;        }    &lt;/style&gt;</code></pre><h4 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h4><pre><code>    2、  v-bind 中支持绑定一个数组    数组中classA和 classB 对应为data中的数据    这里的classA  对用data 中的  classA    这里的classB  对用data 中的  classB    &lt;ul class=&quot;box&quot; :class=&quot;[classA, classB]&quot;&gt;        &lt;li&gt;学习Vue&lt;/li&gt;        &lt;li&gt;学习Node&lt;/li&gt;        &lt;li&gt;学习React&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;    var vm= new Vue({        el:&#39;.box&#39;,        data:{            classA:‘textColor‘,            classB:‘textSize‘        }    })    &lt;/script&gt;    &lt;style&gt;        .box{            border:1px dashed #f0f;        }        .textColor{            color:#f00;            background-color:#eef;        }        .textSize{            font-size:30px;            font-weight:bold;        }    &lt;/style&gt;</code></pre><h4 id="绑定对象和绑定数组-的区别"><a href="#绑定对象和绑定数组-的区别" class="headerlink" title="绑定对象和绑定数组 的区别"></a>绑定对象和绑定数组 的区别</h4><ul><li>绑定对象的时候 对象的属性 即要渲染的类名 对象的属性值对应的是 data 中的数据</li><li>绑定数组的时候数组里面存的是data 中的数据</li></ul><h4 id="绑定style"><a href="#绑定style" class="headerlink" title="绑定style"></a>绑定style</h4><ul><li>不过一般很少这么用</li></ul><pre><code>     &lt;div v-bind:style=&quot;styleObject&quot;&gt;绑定样式对象&lt;/div&gt;&#39;    &lt;!-- CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来)    --&gt;     &lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize,background:&#39;red&#39; }&quot;&gt;内联样式&lt;/div&gt;    &lt;!--组语法可以将多个样式对象应用到同一个元素 --&gt;    &lt;div v-bind:style=&quot;[styleObj1, styleObj2]&quot;&gt;&lt;/div&gt;    &lt;script&gt;        new Vue({          el: &#39;#app&#39;,          data: {            styleObject: {              color: &#39;green&#39;,              fontSize: &#39;30px&#39;,              background:&#39;red&#39;            }，            activeColor: &#39;green&#39;,               fontSize: &quot;30px&quot;          },          styleObj1: {                 color: &#39;red&#39;           },           styleObj2: {                fontSize: &#39;30px&#39;           }    &lt;/script&gt;</code></pre><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="v-if-使用场景"><a href="#v-if-使用场景" class="headerlink" title="v-if 使用场景"></a>v-if 使用场景</h4><ul><li>1- 多个元素 通过条件判断展示或者隐藏某个元素。或者多个元素</li><li>2- 进行两个视图之间的切换</li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;            &lt;!--  判断是否加载，如果为真，就加载，否则不加载--&gt;            &lt;span v-if=&quot;flag&quot;&gt;               如果flag为true则显示,false不显示!            &lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;        var vm = new Vue({            el:&quot;#app&quot;,            data:{                flag:true            }        })    &lt;/script&gt;    ----------------------------------------------------------        &lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt;           A        &lt;/div&gt;      &lt;!-- v-else-if紧跟在v-if或v-else-if之后   表示v-if条件不成立时执行--&gt;        &lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt;           B        &lt;/div&gt;        &lt;div v-else-if=&quot;type === &#39;C&#39;&quot;&gt;           C        &lt;/div&gt;      &lt;!-- v-else紧跟在v-if或v-else-if之后--&gt;        &lt;div v-else&gt;           Not A/B/C        &lt;/div&gt;    &lt;script&gt;        new Vue({          el: &#39;#app&#39;,          data: {            type: &#39;C&#39;          }        })    &lt;/script&gt;</code></pre><h4 id="v-show-和-v-if的区别"><a href="#v-show-和-v-if的区别" class="headerlink" title="v-show 和 v-if的区别"></a>v-show 和 v-if的区别</h4><ul><li>v-show本质就是标签display设置为none，控制隐藏<ul><li>v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。</li></ul></li><li>v-if是动态的向DOM树内添加或者删除DOM元素<ul><li>v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件</li></ul></li><li>v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>相比之下， v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。</li></ul><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><ul><li>用于循环的数组里面的值可以是对象，也可以是普通元素</li></ul><pre><code>    &lt;ul id=&quot;example-1&quot;&gt;       &lt;!-- 循环结构-遍历数组          item 是我们自己定义的一个名字  代表数组里面的每一项          items对应的是 data中的数组--&gt;      &lt;li v-for=&quot;item in items&quot;&gt;        {{ item.message }}      &lt;/li&gt;     &lt;/ul&gt;    &lt;script&gt;     new Vue({      el: &#39;#example-1&#39;,      data: {        items: [          { message: &#39;Foo&#39; },          { message: &#39;Bar&#39; }        ]，      }    })    &lt;/script&gt;</code></pre><ul><li>不推荐同时使用 v-if 和 v-for</li><li>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。</li></ul><pre><code>       &lt;!--  循环结构-遍历对象            v 代表   对象的value            k  代表对象的 键             i  代表索引            ---&gt;          &lt;div v-if=&#39;v==13&#39; v-for=&#39;(v,k,i) in obj&#39;&gt;{{v + '---' + k + '---' + i}}&lt;/div&gt;    &lt;script&gt;     new Vue({      el: &#39;#example-1&#39;,      data: {        items: [          { message: &#39;Foo&#39; },          { message: &#39;Bar&#39; }        ]，        obj: {            uname: &#39;zhangsan&#39;,            age: 13,            gender: &#39;female&#39;        }      }    })    &lt;/script&gt;</code></pre><ul><li>key 的作用<ul><li>key来给每个节点做一个唯一标识</li><li>key的作用主要是为了高效的更新虚拟DOM</li></ul></li></ul><pre><code>    &lt;ul&gt;      &lt;li v-for=&quot;(item,index) in items&quot; :key=&quot;index&quot;&gt;...&lt;/li&gt;    &lt;/ul&gt;</code></pre><h3 id="案例选项卡"><a href="#案例选项卡" class="headerlink" title="案例选项卡"></a>案例选项卡</h3><h4 id="1、-HTML-结构"><a href="#1、-HTML-结构" class="headerlink" title="1、 HTML 结构"></a>1、 HTML 结构</h4><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;tab&quot;&gt;        &lt;!--  tab栏  --&gt;        &lt;ul&gt;            &lt;li class=&quot;active&quot;&gt;apple&lt;/li&gt;            &lt;li class=&quot;&quot;&gt;orange&lt;/li&gt;            &lt;li class=&quot;&quot;&gt;lemon&lt;/li&gt;        &lt;/ul&gt;          &lt;!--  对应显示的图片 --&gt;        &lt;div class=&quot;current&quot;&gt;&lt;img src=&quot;img/apple.png&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;&quot;&gt;&lt;img src=&quot;img/orange.png&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;&quot;&gt;&lt;img src=&quot;img/lemon.png&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h4 id="2、-提供的数据"><a href="#2、-提供的数据" class="headerlink" title="2、 提供的数据"></a>2、 提供的数据</h4><pre><code>     list: [{                id: 1,                title: &#39;apple&#39;,                path: &#39;img/apple.png&#39;            }, {                id: 2,                title: &#39;orange&#39;,                path: &#39;img/orange.png&#39;            }, {                id: 3,                title: &#39;lemon&#39;,                path: &#39;img/lemon.png&#39;            }]</code></pre><h4 id="3、-把数据渲染到页面"><a href="#3、-把数据渲染到页面" class="headerlink" title="3、 把数据渲染到页面"></a>3、 把数据渲染到页面</h4><ul><li>把tab栏 中的数替换到页面上<ul><li>把 data 中 title 利用 v-for 循环渲染到页面上</li><li>把 data 中 path利用 v-for 循环渲染到页面上</li></ul></li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;        &lt;div class=&quot;tab&quot;&gt;              &lt;ul&gt;                  &lt;!--                      1、绑定key的作用 提高Vue的性能                     2、 key 需要是唯一的标识 所以需要使用id， 也可以使用index ，                        index 也是唯一的                     3、 item 是 数组中对应的每一项                      4、 index 是 每一项的 索引                --&gt;                   &lt;li :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;&gt;{{item.title}}&lt;/li&gt;              &lt;/ul&gt;              &lt;div  :key=&#39;item.id&#39; v-for=&#39;(item, index) in list&#39;&gt;                    &lt;!-- :  是 v-bind 的简写   绑定属性使用 v-bind --&gt;                    &lt;img :src=&quot;item.path&quot;&gt;              &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        new  Vue({            //  指定 操作元素 是 id 为app 的             el: &#39;#app&#39;,                data: {                    list: [{                        id: 1,                        title: &#39;apple&#39;,                        path: &#39;img/apple.png&#39;                    }, {                        id: 2,                        title: &#39;orange&#39;,                        path: &#39;img/orange.png&#39;                    }, {                        id: 3,                        title: &#39;lemon&#39;,                        path: &#39;img/lemon.png&#39;                    }]                }        })    &lt;/script&gt;</code></pre><h4 id="4、-给每一个tab栏添加事件-并让选中的高亮"><a href="#4、-给每一个tab栏添加事件-并让选中的高亮" class="headerlink" title="4、 给每一个tab栏添加事件,并让选中的高亮"></a>4、 给每一个tab栏添加事件,并让选中的高亮</h4><ul><li>4.1 、让默认的第一项tab栏高亮<ul><li>tab栏高亮 通过添加类名active 来实现 （CSS active 的样式已经提前写好）<ul><li>在data 中定义一个 默认的 索引 currentIndex 为 0</li><li>给第一个li 添加 active 的类名<ul><li>通过动态绑定class 来实现 第一个li 的索引为 0 和 currentIndex 的值刚好相等</li><li>currentIndex === index 如果相等 则添加类名 active 否则 添加 空类名</li></ul></li></ul></li></ul></li></ul><ul><li>4.2 、让默认的第一项tab栏对应的div 显示<ul><li>实现思路 和 第一个 tab 实现思路一样 只不过 这里控制第一个div 显示的类名是 current</li></ul></li></ul><pre><code>      &lt;ul&gt;           &lt;!-- 动态绑定class   有 active   类名高亮  无 active   不高亮--&gt;           &lt;li  :class=&#39;currentIndex==index?&quot;active&quot;:&quot;&quot;&#39;               :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;               &gt;{{item.title}}&lt;/li&gt;      &lt;/ul&gt;        &lt;!-- 动态绑定class   有 current  类名显示  无 current  隐藏--&gt;      &lt;div :class=&#39;currentIndex==index?&quot;current&quot;:&quot;&quot;&#39;            :key=&#39;item.id&#39; v-for=&#39;(item, index) in list&#39;&gt;            &lt;!-- :  是 v-bind 的简写   绑定属性使用 v-bind --&gt;            &lt;img :src=&quot;item.path&quot;&gt;      &lt;/div&gt;    &lt;script&gt;        new  Vue({            el: &#39;#app&#39;,                data: {                    currentIndex: 0, // 选项卡当前的索引  默认为 0                      list: [{                        id: 1,                        title: &#39;apple&#39;,                        path: &#39;img/apple.png&#39;                    }, {                        id: 2,                        title: &#39;orange&#39;,                        path: &#39;img/orange.png&#39;                    }, {                        id: 3,                        title: &#39;lemon&#39;,                        path: &#39;img/lemon.png&#39;                    }]                }        })    &lt;/script&gt;</code></pre><ul><li>4.3 、点击每一个tab栏 当前的高亮 其他的取消高亮<ul><li>给每一个li添加点击事件</li><li>让当前的索引 index 和 当前 currentIndex 的 值 进项比较</li><li>如果相等 则当前li 添加active 类名 当前的 li 高亮 当前对应索引的 div 添加 current 当前div 显示 其他隐藏</li></ul></li></ul><pre><code>    &lt;div id=&quot;app&quot;&gt;        &lt;div class=&quot;tab&quot;&gt;            &lt;ul&gt;                &lt;!--  通过v-on 添加点击事件   需要把当前li 的索引传过去                 --&gt;                &lt;li v-on:click=&#39;change(index)&#39;                                                   :class=&#39;currentIndex==index?&quot;active&quot;:&quot;&quot;&#39;                                       :key=&#39;item.id&#39;                     v-for=&#39;(item,index) in list&#39;&gt;{{item.title}}&lt;/li&gt;            &lt;/ul&gt;            &lt;div :class=&#39;currentIndex==index?&quot;current&quot;:&quot;&quot;&#39;                  :key=&#39;item.id&#39; v-for=&#39;(item, index) in list&#39;&gt;                &lt;img :src=&quot;item.path&quot;&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        new  Vue({            el: &#39;#app&#39;,                data: {                    currentIndex: 0, // 选项卡当前的索引  默认为 0                      list: [{                        id: 1,                        title: &#39;apple&#39;,                        path: &#39;img/apple.png&#39;                    }, {                        id: 2,                        title: &#39;orange&#39;,                        path: &#39;img/orange.png&#39;                    }, {                        id: 3,                        title: &#39;lemon&#39;,                        path: &#39;img/lemon.png&#39;                    }]                },                methods: {                    change: function(index) {                        // 通过传入过来的索引来让当前的  currentIndex  和点击的index 值 相等                         //  从而实现 控制类名                            this.currentIndex = index;                    }                }        })    &lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element-ui的使用</title>
      <link href="/2020/05/12/element-ui/"/>
      <url>/2020/05/12/element-ui/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h3><ul><li>推荐使用 npm 的方式安装，它能更好地和 webpack 打包工具配合使用。</li></ul><pre><code>    npm i element-ui -S</code></pre><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ul><li>目前可以通过 unpkg.com/element-ui 获取到最新版本的资源，在页面上引入 js 和 css 文件即可开始使用。</li></ul><pre><code>    &lt;!-- 引入样式 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;    &lt;!-- 引入组件库 --&gt;    &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="引入Element"><a href="#引入Element" class="headerlink" title="引入Element"></a>引入Element</h3><ul><li>你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。</li></ul><h3 id="完整引入"><a href="#完整引入" class="headerlink" title="完整引入"></a>完整引入</h3><ul><li>你可以在main.js中加入以下内容</li></ul><pre><code>    import ElementUI from &#39;element-ui&#39;;    import &#39;element-ui/lib/theme-chalk/index.css&#39;;    Vue.use(ElementUI);</code></pre><ul><li>以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。</li><li>如果在需要用到大部分组件的时候可以完整引入，只是用到少部分软件建议按需引入，可以减少项目体积</li></ul><h3 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h3><ul><li><p>借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。</p></li><li><p>首先，安装 babel-plugin-component：</p></li></ul><pre><code>    npm install babel-plugin-component -D</code></pre><ul><li>这里官方文档里面是将 .babelrc 修改为：</li></ul><pre><code>    {      &quot;presets&quot;: [[&quot;es2015&quot;, { &quot;modules&quot;: false }]],      &quot;plugins&quot;: [        [          &quot;component&quot;,          {            &quot;libraryName&quot;: &quot;element-ui&quot;,            &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;          }        ]      ]    }</code></pre><ul><li>但是我们可能没有，只有一个babel.config.js,里面的内容比起上面只能解析es2015要强大很多，当然也包括上面的es2015</li></ul><p>“presets”: [<br>    ‘@vue/cli-plugin-babel/preset’<br>  ],</p><ul><li>所以我们只需把这个加入babel.config.js中</li></ul><pre><code>    &quot;plugins&quot;: [        [          &quot;component&quot;,          {            &quot;libraryName&quot;: &quot;element-ui&quot;,            &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;          }        ]      ]</code></pre><ul><li>接下来，如果你只希望引入部分组件，比如 Button 和 Select，那么需要在 main.js 中写入以下内容：</li></ul><pre><code>    import { Button, Select } from &#39;element-ui&#39;;    Vue.component(Button.name, Button);    Vue.component(Select.name, Select);    /* 或写为     * Vue.use(Button)     * Vue.use(Select)     */</code></pre><h3 id="Message组件"><a href="#Message组件" class="headerlink" title="Message组件"></a>Message组件</h3><h4 id="全局使用"><a href="#全局使用" class="headerlink" title="全局使用"></a>全局使用</h4><ul><li>如果每个文件都要import导入那就太麻烦了</li><li>我们用到了Message组件，就以Message组件为例,写入main.js中</li></ul><pre><code>    import { Message } from &#39;element-ui&#39;    Vue.prototype.$message = Message;</code></pre><ul><li>这样我们在全局要是哟个Message组件就可以这样</li></ul><pre><code>    this.$message.info(&#39;消息&#39;)    this.$message.warning(&#39;警告&#39;)    this.$message.success(&#39;成功&#39;)    this.$message.error(&#39;错误&#39;)</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><pre><code>    getOrderList() {          this.loading = true       //加载loading          this.axios            .get(&quot;/orders&quot;,{              params:{                pageSize: 5,        //每页跳蛛                pageNum:this.pageNum    //当前页数              }            })            .then(res =&gt; {              this.loading = false;              this.list = res.list;     //当前页面数据              this.total = res.total;   //总条数            })            .catch(() =&gt; {              this.loading = false;            });</code></pre><h3 id="Pagination组件"><a href="#Pagination组件" class="headerlink" title="Pagination组件"></a>Pagination组件</h3><ul><li>做一个应用不可能一个页面都能把所有数据加载完，所以我们要实现分页效果，一页只实现少量的数据，可以分很多页</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>注意，这是一个组件，要在components中引入，这里的语法可能不太好理解，Pagination.name就相当于<el-pagination></el-pagination>，这个是在html中引入的组件</li></ul><pre><code>    import { Pagination } from &quot;element-ui&quot;;    components: {        [Pagination.name]: Pagination      }     &lt;el-pagination class=&quot;pagination&quot; :pageSize=&quot;pageSize&quot; background layout=&quot;prev, pager, next&quot; :total=&quot;total&quot; @current-change=&quot;handelchange&quot;&gt;&lt;/el-pagination&gt;</code></pre><ul><li>这里面的组件包含很多属性，pageSize就是页面的大小可以包含几条数据，total表示总数据，注意属性的调用可能有驼峰命名法，比如文档中调用属性page-size会出错，你要改成pageSize</li><li>current-change是事件名称，page页改变的时候会触发，回调参数是当前页数</li></ul><pre><code>     //点击触发事件，会有一个回调参数，这个回调参数就是当前的页数        handelchange(pageNum){          this.pageNum = pageNum          this.getOrderList()        }</code></pre><h2 id="加载更多"><a href="#加载更多" class="headerlink" title="加载更多"></a>加载更多</h2><h3 id="Button组件"><a href="#Button组件" class="headerlink" title="Button组件"></a>Button组件</h3><ul><li>点击Button组件会加载更多数据</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li>组件的loading属性是显示加载loading的，需要动态绑定，在加载时显示，加载完成后关闭，绑定到getOrderList</li></ul><pre><code>    import { Button } from &quot;element-ui&quot;;    components: {        [Button.name]: Button,      }    &lt;el-button type=&quot;primary&quot; :loading=&quot;loading&quot; @click=&quot;loadMore&quot;&gt;加载更多&lt;/el-button&gt;</code></pre><ul><li>loadMore事件是加载更多</li></ul><pre><code>    loadMore(){          this.pageNum++    //每点击一次页数加1          this.getOrderList()        }</code></pre><ul><li>我们发现返回的数据没有拼接，只有请求的到数据，我们要把它拼接</li></ul><pre><code>    this.list = this.list.concat(res.list);   //把返回的数据拼接到一起</code></pre>]]></content>
      
      
      <categories>
          
          <category> element-ui </category>
          
      </categories>
      
      
        <tags>
            
            <tag> element-ui </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot安全（spring security）</title>
      <link href="/2020/02/14/springboot-yu-an-quan/"/>
      <url>/2020/02/14/springboot-yu-an-quan/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot与安全（spring-security）"><a href="#SpringBoot与安全（spring-security）" class="headerlink" title="SpringBoot与安全（spring security）"></a>SpringBoot与安全（spring security）</h1><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>比较常见的安全框架有：Apache的shiro、Spring Security等等，相信用shiro的用户群体更多，而security功能更多一些。<br>Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型。他可以实现强大的web安全控制。对于安全控制，我们仅需引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理。几个类：</p><ul><li>WebSecurityConfigurerAdapter：自定义Security策略</li><li>AuthenticationManagerBuilder：自定义认证策略</li><li>@EnableWebSecurity：开启WebSecurity模式</li></ul><ul><li>应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两个主要区域是Spring Security 的两个目标。</li></ul><ul><li>“认证”（Authentication），是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统）。</li></ul><ul><li><p>“授权”（Authorization）指确定一个主体是否允许在你的应用程序执行一个动作的过程。为了抵达需要授权的店，主体的身份已经有认证过程建立。</p></li><li><p>这个概念是通用的而不只在Spring Security中。</p></li></ul><h2 id="Web和安全"><a href="#Web和安全" class="headerlink" title="Web和安全"></a>Web和安全</h2><h3 id="登陆注销"><a href="#登陆注销" class="headerlink" title="登陆注销"></a>登陆注销</h3><ul><li>HttpSecurity配置登陆、注销功能</li></ul><ul><li>Thymeleaf提供的SpringSecurity标签支持<ul><li>需要引入thymeleaf-extras-springsecurity5</li><li><html xmlns:th="http://www.thymeleaf.org"xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurit></li><li>sec:authentication=“name”获得当前用户的用户名</li><li>sec:authorize=“hasRole(‘ADMIN’)”当前用户必须拥有ADMIN权限时才会显示标签内容</li><li>sec:authentication=”principal.authorities” 获取当前用户的权限级别</li><li>sec:authorize=”!isAuthenticated()” 用户没登陆才会显示的标签内容</li><li>sec:authorize=”isAuthenticated()” 用户登陆才会显示的标签内容</li></ul></li></ul><ul><li>remember me<ul><li>表单添加remember-me的checkbox</li><li>配置启用remember-me功能</li></ul></li></ul><ul><li>CSRF（Cross-site request forgery）跨站请求伪造<ul><li>HttpSecurity启用csrf功能，会为表单添加_csrf的值，提交携带来预防CSRF；</li></ul></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;thymeleaf.version&gt;3.0.11.RELEASE&lt;/thymeleaf.version&gt;        &lt;!--布局功能的支持程序  thymeleaf3的主程序  layout2版本以上--&gt;        &lt;thymeleaf-layout-dialect.version&gt;2.4.1&lt;/thymeleaf-layout-dialect.version&gt;        &lt;thymeleaf-extras-springsecurity.version&gt;3.0.4.RELEASE&lt;/thymeleaf-extras-springsecurity.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;        &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><h3 id="测试页面"><a href="#测试页面" class="headerlink" title="测试页面"></a>测试页面</h3><ul><li>welcome.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;h1 align=&quot;center&quot;&gt;欢迎光临武林秘籍管理系统&lt;/h1&gt;    &lt;h2 align=&quot;center&quot;&gt;游客您好，如果想查看武林秘籍 &lt;a th:href=&quot;@{/login}&quot;&gt;请登录&lt;/a&gt;&lt;/h2&gt;    &lt;hr&gt;    &lt;h3&gt;普通武功秘籍&lt;/h3&gt;    &lt;ul&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level1/1}&quot;&gt;罗汉拳&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level1/2}&quot;&gt;武当长拳&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level1/3}&quot;&gt;全真剑法&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;高级武功秘籍&lt;/h3&gt;    &lt;ul&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level2/1}&quot;&gt;太极拳&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level2/2}&quot;&gt;七伤拳&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level2/3}&quot;&gt;梯云纵&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;绝世武功秘籍&lt;/h3&gt;    &lt;ul&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level3/1}&quot;&gt;葵花宝典&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level3/2}&quot;&gt;龟派气功&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a th:href=&quot;@{/level3/3}&quot;&gt;独孤九剑&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><ul><li>login.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;h1 align=&quot;center&quot;&gt;欢迎登陆武林秘籍管理系统&lt;/h1&gt;    &lt;hr&gt;    &lt;div align=&quot;center&quot;&gt;    &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    用户名:&lt;input name=&quot;&quot;/&gt;&lt;br&gt;    密码:&lt;input name=&quot;&quot;&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;    &lt;/form&gt;    &lt;/div&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><h4 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h4><ul><li>1.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a th:href=&quot;@{/}&quot;&gt;返回&lt;/a&gt;        &lt;h1&gt;罗汉拳&lt;/h1&gt;        &lt;p&gt;罗汉拳站当央,打起来不要慌&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><ul><li>2.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a th:href=&quot;@{/}&quot;&gt;返回&lt;/a&gt;        &lt;h1&gt;罗汉拳&lt;/h1&gt;        &lt;p&gt;罗汉拳站当央,打起来不要慌&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><ul><li>3.html</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a th:href=&quot;@{/}&quot;&gt;返回&lt;/a&gt;        &lt;h1&gt;罗汉拳&lt;/h1&gt;        &lt;p&gt;罗汉拳站当央,打起来不要慌&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><ul><li>level2/3和level1基本一致，页面架构如下</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/18.png" alt=""></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>KungfuController.java</li></ul><pre><code>    package com.atguigu.security.controller;    import org.springframework.stereotype.Controller;    import org.springframework.web.bind.annotation.GetMapping;    import org.springframework.web.bind.annotation.PathVariable;    @Controller    public class KungfuController {        private final String PREFIX = &quot;pages/&quot;;        /**        * 欢迎页        * @return        */        @GetMapping(&quot;/&quot;)        public String index() {            return &quot;welcome&quot;;        }        /**        * 登陆页        * @return        */        @GetMapping(&quot;/userlogin&quot;)        public String loginPage() {            return PREFIX+&quot;login&quot;;        }        /**        * level1页面映射        * @param path        * @return        */        @GetMapping(&quot;/level1/{path}&quot;)        public String level1(@PathVariable(&quot;path&quot;)String path) {            return PREFIX+&quot;level1/&quot;+path;        }        /**        * level2页面映射        * @param path        * @return        */        @GetMapping(&quot;/level2/{path}&quot;)        public String level2(@PathVariable(&quot;path&quot;)String path) {            return PREFIX+&quot;level2/&quot;+path;        }        /**        * level3页面映射        * @param path        * @return        */        @GetMapping(&quot;/level3/{path}&quot;)        public String level3(@PathVariable(&quot;path&quot;)String path) {            return PREFIX+&quot;level3/&quot;+path;        }    }</code></pre><ul><li>访问:localhost:8080</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/19.png" alt=""></p><h3 id="配置授权"><a href="#配置授权" class="headerlink" title="配置授权"></a>配置授权</h3><ul><li>pom文件引入security模块</li></ul><pre><code>    &lt;dependency&gt;    　　&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    　　&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><ul><li>现在所有人都能访问武功秘籍，这时我们要设置一下权限</li></ul><pre><code>    @EnableWebSecurity    public class MySercurityConfig extends WebSecurityConfigurerAdapter {        public void configure(HttpSecurity http) throws Exception {    //定制请求的授权规则    http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()            .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;VIP1&quot;)            .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;VIP2&quot;)            .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;VIP3&quot;);    }</code></pre><p>我们现在访问罗汉拳，将会提示403，访问拒绝。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/21.png" alt=""></p><h3 id="开启登陆功能"><a href="#开启登陆功能" class="headerlink" title="开启登陆功能"></a>开启登陆功能</h3><p>这是因为我们还没有登陆访问，加入如下的这段代码，让它为我们自动配置，只要不符合等级规则，就跳转到/login的登录页</p><pre><code>    //开启自动配置的登陆功能，效果，如果没有登陆，没有权限将会来到登陆页面    http.formLogin();    //1./login来到登陆页    //2.重定向来到/login?error表示登陆失败    //3.更多的详细规定</code></pre><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/20.png" alt=""></p><ul><li>登陆成功，访问页面</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/22.png" alt=""></p><h3 id="定义认证功能"><a href="#定义认证功能" class="headerlink" title="定义认证功能"></a>定义认证功能</h3><ul><li>讲我们拥有的用户信息对应匹配规则，然后使用这些账户登录试一下~（这里为了简单说明，我用的是内存保存，当然，可以使用“auth.jdbc…..”来进行数据库的链接使用）</li></ul><pre><code>    //定义认证功能    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        //这里可以改进连数据库        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())                .withUser(&quot;zhangsan&quot;).password(passwordEncoder.encode(&quot;heihei&quot;)).roles(&quot;VIP1&quot;, &quot;VIP2&quot;)                .and()                .withUser(&quot;lisi&quot;).password(passwordEncoder.encode(&quot;123456&quot;)).roles(&quot;VIP2&quot;, &quot;VIP3&quot;)                .and()                .withUser(&quot;wangwu&quot;).password(passwordEncoder.encode(&quot;12456&quot;)).roles(&quot;VIP1&quot;, &quot;VIP3&quot;);</code></pre><h3 id="开启注销功能"><a href="#开启注销功能" class="headerlink" title="开启注销功能"></a>开启注销功能</h3><ul><li>welcome.html</li></ul><pre><code>    &lt;!-- 把这段代码放到你想要的位置，比如登录后边边 --&gt;    &lt;form th:action=&quot;@{/logout}&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;submit&quot; value=&quot;注销&quot;/&gt;    &lt;/form&gt;</code></pre><ul><li>开启自动配置的注销功能</li></ul><pre><code>    http.logout().logoutSuccessUrl(&quot;/&quot;);    //注销成功后去初始页面    //1.访问/logout 表示用户注销，清空session    //2.退出成功将来到/login?logout页面</code></pre><h3 id="优化页面"><a href="#优化页面" class="headerlink" title="优化页面"></a>优化页面</h3><ul><li>让不同用户看到首页展示不同，没有登录的呢，就看不到具体内容。</li><li>pom文件引入springsecurity5；</li></ul><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;        &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><ul><li>在html中改造一下，引入springsecurity5（加两个div做判断是否授权-sec:authorize），如果没有认证（!isAuthenticated()）就展示游客请登录，如果认证了就展示角色信息；读取角色信息（sec:authentication）；</li></ul><pre><code>    &lt;!DOCTYPE html&gt;    &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;          xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity4&quot;&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;        &lt;title&gt;Insert title here&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;h1 align=&quot;center&quot;&gt;欢迎光临武林秘籍管理系统&lt;/h1&gt;    &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt;        &lt;h2 align=&quot;center&quot;&gt;游客您好，如果想查看武林秘籍 &lt;a th:href=&quot;@{/login}&quot;&gt;请登录&lt;/a&gt;&lt;/h2&gt;    &lt;/div&gt;    &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;        &lt;h2&gt;&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt;，您好，您的角色有:            &lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;&lt;/h2&gt;        &lt;form th:action=&quot;@{/logout}&quot; method=&quot;post&quot;&gt;            &lt;input type=&quot;submit&quot; value=&quot;注销&quot;/&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;hr&gt;    &lt;div sec:authorize=&quot;hasRole(&#39;VIP1&#39;)&quot;&gt;        &lt;h3&gt;普通武功秘籍&lt;/h3&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level1/1}&quot;&gt;罗汉拳&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level1/2}&quot;&gt;武当长拳&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level1/3}&quot;&gt;全真剑法&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div sec:authorize=&quot;hasRole(&#39;VIP2&#39;)&quot;&gt;        &lt;h3&gt;高级武功秘籍&lt;/h3&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level2/1}&quot;&gt;太极拳&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level2/2}&quot;&gt;七伤拳&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level2/3}&quot;&gt;梯云纵&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div sec:authorize=&quot;hasRole(&#39;VIP3&#39;)&quot;&gt;        &lt;h3&gt;绝世武功秘籍&lt;/h3&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level3/1}&quot;&gt;葵花宝典&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level3/2}&quot;&gt;龟派气功&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a th:href=&quot;@{/level3/3}&quot;&gt;独孤九剑&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><p>再次启动就会发现差别</p><ul><li>没登陆状态，只会显示一个请登录页面</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/24.png" alt=""></p><ul><li>登陆状态，成功会显示注销，用户名字，权限等信息</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/23.png" alt=""></p><h3 id="完善页面"><a href="#完善页面" class="headerlink" title="完善页面"></a>完善页面</h3><ul><li>登陆的时候进入我们自己设计的页面，并用用户名和密码作关联<br>http.formLogin().usernameParameter(“user”).passwordParameter(“pwd”).loginPage(“/userlogin”);</li></ul><ul><li><p>welcome.html优化，将登录请求变成userlogin请求；</p></li><li><p>login.html</p></li></ul><pre><code>    &lt;div align=&quot;center&quot;&gt;        &lt;form th:action=&quot;@{/userlogin}&quot; method=&quot;post&quot;&gt;            用户名:&lt;input name=&quot;user&quot;/&gt;&lt;br&gt;            密码:&lt;input name=&quot;pwd&quot;&gt;&lt;br/&gt;            &lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt;记住我&lt;br/&gt;            &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;        &lt;/form&gt;    &lt;/div&gt;</code></pre><ul><li>remeberme优化<br>http.rememberMe().rememberMeParameter(“remember”);</li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot消息(JMS、AMQP、RabbitMQ)</title>
      <link href="/2020/02/11/sprintboot-yu-xiao-xi/"/>
      <url>/2020/02/11/sprintboot-yu-xiao-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot与消息-JMS、AMQP、RabbitMQ"><a href="#SpringBoot与消息-JMS、AMQP、RabbitMQ" class="headerlink" title="SpringBoot与消息(JMS、AMQP、RabbitMQ)"></a>SpringBoot与消息(JMS、AMQP、RabbitMQ)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>1.大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力</li></ul><ul><li><p>2.消息服务中两个重要概念：</p><ul><li>消息代理（message broker）和目的地（destination）<br>当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递指定目的地。</li></ul></li><li><p>3.消息队列主要有两种形式的目的地</p><p>  1.队列（queue）：点对点消息通信（point-to-point）</p><p>  2.主题（topic）：发布（publish）/订阅（subscribe）消息通信</p></li><li><p>4.点对点式：</p><ul><li><p>消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列</p></li><li><p>消息只有唯一的发送者和接受者，但并不是说只能有一个接收者</p></li></ul></li><li><p>5.发布订阅式：</p><ul><li>发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息</li></ul></li><li><p>6.JMS（Java Message Service）JAVA消息服务：</p><ul><li>基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现</li></ul></li><li><p>7.AMQP（Advanced Message Queuing Protocol）</p><ul><li>高级消息队列协议，也是一个消息代理的规范，兼容JMS<br>RabbitMQ是AMQP的实现</li></ul></li><li><p>8.Spring支持</p><ul><li>spring-jms提供了对JMS的支持</li><li>spring-rabbit提供了对AMQP的支持</li><li>需要ConnectionFactory的实现来连接消息代理</li><li>提供JmsTemplate、RabbitTemplate来发送消息</li><li>@JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息</li><li>@EnableJms、@EnableRabbit开启支持</li></ul></li><li><p>9.Spring Boot自动配置</p><ul><li>JmsAutoConfiguration</li><li>RabbitAutoConfiguration</li></ul></li></ul><h2 id="rabbitmq简介"><a href="#rabbitmq简介" class="headerlink" title="rabbitmq简介"></a>rabbitmq简介</h2><ul><li>RabbitMQ简介：</li></ul><p>RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>Message</li></ul><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、pririty（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持性存储）等。</p><ul><li>Publisher</li></ul><p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p><ul><li>Exchange</li></ul><p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。<br>Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别</p><ul><li>Queue</li></ul><p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><ul><li>Binding</li></ul><p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。<br>Exchange 和Queue的绑定可以是多对多的关系。</p><ul><li>Connection</li></ul><p>网络连接，比如一个TCP连接。</p><ul><li>Channel</li></ul><p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><ul><li>Consumer</li></ul><p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><ul><li>Virtual Host</li></ul><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><ul><li>Broker</li></ul><p>表示消息队列服务器实体</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/1.png" alt=""></p><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><ul><li>AMQP 中的消息路由</li></ul><p>AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/2.png" alt=""></p><h3 id="exchange类型"><a href="#exchange类型" class="headerlink" title="exchange类型"></a>exchange类型</h3><ul><li>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键， headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</li></ul><ul><li>Direct Exchange</li></ul><p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/3.png" alt=""></p><ul><li>Fanout Exchange</li></ul><p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/4.png" alt=""></p><ul><li>Topic Exchange</li></ul><p>topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“<em>”。#匹配0个或多个单词，</em>匹配一个单词。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/5.png" alt=""></p><h2 id="docker快速安装"><a href="#docker快速安装" class="headerlink" title="docker快速安装"></a>docker快速安装</h2><ul><li><p>1.拉取镜像</p><ul><li><p>指定版本，该版本包含了web控制页面</p><p>docker pull rabbitmq:3.8.2-management</p></li></ul></li><li><p>2.运行镜像</p><ul><li><p>方式一：默认guest 用户，密码也是 guest</p><p>docker run -d –hostname my-rabbit –name rabbit -p 15672:15672 -p 5672:5672 rabbitmq:3.8.2-management</p></li><li><p>方式二：设置用户名和密码</p><p>docker run -d –hostname my-rabbit –name rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 rabbitmq:3.8.2-management</p></li></ul></li><li><p>3.访问url页面</p></li></ul><p><a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/6.jpg" alt=""></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>1.运行流程</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/8.jpg" alt=""></p><ul><li>2.添加交换器</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/7.jpg" alt=""></p><ul><li>3.添加绑定规则</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/9.jpg" alt=""></p><ul><li>4.发布消息</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/10.jpg" alt=""></p><ul><li>5.获取消息</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/11.jpg" alt=""></p><h2 id="整合rabbitmq"><a href="#整合rabbitmq" class="headerlink" title="整合rabbitmq"></a>整合rabbitmq</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>    &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;                &lt;scope&gt;test&lt;/scope&gt;                &lt;exclusions&gt;                    &lt;exclusion&gt;                        &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                        &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                    &lt;/exclusion&gt;                &lt;/exclusions&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;                &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;                &lt;scope&gt;test&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;</code></pre><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>application.properties</p><pre><code>    spring.rabbitmq.host=192.168.206.131    #linux主机地址    spring.rabbitmq.username=guest    spring.rabbitmq.password=guest    spring.rabbitmq.port=5672</code></pre><h3 id="测试rabbitmq"><a href="#测试rabbitmq" class="headerlink" title="测试rabbitmq"></a>测试rabbitmq</h3><ul><li>RabbitTemplate：消息发送处理组件</li></ul><h4 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h4><pre><code>    @Autowired    RabbitTemplate rabbitTemplate;    /**     * 1.单播（点对点）     */    @Test    void test01() {        //需要自己构造一个Message，定义消息体和消息头        //rabbitTemplate.send(exchange,routekey,message);        //object默认当成消息体，只需要传入要发送的对象，自动序列化发送给rabbitmq        //rabbitTemplate.convertAndSend(exchange,routekey,message);        Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();        map.put(&quot;msg&quot;,&quot;这是第一条消息&quot;);        map.put(&quot;data&quot;, Arrays.asList(&quot;helloworld&quot;,123,true));        //对象被默认序列化发送出去，是java的序列化规则，我们需要把它转换为json规则        //rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;atguigu.news&quot;,map);        rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;atguigu.news&quot;,map);    }    /**         * 广播（所有键全部发送）         */        @Test        public void test02(){            rabbitTemplate.convertAndSend(&quot;exchange.fanout&quot;,&quot;&quot;,new Book(&quot;上海堡垒&quot;,&quot;江南&quot;));        }</code></pre><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ul><li>对象被默认序列化发送出去，是java的序列化规则，我们需要把它转换为json规则</li></ul><p>MyAMQPConfig</p><pre><code>    //序列化配置    @Configuration    public class MyAMQPConfig {        @Bean        public MessageConverter messageConverter(){                return new Jackson2JsonMessageConverter();        }    }</code></pre><h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><pre><code>    //获取消息，获取完之后就从消息队列里删除        @Test        public void receive(){            Object o = rabbitTemplate.receiveAndConvert(&quot;atguigu.emps&quot;);            System.out.println(o.getClass());            System.out.println(o);        }</code></pre><h3 id="监听机制"><a href="#监听机制" class="headerlink" title="监听机制"></a>监听机制</h3><ul><li><p>@RabbitListener + @EnableRabbit(放于主程序前)    </p><p>  //开启基于注解的rabbitmq监听机制</p></li></ul><pre><code>    @Service    public class BookService {        @RabbitListener(queues = &quot;atguigu.news&quot;)    //参数类型是数组，可以监听多个消息队列        //只要这个消息队列中有消息进来，这个方法就会进行        public void receive(Object o){            System.out.println(&quot;收到消息&quot;+o);        }    }</code></pre><h3 id="amqpadmin"><a href="#amqpadmin" class="headerlink" title="amqpadmin"></a>amqpadmin</h3><ul><li>AmqpAdmin</li></ul><p>rabbitmq系统管理功能组件</p><ul><li>功能</li></ul><p>创建和删除Queue，Exchange，Binding</p><pre><code>    @Autowired    AmqpAdmin amqpAdmin;    /**     * declare是创建，delete是删除     * destination：目的地（哪个消息队列）     * Binding.DestinationType.QUEUE  绑定的类型是queue     * durable:是否持久化     * routingkey：路由键     */    @Test    public void create(){        //创建exchange        amqpAdmin.declareExchange(new DirectExchange(&quot;amqpadmin.exchange&quot;));        System.out.println(&quot;创建exchange成功&quot;);        //创建queue        amqpAdmin.declareQueue(new Queue(&quot;amqpadmin.queue&quot;,true));    //durable:是否持久化        //创建Binding        amqpAdmin.declareBinding(new Binding(&quot;amqpadmin.queue&quot;,Binding.DestinationType.QUEUE,&quot;amqpadmin.exchange&quot;,&quot;amqpadmin.haha&quot;,null));    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot消息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot高级缓存</title>
      <link href="/2020/02/10/springboot-gao-ji-huan-cun-cache/"/>
      <url>/2020/02/10/springboot-gao-ji-huan-cun-cache/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot高级-缓存cache并且整合redis"><a href="#springboot高级-缓存cache并且整合redis" class="headerlink" title="springboot高级,缓存cache并且整合redis"></a>springboot高级,缓存cache并且整合redis</h1><h1 id="springboot缓存"><a href="#springboot缓存" class="headerlink" title="springboot缓存"></a>springboot缓存</h1><p>缓存的场景</p><ul><li>临时性数据存储【校验码】</li><li>避免频繁因为相同的内容查询数据库【查询的信息】</li></ul><h2 id="jsr107缓存规范"><a href="#jsr107缓存规范" class="headerlink" title="jsr107缓存规范"></a>jsr107缓存规范</h2><blockquote><p>用的比较少</p></blockquote><p>Java Caching定义了5个核心接口</p><ul><li><p>CachingProvider</p><p>定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期间访问多个CachingProvider</p></li><li><p>CacheManager</p><p>定义了创建、配置、获取、管理和控制多个唯一命名的Cache,这些Cache存在于CacheManage的上下文中，一个CacheManage只被一个CachingProvider拥有</p></li><li><p>Cache</p><p>类似于Map的数据结构并临时储存以key为索引的值，一个Cache仅仅被一个CacheManage所拥有</p></li><li><p>Entry</p><p>存储在Cache中的key-value对</p></li><li><p>Expiry</p><p>存储在Cache的条目有一个定义的有效期，一旦超过这个时间，就会设置过期的状态，过期无法被访问，更新，删除。缓存的有效期可以通过ExpiryPolicy设置。</p></li></ul><h2 id="spring的缓存抽象"><a href="#spring的缓存抽象" class="headerlink" title="spring的缓存抽象"></a>spring的缓存抽象</h2><p>包括一些JSR107的注解</p><p>CahceManager</p><p>Cache</p><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><p><strong>重要的概念&amp;缓存注解</strong></p><table><thead><tr><th></th><th align="left">功能</th></tr></thead><tbody><tr><td>Cache</td><td align="left">缓存接口，定义缓存操作，实现有：RedisCache、EhCacheCache、ConcurrentMapCache等</td></tr><tr><td>CacheManager</td><td align="left">缓存管理器，管理各种缓存（Cache）组件</td></tr><tr><td>@Cacheable</td><td align="left">针对方法配置，根据方法的请求参数对其结果进行缓存</td></tr><tr><td>@CacheEvict</td><td align="left">清空缓存</td></tr><tr><td>@CachePut</td><td align="left">保证方法被调用，又希望结果被缓存 update，调用，将信息更新缓存</td></tr><tr><td>@EnableCaching</td><td align="left">开启基于注解的缓存</td></tr><tr><td>KeyGenerator</td><td align="left">缓存数据时key生成的策略</td></tr><tr><td>serialize</td><td align="left">缓存数据时value序列化策略</td></tr></tbody></table><h2 id="整合项目"><a href="#整合项目" class="headerlink" title="整合项目"></a>整合项目</h2><p>springboot 2.2.3+web+mysql+mybatis+cache</p><h3 id="导入相关配置"><a href="#导入相关配置" class="headerlink" title="导入相关配置"></a>导入相关配置</h3><pre><code>    &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;                &lt;scope&gt;test&lt;/scope&gt;                &lt;exclusions&gt;                    &lt;exclusion&gt;                        &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                        &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                    &lt;/exclusion&gt;                &lt;/exclusions&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;2.1.1&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                &lt;scope&gt;runtime&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;                &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;1.1.20&lt;/version&gt;            &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>application.yml</p><pre><code>spring:        datasource:          username: root          password: 980508          url: jdbc:mysql://localhost:3306/spring-cache?serverTimezone=UTC          driver-class-name: com.mysql.cj.jdbc.Driver          initialization-mode: always#开启驼峰命名法mybatis:  configuration:    map-underscore-to-camel-case: true</code></pre><p>application.properties</p><pre><code># 开启日志，打印sql语句logging.level.com.atguigu.mapper = debug# 打印配置报告debug=true</code></pre><h3 id="创建bean实例"><a href="#创建bean实例" class="headerlink" title="创建bean实例"></a>创建bean实例</h3><p>Department</p><pre><code>package com.atguigu.bean;public class Department {    private Integer id;    private String departmentName;    public Department() {        super();        // TODO Auto-generated constructor stub    }    public Department(Integer id, String departmentName) {        super();        this.id = id;        this.departmentName = departmentName;    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getDepartmentName() {        return departmentName;    }    public void setDepartmentName(String departmentName) {        this.departmentName = departmentName;    }    @Override    public String toString() {        return &quot;Department [id=&quot; + id + &quot;, departmentName=&quot; + departmentName + &quot;]&quot;;    }}</code></pre><p>Employee</p><pre><code>package com.atguigu.bean;public class Employee {    private Integer id;    private String lastName;    private String email;    private Integer gender; //性别 1男  0女    private Integer dId;    public Employee() {        super();    }    public Employee(Integer id, String lastName, String email, Integer gender, Integer dId) {        super();        this.id = id;        this.lastName = lastName;        this.email = email;        this.gender = gender;        this.dId = dId;    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getLastName() {        return lastName;    }    public void setLastName(String lastName) {        this.lastName = lastName;    }    public String getEmail() {        return email;    }    public void setEmail(String email) {        this.email = email;    }    public Integer getGender() {        return gender;    }    public void setGender(Integer gender) {        this.gender = gender;    }    public Integer getdId() {        return dId;    }    public void setdId(Integer dId) {        this.dId = dId;    }    @Override    public String toString() {        return &quot;Employee [id=&quot; + id + &quot;, lastName=&quot; + lastName + &quot;, email=&quot; + email + &quot;, gender=&quot; + gender + &quot;, dId=&quot;                + dId + &quot;]&quot;;    }}</code></pre><h3 id="创建mapper接口映射数据库"><a href="#创建mapper接口映射数据库" class="headerlink" title="创建mapper接口映射数据库"></a>创建mapper接口映射数据库</h3><p>DepartmentMapper</p><pre><code>package com.atguigu.mapper;import com.atguigu.bean.Department;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;public interface DepartmentMapper {    @Select(&quot;select * from department where id = #{id}&quot;)    public Department getDepById(Integer id);    @Update(&quot;update department set departmentName=#{departmentName} where id=#{id}&quot;)    public void updateDep(Department department);    @Delete(&quot;delete from department where id=#{id}&quot;)    public void deleteDepById(Integer id);    @Insert(&quot;insert into department (departmentName)values(#{departmentName})&quot;)    public void insertDep(Department department);}</code></pre><p>EmployeeMapper</p><pre><code>package com.atguigu.mapper;import com.atguigu.bean.Employee;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;public interface EmployeeMapper {    @Select(&quot;select * from Employee where id = #{id}&quot;)    public Employee getEmpById(Integer id);    @Update(&quot; update Employee set lastName=#{lastName},email=#{email},gender=#{gender},d_id=#{dId} where id=#{id}&quot;)    public void updateEmp(Employee employee);    @Delete(&quot;delete form Employee where id=#{id}&quot;)    public void deleteEmpById(Integer id);    @Insert(&quot;insert into Employee(lastName,email,gender,d_id)values(#{lastName},#{email},#{gender},#{dId})&quot;)    public void insertEmp(Employee employee);    @Select(&quot;select * from Employee where lastName = #{lastName}&quot;)    public Employee getEmpByLastName(String lastName);}</code></pre><h3 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h3><p>主程序添加注解MapperScan，并且使用@EnableCaching开启缓存</p><pre><code>@EnableCaching@MapperScan(&quot;com.atguigu.mapper&quot;)@SpringBootApplicationpublic class SpringBoot01CacheApplication {    public static void main(String[] args) {        SpringApplication.run(SpringBoot01CacheApplication.class, args);    }}</code></pre><h3 id="编写service来具体实现mapper中的方法"><a href="#编写service来具体实现mapper中的方法" class="headerlink" title="编写service来具体实现mapper中的方法"></a>编写service来具体实现mapper中的方法</h3><p>将方法的运行结果进行缓存，以后要是再有相同的数据，直接从缓存中获取，不用调用方法</p><p> CacheManager中管理多个Cache组件，对缓存的真正CRUD操作在Cache组件中，每个缓存组件都有自己的唯一名字；</p><p> 属性：</p><ul><li>CacheName/value:指定存储缓存组件的名字</li><li>key:缓存数据使用的key,可以使用它来指定。默认是使用方法参数的值，1-方法的返回值</li><li>编写Spel表达式：#id 参数id的值， #a0/#p0 #root.args[0]</li><li>keyGenerator:key的生成器，自己可以指定key的生成器的组件id</li><li>key/keyGendertor二选一使用</li><li>cacheManager指定Cache管理器，或者cacheReslover指定获取解析器</li><li>condition:指定符合条件的情况下，才缓存； ex:condition = “#id&gt;0”</li><li>unless：否定缓存，unless指定的条件为true，方法的返回值就不会被缓存，可以获取到结果进行判断  ;  ex:unless = “#result == null”</li><li>sync:是否使用异步模式，unless不支持</li></ul><h4 id="各种注解的使用"><a href="#各种注解的使用" class="headerlink" title="各种注解的使用"></a>各种注解的使用</h4><pre><code>@Servicepublic class EmployeeService {    @Autowired    EmployeeMapper employeeMapper;    /**     * cacheName：  指定缓存组件的名字，也可以用value来表示     * key: #id表示id的值作为key   还有另一种keyGenerator:key的生成器，自己可以指定key的生成器的组件id,自己了解，这里就不演示了     * condition： 符合条件下，才缓存，这里表示id&gt;1才缓存     * unless:  符合条件下，不缓存，这里表示id==0则不缓存     * @param id     * @return     */    @Cacheable(cacheNames = &quot;emp&quot;,key = &quot;#id&quot;,condition = &quot;#id&gt;1&quot;,unless = &quot;#id==0&quot;)    public Employee getEmp(Integer id){        System.out.println(&quot;查询&quot;+id+&quot;号员工&quot;);        Employee employee=employeeMapper.getEmpById(id);        return employee;    }     /**     *@CachePut：既调用方法，又更新缓存     * 修改了数据库的某个数据，同时又更新了缓存     * 运行时机：（与Cacheable相反）     *      1.先调用目标方法     *      2.将目标方法缓存起来     *     * 测试步骤     * 1.查询1号员工，查询到的结果会放到缓存中     *          key：1   value：lastName：zhangsan     * 2.以后查询的结果还是之前的结果     * 3.更新1号员工     * 4.查询1号员工，应该是更新后的员工，key应该这样写     *      key=&quot;#employee.id&quot;   使用传入参数的员工id     *      key=&quot;#result.id&quot;     使用返回后的员工id     *      注：@Cacheable中不能写#result.id     * @param employee     * @return     */    @CachePut(cacheNames = &quot;emp&quot;,key = &quot;#result.id&quot;)    public Employee updateEmp(Employee employee){        System.out.println(&quot;更新&quot;+employee.getId()+&quot;号员工&quot;);        employeeMapper.updateEmp(employee);        return employee;    }     /**     * @CacheEvict：清除缓存（常用于删除之类的）     * key：指定清除的数据     * allEntries=true：指定清除这个缓存中的所有数据，默认是false     * beforeInvocation = false : 缓存的清除是否在方法之前清除，默认是false     *      默认是在方法之后清除（如果出现异常错误则不清除）     * beforeInvocation = true ：缓存的清除在方法之前清除，不管是否出现异常都会清除     * @param id     */    @CacheEvict(cacheNames = &quot;emp&quot;,key = &quot;#id&quot;,beforeInvocation = true)    public void deleteEmp(Integer id){        System.out.println(&quot;清除&quot;+id+&quot;号员工缓存&quot;);        //employeeMapper.deleteEmpById(id);     //同时删除数据库中的数据        int i=10/0;    }    //@Caching 定义复杂的缓存规则    /**     * 这里通过查询lastName来测试     * 当查询lastName完之后，再通过id和email来查就不需要通过数据库了     * 但是通过lastName来查询还是需要通过数据库，因为CachePut注解的作用是先调用目标方法，方法必被执行     *     * 公共的配置可以通过@CacheConfig写在一起，标注在类前，比如配置cacheName     * @param lastName     * @return     */    @Caching(            cacheable = {                    @Cacheable(key = &quot;#lastName&quot;)            },            put = {                    @CachePut(key = &quot;#result.id&quot;),                    @CachePut(key = &quot;#result.email&quot;)            }    )    public Employee getEmpByLastName(String lastName){        System.out.println(&quot;查询&quot;+lastName);        Employee emp = employeeMapper.getEmpByLastName(lastName);        return emp;    }}</code></pre><h3 id="编写controller测试"><a href="#编写controller测试" class="headerlink" title="编写controller测试"></a>编写controller测试</h3><pre><code>@RestControllerpublic class EmployeeController {    @Autowired    EmployeeService employeeService;    @GetMapping(&quot;/emp/{id}&quot;)    public Employee getEmployee(@PathVariable(&quot;id&quot;) Integer id){        Employee emp = employeeService.getEmp(id);        return emp;    }    @GetMapping(&quot;/emp&quot;)    public Employee updateEmployee(Employee employee){        Employee emp = employeeService.updateEmp(employee);        return emp;    }    @GetMapping(&quot;/delemp/{id}&quot;)    public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id){        employeeService.deleteEmp(id);        return &quot;清除&quot;+id+&quot;号员工缓存成功&quot;;    }    @GetMapping(&quot;/emp/lastname/{lastName}&quot;)    public Employee getEmpByLastName(@PathVariable(&quot;lastName&quot;) String lastName){        Employee emp= employeeService.getEmpByLastName(lastName);        return emp;    }}</code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>第一次访问会查询数据库，继续访问缓存中取值</p><h2 id="整合redis"><a href="#整合redis" class="headerlink" title="整合redis"></a>整合redis</h2><ul><li>在上面的基础上加一部分东西</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>下载windows版本的压缩包 <a href="https://github.com/microsoftarchive/redis/releases" target="_blank" rel="noopener">链接</a></li><li>下载RedisDesktopManager（一个桌面化的redis工具）</li></ul><h3 id="导入相关依赖"><a href="#导入相关依赖" class="headerlink" title="导入相关依赖"></a>导入相关依赖</h3><pre><code>    &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>application.yml</p><pre><code>    # REDIS (RedisProperties)    # Redis数据库索引（默认为0）    spring.redis.database=0    # Redis服务器地址    spring.redis.host=localhost    # Redis服务器连接端口    spring.redis.port=6379    # Redis服务器连接密码（默认为空）    #spring.redis.password=980508    # 连接池最大连接数（使用负值表示没有限制）    spring.redis.jedis.pool.max-active=8    # 连接池最大阻塞等待时间（使用负值表示没有限制）    spring.redis.jedis.pool.max-wait=-1    # 连接池中的最大空闲连接    spring.redis.jedis.pool.max-idle=8    # 连接池中的最小空闲连接    spring.redis.jedis.pool.min-idle=0</code></pre><h3 id="测试redis"><a href="#测试redis" class="headerlink" title="测试redis"></a>测试redis</h3><ul><li><p>redis中常见的五大数据类型</p><ul><li>String（字符串），List（列表），Set（集合），Hash（散列），ZSet   有序集合）</li></ul></li><li><p>redis两个template</p><ul><li><p>StringRedisTemplate stringRedisTemplate;    //操作k-v都是字符串的</p></li><li><p>RedisTemplate redisTemplate;    //操作k-v都是对象的</p></li></ul></li><li><p>具体用法（redisTemplate是一样的）</p><ul><li>stringRedisTemplate.opsForValue()    [String（字符串）]</li><li>stringRedisTemplate.opsForList()    [List（列表）]</li><li>stringRedisTemplate.opsForSet()    [Set（集合）]</li><li>stringRedisTemplate.opsForHash()    [Hash（散列）]</li><li>stringRedisTemplate.opsForZSet()    [ZSet（有序集合）]</li></ul></li></ul><h4 id="test01"><a href="#test01" class="headerlink" title="test01"></a>test01</h4><pre><code>    //测试给redis中保存数据，操作k-v都是字符串的    @Autowired    StringRedisTemplate stringRedisTemplate;    //操作k-v都是字符串的    @Test    public void test01(){        //stringRedisTemplate.opsForValue().append(&quot;msg&quot;,&quot;lihua&quot;);        //字符串        //String msg=stringRedisTemplate.opsForValue().get(&quot;msg&quot;);        //System.out.println(msg);        stringRedisTemplate.opsForList().leftPush(&quot;mylist&quot;,&quot;1&quot;);        //列表        stringRedisTemplate.opsForList().leftPush(&quot;mylist&quot;,&quot;2&quot;);    }</code></pre><h4 id="test02"><a href="#test02" class="headerlink" title="test02"></a>test02</h4><pre><code>    //测试保存对象    @Autowired    RedisTemplate redisTemplate;    //操作k-v都是对象的    @Autowired    EmployeeMapper employeeMapper;    @Test    public void test02(){        Employee EmpById=employeeMapper.getEmpById(1);        //默认如果保存对象，使用jdk序列化机制，序列化的数据保存到redis中        redisTemplate.opsForValue().set(&quot;emp-01&quot;,EmpById);        redisTemplate.opsForValue().set(&quot;dept-01&quot;,departmentMapper.getDepById(1));    }</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul><li><p>保存对象存进redis中的数据不是json数据，我们需要把它转换成json数据，这样我们就需要使用序列话机制，改变redisTemplate默认的序列化规则</p></li><li><p>默认保存对象，是使用jdk序列化规则，我们需要改成json序列化规则</p></li></ul><p>Employee</p><pre><code>    //实现一个接口    public class Employee implements Serializable{</code></pre><ul><li>创建一个配置类</li></ul><p>config.MyRedisConfig</p><pre><code>    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        // 配置连接工厂        template.setConnectionFactory(factory);        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）        Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jacksonSeial.setObjectMapper(om);        // 值采用json序列化        template.setValueSerializer(jacksonSeial);        //使用StringRedisSerializer来序列化和反序列化redis的key值        template.setKeySerializer(new StringRedisSerializer());        // 设置hash key 和value序列化模式        template.setHashKeySerializer(new StringRedisSerializer());        template.setHashValueSerializer(jacksonSeial);        template.afterPropertiesSet();        return template;    }</code></pre><h3 id="自定义Cachemanager"><a href="#自定义Cachemanager" class="headerlink" title="自定义Cachemanager"></a>自定义Cachemanager</h3><ul><li>缓存管理器,转换为json数据</li><li>当我们运行存入缓存中的数据不是json数据，这时我们需要自定义CacheManager，把它转换为json数据</li></ul><p>config.MyRedisConfig</p><pre><code>    /**     * 缓存管理器,转换为json数据     */    @Bean    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {        //初始化一个RedisCacheWriter        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory);        //设置CacheManager的值序列化方式为json序列化        RedisSerializer&lt;Object&gt; jsonSerializer = new GenericJackson2JsonRedisSerializer();        RedisSerializationContext.SerializationPair&lt;Object&gt; pair = RedisSerializationContext.SerializationPair                .fromSerializer(jsonSerializer);        RedisCacheConfiguration defaultCacheConfig=RedisCacheConfiguration.defaultCacheConfig()                .serializeValuesWith(pair);        //设置默认超过期时间是30秒        defaultCacheConfig.entryTtl(Duration.ofSeconds(30));        //初始化RedisCacheManager        return new RedisCacheManager(redisCacheWriter, defaultCacheConfig);    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot高级缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot jdbc</title>
      <link href="/2020/01/13/springboot-lian-jie-jdbc/"/>
      <url>/2020/01/13/springboot-lian-jie-jdbc/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot连接jdbc数据库并且整合Druid数据源"><a href="#springboot连接jdbc数据库并且整合Druid数据源" class="headerlink" title="springboot连接jdbc数据库并且整合Druid数据源"></a>springboot连接jdbc数据库并且整合Druid数据源</h1><h1 id="连接jdbc数据库"><a href="#连接jdbc数据库" class="headerlink" title="连接jdbc数据库"></a>连接jdbc数据库</h1><h2 id="导入相关依赖"><a href="#导入相关依赖" class="headerlink" title="导入相关依赖"></a>导入相关依赖</h2><pre><code>&lt;!--导入jdbc相关依赖--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.1.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><h2 id="配置数据库连接信息"><a href="#配置数据库连接信息" class="headerlink" title="配置数据库连接信息"></a>配置数据库连接信息</h2><ul><li>application.yml</li></ul><pre><code>    spring:      datasource:        username: root        password: 数据库密码        url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC        driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><h2 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h2><ul><li>在测试类中测试</li></ul><pre><code>    @SpringBootTest    class SpringBootData06JdbcApplicationTests {      @Autowired      DataSource dataSource;      //测试连接数据库      @Test      void contextLoads() throws SQLException {        System.out.println(dataSource.getClass());        Connection connection = dataSource.getConnection();        System.out.println(connection);      }    }</code></pre><ul><li>springboot默认是使用com.zaxxer.hikari.HikariDataSource作为数据源，</li></ul><p>2.0以下是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p><pre><code>    如果出现com.zaxxer.hikari.HikariDataSource则表示连接成功</code></pre><h2 id="数据库查询数据返回网页"><a href="#数据库查询数据返回网页" class="headerlink" title="数据库查询数据返回网页"></a>数据库查询数据返回网页</h2><pre><code>    @RestController    public class JdbcController {        //查询数据库的数据返回网页        @Autowired        JdbcTemplate jdbcTemplate;        @GetMapping(&quot;/query&quot;)        public Map&lt;String,Object&gt; map(){            List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;SELECT * from department&quot;);            return list.get(0);        }    }</code></pre><p><a href="http://localhost:8080/query" target="_blank" rel="noopener">查询</a>  </p><h1 id="整合Druid数据源"><a href="#整合Druid数据源" class="headerlink" title="整合Druid数据源"></a>整合Druid数据源</h1><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><ul><li>在springboot项目中导入druid数据源依赖<a href="https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter" target="_blank" rel="noopener">点击查询最新依赖</a></li></ul><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.20&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><ul><li>application.yml</li></ul><pre><code>    #jdbc的配置    spring:      datasource:        password: 980508        username: root        url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8        driver-class-name: com.mysql.cj.jdbc.Driver        initialization-mode: always        #整合Druid数据源        type: com.alibaba.druid.pool.DruidDataSource        druid:          # 连接池配置          # 配置初始化大小、最小、最大          initial-size: 1          min-idle: 1          max-active: 20          # 配置获取连接等待超时的时间          max-wait: 3000          validation-query: SELECT 1 FROM DUAL          test-on-borrow: false          test-on-return: false          test-while-idle: true          pool-prepared-statements: true          time-between-eviction-runs-millis: 60000          min-evictable-idle-time-millis: 300000          filters: stat,wall,slf4j          # 配置web监控,默认配置也和下面相同(除用户名密码，enabled默认false外)，其他可以不配          web-stat-filter:            enabled: true            url-pattern: /*            exclusions: &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;          stat-view-servlet:            enabled: true            url-pattern: /druid/*            login-username: lihuazhou            login-password: 980508            allow: 192.168.182.1</code></pre><h2 id="测试类查看使用的数据源"><a href="#测试类查看使用的数据源" class="headerlink" title="测试类查看使用的数据源"></a>测试类查看使用的数据源</h2><pre><code>    @SpringBootTest    class SpringbootJdbcApplicationTests {        @Autowired        private DataSource dataSource;        @Test        void contextLoads() throws SQLException {            System.out.println(dataSource.getClass());            System.out.println(dataSource.getConnection());        }    }</code></pre><h2 id="编写一个Druid配置类"><a href="#编写一个Druid配置类" class="headerlink" title="编写一个Druid配置类"></a>编写一个Druid配置类</h2><ul><li><p>DruidConfig</p></li><li><p>需要把配置信息从application.yml中加入到容器中</p></li></ul><pre><code>    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)            @Bean            public DataSource druid(){                return  new DruidDataSource();            }</code></pre><ul><li>配置一个Servelet容器来管理后台（Druid的监控）</li></ul><pre><code>    @Bean    public ServletRegistrationBean statViewServlet(){        ServletRegistrationBean bean=new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;); //druid后台的路径        Map&lt;String,String&gt; initParams =new HashMap&lt;&gt;();        initParams.put(&quot;loginUsername&quot;,&quot;lihuazhou&quot;);        initParams.put(&quot;loginPassword&quot;,&quot;980508&quot;);        initParams.put(&quot;allow&quot;,&quot;&quot;);//可以设置为localhost下才能访问，默认是所有都可以访问        initParams.put(&quot;deny&quot;,&quot;&quot;);//默认是不禁用路径        bean.setInitParameters(initParams);        return bean;    }</code></pre><ul><li>配置一个web监控的Filter（拦截一些操作，有点类似拦截器）</li></ul><pre><code>    @Bean    public FilterRegistrationBean webStatFilter(){        FilterRegistrationBean bean = new FilterRegistrationBean();        bean.setFilter(new WebStatFilter());        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);     //除了这些操作的数据，其他都会被拦截        bean.setInitParameters(initParams);        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));      return  bean;      }</code></pre><ul><li>Druid页面<h1 id="springboot连接jdbc数据库并且整合Druid数据源-1"><a href="#springboot连接jdbc数据库并且整合Druid数据源-1" class="headerlink" title="springboot连接jdbc数据库并且整合Druid数据源"></a>springboot连接jdbc数据库并且整合Druid数据源</h1></li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>1.<a href="#连接jdbc数据库">连接jdbc数据库</a><ul><li>1.<a href="#导入相关依赖">导入相关依赖</a></li><li>2.<a href="#配置数据库连接信息">配置数据库连接信息</a></li><li>3.<a href="#测试连接">测试连接</a></li><li>4.<a href="#数据库查询数据返回网页">数据库查询数据返回网页</a></li></ul></li><li>1.<a href="#整合Druid数据源">整合Druid数据源</a><ul><li>1.<a href="#导入依赖">导入依赖</a></li><li>2.<a href="#配置信息">配置信息</a></li><li>3.<a href="#测试类查看使用的数据源">测试类查看使用的数据源</a></li><li>4.<a href="#编写一个Druid配置类">编写一个Druid配置类</a></li></ul></li></ul><h1 id="连接jdbc数据库-1"><a href="#连接jdbc数据库-1" class="headerlink" title="连接jdbc数据库"></a>连接jdbc数据库</h1><h2 id="导入相关依赖-1"><a href="#导入相关依赖-1" class="headerlink" title="导入相关依赖"></a>导入相关依赖</h2><pre><code>&lt;!--导入jdbc相关依赖--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.1.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><h2 id="配置数据库连接信息-1"><a href="#配置数据库连接信息-1" class="headerlink" title="配置数据库连接信息"></a>配置数据库连接信息</h2><ul><li>application.yml</li></ul><pre><code>    spring:      datasource:        username: root        password: 数据库密码        url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC        driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><h2 id="测试连接-1"><a href="#测试连接-1" class="headerlink" title="测试连接"></a>测试连接</h2><ul><li>在测试类中测试</li></ul><pre><code>    @SpringBootTest    class SpringBootData06JdbcApplicationTests {      @Autowired      DataSource dataSource;      //测试连接数据库      @Test      void contextLoads() throws SQLException {        System.out.println(dataSource.getClass());        Connection connection = dataSource.getConnection();        System.out.println(connection);      }    }</code></pre><ul><li>springboot默认是使用com.zaxxer.hikari.HikariDataSource作为数据源，</li></ul><p>2.0以下是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p><pre><code>    如果出现com.zaxxer.hikari.HikariDataSource则表示连接成功</code></pre><h2 id="数据库查询数据返回网页-1"><a href="#数据库查询数据返回网页-1" class="headerlink" title="数据库查询数据返回网页"></a>数据库查询数据返回网页</h2><pre><code>    @RestController    public class JdbcController {        //查询数据库的数据返回网页        @Autowired        JdbcTemplate jdbcTemplate;        @GetMapping(&quot;/query&quot;)        public Map&lt;String,Object&gt; map(){            List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;SELECT * from department&quot;);            return list.get(0);        }    }</code></pre><p><a href="http://localhost:8080/query" target="_blank" rel="noopener">查询</a>  </p><h1 id="整合Druid数据源-1"><a href="#整合Druid数据源-1" class="headerlink" title="整合Druid数据源"></a>整合Druid数据源</h1><h2 id="导入依赖-1"><a href="#导入依赖-1" class="headerlink" title="导入依赖"></a>导入依赖</h2><ul><li>在springboot项目中导入druid数据源依赖<a href="https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter" target="_blank" rel="noopener">点击查询最新依赖</a></li></ul><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.20&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h2 id="配置信息-1"><a href="#配置信息-1" class="headerlink" title="配置信息"></a>配置信息</h2><ul><li>application.yml</li></ul><pre><code>    #jdbc的配置    spring:      datasource:        password: 980508        username: root        url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8        driver-class-name: com.mysql.cj.jdbc.Driver        initialization-mode: always        #整合Druid数据源        type: com.alibaba.druid.pool.DruidDataSource        druid:          # 连接池配置          # 配置初始化大小、最小、最大          initial-size: 1          min-idle: 1          max-active: 20          # 配置获取连接等待超时的时间          max-wait: 3000          validation-query: SELECT 1 FROM DUAL          test-on-borrow: false          test-on-return: false          test-while-idle: true          pool-prepared-statements: true          time-between-eviction-runs-millis: 60000          min-evictable-idle-time-millis: 300000          filters: stat,wall,slf4j          # 配置web监控,默认配置也和下面相同(除用户名密码，enabled默认false外)，其他可以不配          web-stat-filter:            enabled: true            url-pattern: /*            exclusions: &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;          stat-view-servlet:            enabled: true            url-pattern: /druid/*            login-username: lihuazhou            login-password: 980508            allow: 192.168.182.1</code></pre><h2 id="测试类查看使用的数据源-1"><a href="#测试类查看使用的数据源-1" class="headerlink" title="测试类查看使用的数据源"></a>测试类查看使用的数据源</h2><pre><code>    @SpringBootTest    class SpringbootJdbcApplicationTests {        @Autowired        private DataSource dataSource;        @Test        void contextLoads() throws SQLException {            System.out.println(dataSource.getClass());            System.out.println(dataSource.getConnection());        }    }</code></pre><h2 id="编写一个Druid配置类-1"><a href="#编写一个Druid配置类-1" class="headerlink" title="编写一个Druid配置类"></a>编写一个Druid配置类</h2><ul><li><p>DruidConfig</p></li><li><p>需要把配置信息从application.yml中加入到容器中</p></li></ul><pre><code>    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)            @Bean            public DataSource druid(){                return  new DruidDataSource();            }</code></pre><ul><li>配置一个Servelet容器来管理后台（Druid的监控）</li></ul><pre><code>    @Bean    public ServletRegistrationBean statViewServlet(){        ServletRegistrationBean bean=new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;); //druid后台的路径        Map&lt;String,String&gt; initParams =new HashMap&lt;&gt;();        initParams.put(&quot;loginUsername&quot;,&quot;lihuazhou&quot;);        initParams.put(&quot;loginPassword&quot;,&quot;980508&quot;);        initParams.put(&quot;allow&quot;,&quot;&quot;);//可以设置为localhost下才能访问，默认是所有都可以访问        initParams.put(&quot;deny&quot;,&quot;&quot;);//默认是不禁用路径        bean.setInitParameters(initParams);        return bean;    }</code></pre><ul><li>配置一个web监控的Filter（拦截一些操作，有点类似拦截器）</li></ul><pre><code>    @Bean    public FilterRegistrationBean webStatFilter(){        FilterRegistrationBean bean = new FilterRegistrationBean();        bean.setFilter(new WebStatFilter());        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);     //除了这些操作的数据，其他都会被拦截        bean.setInitParameters(initParams);        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));      return  bean;      }</code></pre><ul><li>Druid页面</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/images/25.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot jdbc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
